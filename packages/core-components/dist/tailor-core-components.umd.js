(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('lodash/capitalize'), require('@tailor/utils'), require('lodash/filter'), require('lodash/flatMap'), require('lodash/intersection'), require('lodash/pick'), require('lodash/reduce'), require('lodash/reject'), require('lodash/partition'), require('lodash/takeRight'), require('lodash/find'), require('pluralize'), require('@extensionengine/vue-radio'), require('lodash/orderBy'), require('lodash/get'), require('lodash/keyBy'), require('lodash/map'), require('lodash/groupBy'), require('lodash/debounce'), require('lodash/sortBy'), require('lodash/cloneDeep'), require('lodash/isArray'), require('lodash/some'), require('lodash/isEmpty'), require('lodash/omit'), require('lodash/throttle'), require('vuedraggable'), require('lodash/findIndex'), require('lodash/head'), require('lodash/pullAt'), require('lodash/set'), require('lodash/last'), require('lodash/uniqueId'), require('lodash/mapKeys'), require('lodash/values')) :
  typeof define === 'function' && define.amd ? define(['exports', 'lodash/capitalize', '@tailor/utils', 'lodash/filter', 'lodash/flatMap', 'lodash/intersection', 'lodash/pick', 'lodash/reduce', 'lodash/reject', 'lodash/partition', 'lodash/takeRight', 'lodash/find', 'pluralize', '@extensionengine/vue-radio', 'lodash/orderBy', 'lodash/get', 'lodash/keyBy', 'lodash/map', 'lodash/groupBy', 'lodash/debounce', 'lodash/sortBy', 'lodash/cloneDeep', 'lodash/isArray', 'lodash/some', 'lodash/isEmpty', 'lodash/omit', 'lodash/throttle', 'vuedraggable', 'lodash/findIndex', 'lodash/head', 'lodash/pullAt', 'lodash/set', 'lodash/last', 'lodash/uniqueId', 'lodash/mapKeys', 'lodash/values'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.TailorCoreComponents = {}, global.capitalize$1, global.utils, global.filter, global.flatMap, global.intersection, global.pick, global.reduce, global.reject, global.partition, global.takeRgt, global.find, global.pluralize, global.vueRadio, global.orderBy, global.get$1, global.keyBy, global.map, global.groupBy, global.debounce, global.sortBy, global.cloneDeep, global.isArray$1, global.some, global.isEmpty, global.omit, global.throttle, global.Draggable, global.findIndex$1, global.head, global.pullAt, global.set, global.last, global.uniqueId, global.mapKeys$1, global.values$1));
}(this, (function (exports, capitalize$1, utils, filter, flatMap, intersection, pick, reduce, reject, partition, takeRgt, find, pluralize, vueRadio, orderBy, get$1, keyBy, map, groupBy, debounce, sortBy, cloneDeep, isArray$1, some, isEmpty, omit, throttle, Draggable, findIndex$1, head, pullAt, set, last, uniqueId, mapKeys$1, values$1) { 'use strict';

  function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

  var capitalize__default = /*#__PURE__*/_interopDefaultLegacy(capitalize$1);
  var filter__default = /*#__PURE__*/_interopDefaultLegacy(filter);
  var flatMap__default = /*#__PURE__*/_interopDefaultLegacy(flatMap);
  var intersection__default = /*#__PURE__*/_interopDefaultLegacy(intersection);
  var pick__default = /*#__PURE__*/_interopDefaultLegacy(pick);
  var reduce__default = /*#__PURE__*/_interopDefaultLegacy(reduce);
  var reject__default = /*#__PURE__*/_interopDefaultLegacy(reject);
  var partition__default = /*#__PURE__*/_interopDefaultLegacy(partition);
  var takeRgt__default = /*#__PURE__*/_interopDefaultLegacy(takeRgt);
  var find__default = /*#__PURE__*/_interopDefaultLegacy(find);
  var pluralize__default = /*#__PURE__*/_interopDefaultLegacy(pluralize);
  var orderBy__default = /*#__PURE__*/_interopDefaultLegacy(orderBy);
  var get__default = /*#__PURE__*/_interopDefaultLegacy(get$1);
  var keyBy__default = /*#__PURE__*/_interopDefaultLegacy(keyBy);
  var map__default = /*#__PURE__*/_interopDefaultLegacy(map);
  var groupBy__default = /*#__PURE__*/_interopDefaultLegacy(groupBy);
  var debounce__default = /*#__PURE__*/_interopDefaultLegacy(debounce);
  var sortBy__default = /*#__PURE__*/_interopDefaultLegacy(sortBy);
  var cloneDeep__default = /*#__PURE__*/_interopDefaultLegacy(cloneDeep);
  var isArray__default = /*#__PURE__*/_interopDefaultLegacy(isArray$1);
  var some__default = /*#__PURE__*/_interopDefaultLegacy(some);
  var isEmpty__default = /*#__PURE__*/_interopDefaultLegacy(isEmpty);
  var omit__default = /*#__PURE__*/_interopDefaultLegacy(omit);
  var throttle__default = /*#__PURE__*/_interopDefaultLegacy(throttle);
  var Draggable__default = /*#__PURE__*/_interopDefaultLegacy(Draggable);
  var findIndex__default = /*#__PURE__*/_interopDefaultLegacy(findIndex$1);
  var head__default = /*#__PURE__*/_interopDefaultLegacy(head);
  var pullAt__default = /*#__PURE__*/_interopDefaultLegacy(pullAt);
  var set__default = /*#__PURE__*/_interopDefaultLegacy(set);
  var last__default = /*#__PURE__*/_interopDefaultLegacy(last);
  var uniqueId__default = /*#__PURE__*/_interopDefaultLegacy(uniqueId);
  var mapKeys__default = /*#__PURE__*/_interopDefaultLegacy(mapKeys$1);
  var values__default = /*#__PURE__*/_interopDefaultLegacy(values$1);

  //
  var script$18 = {
    name: 'tailor-active-users',
    props: {
      users: {
        type: Array,
        "default": function _default() {
          return [];
        }
      },
      size: {
        type: Number,
        "default": 36
      }
    },
    filters: {
      capitalize: capitalize__default['default']
    }
  };

  /* script */
  var __vue_script__$18 = script$18;
  /* template */

  var __vue_render__$18 = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      staticClass: "d-flex align-center"
    }, _vm._l(_vm.users, function (ref) {
      var id = ref.id;
      var label = ref.label;
      var imgUrl = ref.imgUrl;
      return _c('v-avatar', {
        key: id,
        staticClass: "avatar",
        attrs: {
          "size": _vm.size,
          "color": "pink accent-2"
        }
      }, [_c('v-tooltip', {
        attrs: {
          "bottom": ""
        },
        scopedSlots: _vm._u([{
          key: "activator",
          fn: function fn(ref) {
            var on = ref.on;
            return [imgUrl ? _c('img', _vm._g({
              attrs: {
                "src": imgUrl,
                "alt": label,
                "aria-describedby": "activeUser-" + id,
                "tabindex": "0"
              }
            }, on)) : _vm._e()];
          }
        }], null, true)
      }, [_vm._v(" "), _c('span', {
        attrs: {
          "id": "activeUser-" + id
        }
      }, [_vm._v(_vm._s(label))])])], 1);
    }), 1);
  };

  var __vue_staticRenderFns__$18 = [];
  /* style */

  var __vue_inject_styles__$18 = function __vue_inject_styles__(inject) {
    if (!inject) return;
    inject("data-v-33d463d4_0", {
      source: ".avatar[data-v-33d463d4]{transition:all .2s}.avatar img[data-v-33d463d4]{padding:.125rem}.avatar[data-v-33d463d4]:focus-within,.avatar[data-v-33d463d4]:hover{transform:scale(1.1);z-index:1}.avatar:focus-within img[data-v-33d463d4]:focus,.avatar:hover img[data-v-33d463d4]:focus{outline:0}",
      map: undefined,
      media: undefined
    });
  };
  /* scoped */


  var __vue_scope_id__$18 = "data-v-33d463d4";
  /* module identifier */

  var __vue_module_identifier__$N = undefined;
  /* functional template */

  var __vue_is_functional_template__$18 = false;
  /* component normalizer */

  function __vue_normalize__$18(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "ActiveUsers.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    {
      var hook;

      if (style) {
        hook = function hook(context) {
          style.call(this, createInjector(context));
        };
      }

      if (hook !== undefined) {
        if (component.functional) {
          // register for functional component in vue file
          var originalRender = component.render;

          component.render = function renderWithStyleInjection(h, context) {
            hook.call(context);
            return originalRender(h, context);
          };
        } else {
          // inject component registration as beforeCreate hook
          var existing = component.beforeCreate;
          component.beforeCreate = existing ? [].concat(existing, hook) : [hook];
        }
      }
    }

    return component;
  }
  /* style inject */


  function __vue_create_injector__$N() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$N.styles || (__vue_create_injector__$N.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());
    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = {
        ids: [],
        parts: [],
        element: undefined
      });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;
        style.ids.push(id);

        if (css.map) {
          // https://developer.chrome.com/devtools/docs/javascript-debugging
          // this makes source maps inside style tags work properly in Chrome
          code += '\n/*# sourceURL=' + css.map.sources[0] + ' */'; // http://stackoverflow.com/a/26603875

          code += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(css.map)))) + ' */';
        }

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';
          if (css.media) el.setAttribute('media', css.media);

          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */


  var ActiveUsers$1 = __vue_normalize__$18({
    render: __vue_render__$18,
    staticRenderFns: __vue_staticRenderFns__$18
  }, __vue_inject_styles__$18, __vue_script__$18, __vue_scope_id__$18, __vue_is_functional_template__$18, __vue_module_identifier__$N, __vue_create_injector__$N);

  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  var script$17 = {
    name: 'add-new-element',
    props: {
      library: {
        type: Array,
        required: true
      },
      allowedTypes: {
        type: Array,
        required: true
      }
    },
    methods: {
      isAllowed: function isAllowed(type) {
        return !this.allowedTypes.length || this.allowedTypes.includes(type);
      }
    }
  };

  /* script */
  var __vue_script__$17 = script$17;
  /* template */

  var __vue_render__$17 = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('v-bottom-sheet', _vm._g(_vm._b({
      attrs: {
        "max-width": "1240",
        "inset": ""
      }
    }, 'v-bottom-sheet', _vm.$attrs, false), _vm.$listeners), [_c('div', {
      staticClass: "element-container grey lighten-5"
    }, [_c('div', {
      staticClass: "d-flex align-center py-4 px-10"
    }, [_vm._t("header")], 2), _vm._v(" "), _vm._l(_vm.library, function (group) {
      return _c('div', {
        key: group.name
      }, [_c('div', {
        staticClass: "group-heading grey--text text--darken-4"
      }, [_vm._v(_vm._s(group.name))]), _vm._v(" "), _c('div', {
        staticClass: "group-elements"
      }, _vm._l(group.elements, function (element) {
        return _c('v-hover', {
          key: element.position,
          scopedSlots: _vm._u([{
            key: "default",
            fn: function fn(ref) {
              var hover = ref.hover;
              return [_c('v-btn', {
                staticClass: "add-element",
                attrs: {
                  "disabled": !_vm.isAllowed(element.type),
                  "color": hover ? 'secondary accent-2' : 'blue-grey darken-4',
                  "text": ""
                },
                on: {
                  "click": function click($event) {
                    $event.stopPropagation();
                    return _vm.$emit('add', [element]);
                  }
                }
              }, [element.ui.icon ? _c('v-icon', {
                attrs: {
                  "size": "26",
                  "color": "primary darken-3"
                }
              }, [_vm._v("\n              " + _vm._s(element.ui.icon) + "\n            ")]) : _vm._e(), _vm._v(" "), _c('span', {
                staticClass: "button-text body-2"
              }, [_vm._v(_vm._s(element.name))])], 1)];
            }
          }], null, true)
        });
      }), 1)]);
    })], 2)]);
  };

  var __vue_staticRenderFns__$17 = [];
  /* style */

  var __vue_inject_styles__$17 = function __vue_inject_styles__(inject) {
    if (!inject) return;
    inject("data-v-5e4d908e_0", {
      source: ".element-container[data-v-5e4d908e]{min-height:20rem;padding:0 0 1.875rem;border-top-left-radius:.5rem;border-top-right-radius:.5rem;overflow:hidden}.group-heading[data-v-5e4d908e]{margin:0 2.5rem .375rem;padding-top:.5rem;font-size:.875rem;font-weight:500;line-height:1rem;text-align:left}.group-elements[data-v-5e4d908e]{display:flex;flex-wrap:wrap;width:100%;padding:0 1.875rem}.add-element[data-v-5e4d908e]{width:8.125rem;min-width:8.125rem;height:auto!important;min-height:4.375rem;padding:0!important;white-space:normal}.add-element[data-v-5e4d908e]  .v-btn__content{flex:1 1 100%;flex-direction:column;padding:.375rem;text-transform:none}.add-element .v-icon[data-v-5e4d908e]{padding:.125rem 0;font-size:1.875rem}.add-element .button-text[data-v-5e4d908e]{margin:.625rem 0}",
      map: undefined,
      media: undefined
    });
  };
  /* scoped */


  var __vue_scope_id__$17 = "data-v-5e4d908e";
  /* module identifier */

  var __vue_module_identifier__$M = undefined;
  /* functional template */

  var __vue_is_functional_template__$17 = false;
  /* component normalizer */

  function __vue_normalize__$17(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "AddNewElement.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    {
      var hook;

      if (style) {
        hook = function hook(context) {
          style.call(this, createInjector(context));
        };
      }

      if (hook !== undefined) {
        if (component.functional) {
          // register for functional component in vue file
          var originalRender = component.render;

          component.render = function renderWithStyleInjection(h, context) {
            hook.call(context);
            return originalRender(h, context);
          };
        } else {
          // inject component registration as beforeCreate hook
          var existing = component.beforeCreate;
          component.beforeCreate = existing ? [].concat(existing, hook) : [hook];
        }
      }
    }

    return component;
  }
  /* style inject */


  function __vue_create_injector__$M() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$M.styles || (__vue_create_injector__$M.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());
    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = {
        ids: [],
        parts: [],
        element: undefined
      });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;
        style.ids.push(id);

        if (css.map) {
          // https://developer.chrome.com/devtools/docs/javascript-debugging
          // this makes source maps inside style tags work properly in Chrome
          code += '\n/*# sourceURL=' + css.map.sources[0] + ' */'; // http://stackoverflow.com/a/26603875

          code += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(css.map)))) + ' */';
        }

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';
          if (css.media) el.setAttribute('media', css.media);

          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */


  var AddNewElement$1 = __vue_normalize__$17({
    render: __vue_render__$17,
    staticRenderFns: __vue_staticRenderFns__$17
  }, __vue_inject_styles__$17, __vue_script__$17, __vue_scope_id__$17, __vue_is_functional_template__$17, __vue_module_identifier__$M, __vue_create_injector__$M);

  function _typeof(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function (obj) {
        return typeof obj;
      };
    } else {
      _typeof = function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  function _defineProperty$1(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _slicedToArray$1(arr, i) {
    return _arrayWithHoles$1(arr) || _iterableToArrayLimit$1(arr, i) || _unsupportedIterableToArray$1(arr, i) || _nonIterableRest$1();
  }

  function _toConsumableArray$1(arr) {
    return _arrayWithoutHoles$1(arr) || _iterableToArray$1(arr) || _unsupportedIterableToArray$1(arr) || _nonIterableSpread$1();
  }

  function _arrayWithoutHoles$1(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray$1(arr);
  }

  function _arrayWithHoles$1(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArray$1(iter) {
    if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
  }

  function _iterableToArrayLimit$1(arr, i) {
    if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _unsupportedIterableToArray$1(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray$1(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen);
  }

  function _arrayLikeToArray$1(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

    return arr2;
  }

  function _nonIterableSpread$1() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _nonIterableRest$1() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  var script$16 = {
    name: 'tailor-editor-link',
    props: {
      activityId: {
        type: Number,
        required: true
      },
      elementUid: {
        type: String,
        "default": null
      },
      label: {
        type: String,
        required: true
      }
    },
    computed: {
      editorRoute: function editorRoute(_ref) {
        var activityId = _ref.activityId,
            elementUid = _ref.elementUid;
        return Object.assign({
          name: 'editor',
          params: {
            activityId: activityId
          }
        }, elementUid && {
          query: {
            elementId: elementUid
          }
        });
      }
    }
  };

  /* script */
  var __vue_script__$16 = script$16;
  /* template */

  var __vue_render__$16 = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      staticClass: "editor-link"
    }, [_c('v-tooltip', {
      attrs: {
        "right": ""
      },
      scopedSlots: _vm._u([{
        key: "activator",
        fn: function fn(ref) {
          var on = ref.on;
          return [_c('router-link', {
            attrs: {
              "to": _vm.editorRoute
            },
            scopedSlots: _vm._u([{
              key: "default",
              fn: function fn(ref) {
                var navigate = ref.navigate;
                var isExactActive = ref.isExactActive;
                return [_c('v-btn', _vm._g(_vm._b({
                  attrs: {
                    "color": isExactActive ? 'teal accent-4' : 'primary',
                    "text": "",
                    "x-small": ""
                  },
                  on: {
                    "click": navigate
                  }
                }, 'v-btn', _vm.$attrs, false), on), [_vm._v("\n          " + _vm._s(_vm.label) + "\n          "), _vm._t("icon", [_c('v-icon', {
                  staticClass: "ml-1",
                  attrs: {
                    "x-small": ""
                  }
                }, [_vm._v("mdi-arrow-top-right-thick")])])], 2)];
              }
            }], null, true)
          })];
        }
      }])
    }, [_vm._v(" "), _vm._t("tooltip", [_c('span', [_vm._v("View element")])])], 2)], 1);
  };

  var __vue_staticRenderFns__$16 = [];
  /* style */

  var __vue_inject_styles__$16 = undefined;
  /* scoped */

  var __vue_scope_id__$16 = undefined;
  /* functional template */

  var __vue_is_functional_template__$16 = false;
  /* component normalizer */

  function __vue_normalize__$16(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "EditorLink.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */

  /* style inject SSR */


  var EditorLink$1 = __vue_normalize__$16({
    render: __vue_render__$16,
    staticRenderFns: __vue_staticRenderFns__$16
  }, __vue_inject_styles__$16, __vue_script__$16, __vue_scope_id__$16, __vue_is_functional_template__$16);

  //

  var getOptions$1 = function getOptions() {
    return {
      resolve: {
        action: 'resolve',
        icon: 'check-box-outline',
        color: 'teal accent-4'
      },
      edit: {
        action: 'toggleEdit',
        icon: 'pencil-outline',
        color: 'grey'
      },
      remove: {
        action: 'remove',
        icon: 'trash-can-outline',
        color: 'grey'
      }
    };
  };

  var script$15 = {
    name: 'comment-header',
    props: {
      comment: {
        type: Object,
        required: true
      },
      isActivityThread: {
        type: Boolean,
        "default": false
      },
      isResolved: {
        type: Boolean,
        "default": false
      },
      elementLabel: {
        type: String,
        "default": null
      },
      user: {
        type: Object,
        required: true
      }
    },
    computed: {
      elementUid: function elementUid(vm) {
        return vm.comment.contentElement.uid;
      },
      author: function author(vm) {
        return vm.comment.author;
      },
      isAuthor: function isAuthor(vm) {
        return vm.author.id === vm.user.id;
      },
      isDeleted: function isDeleted(vm) {
        return !!vm.comment.deletedAt;
      },
      showEditedLabel: function showEditedLabel(vm) {
        return !!vm.comment.editedAt;
      },
      showOptions: function showOptions(vm) {
        return vm.isAuthor && !vm.isDeleted && !vm.isResolved;
      },
      options: function options() {
        var options = getOptions$1();
        if (this.isActivityThread) delete options.resolve;
        return options;
      }
    },
    components: {
      EditorLink: EditorLink$1
    }
  };

  /* script */
  var __vue_script__$15 = script$15;
  /* template */

  var __vue_render__$15 = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      staticClass: "header"
    }, [_c('v-avatar', {
      staticClass: "comment-avatar",
      attrs: {
        "size": "34"
      }
    }, [_c('img', {
      attrs: {
        "src": _vm.author.imgUrl
      }
    })]), _vm._v(" "), _c('div', {
      staticClass: "info-container"
    }, [_c('div', {
      staticClass: "d-flex align-center"
    }, [_c('v-tooltip', {
      attrs: {
        "right": ""
      },
      scopedSlots: _vm._u([{
        key: "activator",
        fn: function fn(ref) {
          var on = ref.on;
          return [_c('span', _vm._g({
            staticClass: "author text-truncate"
          }, on), [_vm._v(_vm._s(_vm.author.label))])];
        }
      }])
    }, [_vm._v("\n        " + _vm._s(_vm.author.label) + "\n      ")]), _vm._v(" "), _vm.showEditedLabel ? _c('span', {
      staticClass: "edited ml-1"
    }, [_vm._v("(edited)")]) : _vm._e()], 1), _vm._v(" "), _c('div', {
      staticClass: "d-flex align-center"
    }, [_c('v-tooltip', {
      attrs: {
        "right": ""
      },
      scopedSlots: _vm._u([{
        key: "activator",
        fn: function fn(ref) {
          var on = ref.on;
          return [_c('span', _vm._g({}, on), [_c('timeago', {
            staticClass: "time",
            attrs: {
              "datetime": _vm.comment.createdAt,
              "auto-update": 60
            }
          })], 1)];
        }
      }])
    }, [_vm._v(" "), _c('span', [_vm._v(_vm._s(_vm._f("formatDate")(_vm.comment.createdAt, 'DD. MMM h:mm A')))])]), _vm._v(" "), _vm.isActivityThread && _vm.elementLabel ? [_c('v-divider', {
      attrs: {
        "vertical": ""
      }
    }), _vm._v(" "), _c('editor-link', {
      attrs: {
        "activity-id": _vm.comment.activityId,
        "element-uid": _vm.elementUid,
        "label": _vm.elementLabel
      }
    })] : _vm._e()], 2)]), _vm._v(" "), _vm.showOptions ? _c('div', {
      staticClass: "actions"
    }, _vm._l(_vm.options, function (ref, name) {
      var action = ref.action;
      var icon = ref.icon;
      var color = ref.color;
      return _c('v-btn', {
        key: name,
        staticClass: "ml-1",
        attrs: {
          "x-small": "",
          "icon": ""
        },
        on: {
          "click": function click($event) {
            return _vm.$emit(action);
          }
        }
      }, [_c('v-icon', {
        attrs: {
          "color": color,
          "size": "14"
        }
      }, [_vm._v(" mdi-" + _vm._s(icon))])], 1);
    }), 1) : _vm._e()], 1);
  };

  var __vue_staticRenderFns__$15 = [];
  /* style */

  var __vue_inject_styles__$15 = function __vue_inject_styles__(inject) {
    if (!inject) return;
    inject("data-v-a1e0c4e8_0", {
      source: ".header[data-v-a1e0c4e8]{display:flex;align-items:flex-start}.header .comment-avatar[data-v-a1e0c4e8]{margin:.375rem .375rem 0 0}.header .info-container[data-v-a1e0c4e8]{display:flex;flex-direction:column;flex:0 100%;max-width:calc(100% - 8rem);margin-left:.125rem}.header .info-container .author[data-v-a1e0c4e8]{display:inline-block;max-width:75%;color:#000;font-size:1rem}.header .info-container .edited[data-v-a1e0c4e8],.header .info-container .time[data-v-a1e0c4e8]{color:#888;font-size:.75rem}.header .info-container hr.v-divider--vertical[data-v-a1e0c4e8]{margin:.25rem .125rem .125rem .625rem}.header .info-container[data-v-a1e0c4e8]  .editor-link{display:inline-flex;align-self:flex-end}.header .actions[data-v-a1e0c4e8]{margin-left:auto}",
      map: undefined,
      media: undefined
    });
  };
  /* scoped */


  var __vue_scope_id__$15 = "data-v-a1e0c4e8";
  /* module identifier */

  var __vue_module_identifier__$L = undefined;
  /* functional template */

  var __vue_is_functional_template__$15 = false;
  /* component normalizer */

  function __vue_normalize__$15(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "Header.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    {
      var hook;

      if (style) {
        hook = function hook(context) {
          style.call(this, createInjector(context));
        };
      }

      if (hook !== undefined) {
        if (component.functional) {
          // register for functional component in vue file
          var originalRender = component.render;

          component.render = function renderWithStyleInjection(h, context) {
            hook.call(context);
            return originalRender(h, context);
          };
        } else {
          // inject component registration as beforeCreate hook
          var existing = component.beforeCreate;
          component.beforeCreate = existing ? [].concat(existing, hook) : [hook];
        }
      }
    }

    return component;
  }
  /* style inject */


  function __vue_create_injector__$L() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$L.styles || (__vue_create_injector__$L.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());
    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = {
        ids: [],
        parts: [],
        element: undefined
      });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;
        style.ids.push(id);

        if (css.map) {
          // https://developer.chrome.com/devtools/docs/javascript-debugging
          // this makes source maps inside style tags work properly in Chrome
          code += '\n/*# sourceURL=' + css.map.sources[0] + ' */'; // http://stackoverflow.com/a/26603875

          code += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(css.map)))) + ' */';
        }

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';
          if (css.media) el.setAttribute('media', css.media);

          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */


  var CommentHeader$1 = __vue_normalize__$15({
    render: __vue_render__$15,
    staticRenderFns: __vue_staticRenderFns__$15
  }, __vue_inject_styles__$15, __vue_script__$15, __vue_scope_id__$15, __vue_is_functional_template__$15, __vue_module_identifier__$L, __vue_create_injector__$L);

  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  var script$14 = {
    name: 'comment-preview',
    props: {
      content: {
        type: String,
        "default": ''
      },
      isResolved: {
        type: Boolean,
        "default": false
      }
    }
  };

  /* script */
  var __vue_script__$14 = script$14;
  /* template */

  var __vue_render__$14 = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      staticClass: "content",
      "class": {
        resolved: _vm.isResolved
      }
    }, [_vm.isResolved ? _c('div', {
      staticClass: "resolvement-options"
    }, [_c('span', {
      staticClass: "font-italic mr-1"
    }, [_vm._v("Marked as resolved.")]), _vm._v(" "), _c('v-tooltip', {
      attrs: {
        "open-delay": "800",
        "right": ""
      },
      scopedSlots: _vm._u([{
        key: "activator",
        fn: function fn(ref) {
          var on = ref.on;
          return [_c('v-btn', _vm._g({
            attrs: {
              "color": "secondary",
              "text": "",
              "x-small": ""
            },
            on: {
              "click": _vm.$listeners.unresolve
            }
          }, on), [_vm._v("\n          Undo\n        ")])];
        }
      }], null, false, 3181083862)
    }, [_vm._v(" "), _c('span', [_vm._v("Unresolve comment")])])], 1) : _vm._e(), _vm._v(" "), _c('pre', [_c('span', [_vm._v(_vm._s(_vm.content))]), _c('br')])]);
  };

  var __vue_staticRenderFns__$14 = [];
  /* style */

  var __vue_inject_styles__$14 = function __vue_inject_styles__(inject) {
    if (!inject) return;
    inject("data-v-3d625308_0", {
      source: ".content[data-v-3d625308]{margin-top:.375rem}.content pre[data-v-3d625308]{height:100%;margin:0;padding:0 .25rem .5rem 0;font:inherit;white-space:pre-wrap;word-break:break-all;word-wrap:break-word;overflow-wrap:break-word;background:inherit;border:none;overflow:hidden}.content.resolved[data-v-3d625308]{opacity:.7}.content.resolved .resolvement-options[data-v-3d625308]{display:flex;align-items:center;margin-bottom:.25rem;font-size:.75rem}",
      map: undefined,
      media: undefined
    });
  };
  /* scoped */


  var __vue_scope_id__$14 = "data-v-3d625308";
  /* module identifier */

  var __vue_module_identifier__$K = undefined;
  /* functional template */

  var __vue_is_functional_template__$14 = false;
  /* component normalizer */

  function __vue_normalize__$14(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "Preview.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    {
      var hook;

      if (style) {
        hook = function hook(context) {
          style.call(this, createInjector(context));
        };
      }

      if (hook !== undefined) {
        if (component.functional) {
          // register for functional component in vue file
          var originalRender = component.render;

          component.render = function renderWithStyleInjection(h, context) {
            hook.call(context);
            return originalRender(h, context);
          };
        } else {
          // inject component registration as beforeCreate hook
          var existing = component.beforeCreate;
          component.beforeCreate = existing ? [].concat(existing, hook) : [hook];
        }
      }
    }

    return component;
  }
  /* style inject */


  function __vue_create_injector__$K() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$K.styles || (__vue_create_injector__$K.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());
    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = {
        ids: [],
        parts: [],
        element: undefined
      });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;
        style.ids.push(id);

        if (css.map) {
          // https://developer.chrome.com/devtools/docs/javascript-debugging
          // this makes source maps inside style tags work properly in Chrome
          code += '\n/*# sourceURL=' + css.map.sources[0] + ' */'; // http://stackoverflow.com/a/26603875

          code += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(css.map)))) + ' */';
        }

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';
          if (css.media) el.setAttribute('media', css.media);

          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */


  var CommentPreview$1 = __vue_normalize__$14({
    render: __vue_render__$14,
    staticRenderFns: __vue_staticRenderFns__$14
  }, __vue_inject_styles__$14, __vue_script__$14, __vue_scope_id__$14, __vue_is_functional_template__$14, __vue_module_identifier__$K, __vue_create_injector__$K);

  //
  var script$13 = {
    name: 'thread-comment',
    props: {
      comment: {
        type: Object,
        required: true
      },
      isActivityThread: {
        type: Boolean,
        "default": false
      },
      elementLabel: {
        type: String,
        "default": null
      },
      user: {
        type: Object,
        required: true
      }
    },
    data: function data(vm) {
      return {
        content: vm.comment.content,
        isEditing: false
      };
    },
    computed: {
      isResolved: function isResolved(_ref) {
        var comment = _ref.comment;
        return !!comment.resolvedAt;
      }
    },
    methods: {
      toggleEdit: function toggleEdit() {
        this.isEditing = !this.isEditing;
      },
      save: function save() {
        var comment = this.comment,
            content = this.content;
        if (!content) return this.remove();
        this.toggleEdit();
        this.$emit('update', comment, content);
      },
      remove: function remove() {
        this.$emit('remove', this.comment);
      },
      reset: function reset() {
        this.content = this.comment.content;
        this.isEditing = false;
      }
    },
    watch: {
      comment: {
        deep: true,
        handler: 'reset'
      }
    },
    components: {
      CommentHeader: CommentHeader$1,
      CommentPreview: CommentPreview$1
    }
  };

  /* script */
  var __vue_script__$13 = script$13;
  /* template */

  var __vue_render__$13 = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      staticClass: "comment"
    }, [_c('comment-header', _vm._b({
      on: {
        "toggleEdit": _vm.toggleEdit,
        "remove": _vm.remove,
        "resolve": function resolve($event) {
          return _vm.$emit('resolve', _vm.comment);
        }
      }
    }, 'comment-header', {
      comment: _vm.comment,
      isActivityThread: _vm.isActivityThread,
      isResolved: _vm.isResolved,
      elementLabel: _vm.elementLabel,
      user: _vm.user
    }, false)), _vm._v(" "), _c('div', {
      staticClass: "comment-body"
    }, [!_vm.isEditing ? _c('comment-preview', _vm._b({
      on: {
        "unresolve": function unresolve($event) {
          return _vm.$emit('unresolve', _vm.comment);
        }
      }
    }, 'comment-preview', {
      content: _vm.content,
      isResolved: _vm.isResolved
    }, false)) : [_c('v-textarea', {
      staticClass: "comment-editor",
      attrs: {
        "rows": "3",
        "autofocus": "",
        "outlined": "",
        "auto-grow": "",
        "clearable": "",
        "counter": ""
      },
      model: {
        value: _vm.content,
        callback: function callback($$v) {
          _vm.content = typeof $$v === 'string' ? $$v.trim() : $$v;
        },
        expression: "content"
      }
    }), _vm._v(" "), _c('span', {
      staticClass: "d-flex justify-end"
    }, [_c('v-btn', {
      attrs: {
        "text": "",
        "small": ""
      },
      on: {
        "click": _vm.reset
      }
    }, [_vm._v("Cancel")]), _vm._v(" "), _c('v-btn', {
      attrs: {
        "color": "green",
        "text": "",
        "small": ""
      },
      on: {
        "click": _vm.save
      }
    }, [_c('v-icon', {
      staticClass: "pr-1"
    }, [_vm._v("mdi-check")]), _vm._v(" Save\n        ")], 1)], 1)]], 2)], 1);
  };

  var __vue_staticRenderFns__$13 = [];
  /* style */

  var __vue_inject_styles__$13 = function __vue_inject_styles__(inject) {
    if (!inject) return;
    inject("data-v-3d04e7dc_0", {
      source: ".comment[data-v-3d04e7dc]{display:flex;flex-direction:column;font-family:Roboto,Arial,sans-serif}.comment-body[data-v-3d04e7dc]{flex:1;padding:0 .25rem 0 2.625rem}.comment-editor.v-textarea[data-v-3d04e7dc]{margin:.75rem 0 0 0}.comment-editor.v-textarea[data-v-3d04e7dc]  .v-input__slot{width:auto}",
      map: undefined,
      media: undefined
    });
  };
  /* scoped */


  var __vue_scope_id__$13 = "data-v-3d04e7dc";
  /* module identifier */

  var __vue_module_identifier__$J = undefined;
  /* functional template */

  var __vue_is_functional_template__$13 = false;
  /* component normalizer */

  function __vue_normalize__$13(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "index.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    {
      var hook;

      if (style) {
        hook = function hook(context) {
          style.call(this, createInjector(context));
        };
      }

      if (hook !== undefined) {
        if (component.functional) {
          // register for functional component in vue file
          var originalRender = component.render;

          component.render = function renderWithStyleInjection(h, context) {
            hook.call(context);
            return originalRender(h, context);
          };
        } else {
          // inject component registration as beforeCreate hook
          var existing = component.beforeCreate;
          component.beforeCreate = existing ? [].concat(existing, hook) : [hook];
        }
      }
    }

    return component;
  }
  /* style inject */


  function __vue_create_injector__$J() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$J.styles || (__vue_create_injector__$J.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());
    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = {
        ids: [],
        parts: [],
        element: undefined
      });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;
        style.ids.push(id);

        if (css.map) {
          // https://developer.chrome.com/devtools/docs/javascript-debugging
          // this makes source maps inside style tags work properly in Chrome
          code += '\n/*# sourceURL=' + css.map.sources[0] + ' */'; // http://stackoverflow.com/a/26603875

          code += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(css.map)))) + ' */';
        }

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';
          if (css.media) el.setAttribute('media', css.media);

          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */


  var ThreadComment$1 = __vue_normalize__$13({
    render: __vue_render__$13,
    staticRenderFns: __vue_staticRenderFns__$13
  }, __vue_inject_styles__$13, __vue_script__$13, __vue_scope_id__$13, __vue_is_functional_template__$13, __vue_module_identifier__$J, __vue_create_injector__$J);

  //
  var script$12 = {
    name: 'thread-list',
    inject: ['$teRegistry'],
    props: {
      comments: {
        type: Array,
        "default": function _default() {
          return [];
        }
      },
      isActivityThread: {
        type: Boolean,
        "default": false
      },
      elementLabel: {
        type: String,
        "default": null
      },
      user: {
        type: Object,
        required: true
      }
    },
    methods: {
      getElementLabel: function getElementLabel(_ref) {
        var _find;

        var contentElement = _ref.contentElement;
        if (!contentElement) return;
        return (_find = find__default['default'](this.$teRegistry._registry, {
          type: contentElement.type
        })) === null || _find === void 0 ? void 0 : _find.name;
      }
    },
    components: {
      ThreadComment: ThreadComment$1
    }
  };

  /* script */
  var __vue_script__$12 = script$12;
  /* template */

  var __vue_render__$12 = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('ul', {
      staticClass: "thread-list"
    }, _vm._l(_vm.comments, function (comment) {
      return _c('li', {
        key: comment.uid,
        staticClass: "thread-list-item"
      }, [_c('v-divider'), _vm._v(" "), _c('thread-comment', _vm._g(_vm._b({
        staticClass: "mb-3",
        attrs: {
          "element-label": _vm.getElementLabel(comment)
        }
      }, 'thread-comment', {
        comment: comment,
        isActivityThread: _vm.isActivityThread,
        user: _vm.user
      }, false), _vm.$listeners))], 1);
    }), 0);
  };

  var __vue_staticRenderFns__$12 = [];
  /* style */

  var __vue_inject_styles__$12 = function __vue_inject_styles__(inject) {
    if (!inject) return;
    inject("data-v-b5620cec_0", {
      source: ".thread-list[data-v-b5620cec]{margin:0;padding:0;list-style:none}.thread-list .thread-list-item .v-divider[data-v-b5620cec]{margin:0 .25rem 1rem .25rem}.thread-list .thread-list-item:first-child .v-divider[data-v-b5620cec]{display:none}",
      map: undefined,
      media: undefined
    });
  };
  /* scoped */


  var __vue_scope_id__$12 = "data-v-b5620cec";
  /* module identifier */

  var __vue_module_identifier__$I = undefined;
  /* functional template */

  var __vue_is_functional_template__$12 = false;
  /* component normalizer */

  function __vue_normalize__$12(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "List.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    {
      var hook;

      if (style) {
        hook = function hook(context) {
          style.call(this, createInjector(context));
        };
      }

      if (hook !== undefined) {
        if (component.functional) {
          // register for functional component in vue file
          var originalRender = component.render;

          component.render = function renderWithStyleInjection(h, context) {
            hook.call(context);
            return originalRender(h, context);
          };
        } else {
          // inject component registration as beforeCreate hook
          var existing = component.beforeCreate;
          component.beforeCreate = existing ? [].concat(existing, hook) : [hook];
        }
      }
    }

    return component;
  }
  /* style inject */


  function __vue_create_injector__$I() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$I.styles || (__vue_create_injector__$I.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());
    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = {
        ids: [],
        parts: [],
        element: undefined
      });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;
        style.ids.push(id);

        if (css.map) {
          // https://developer.chrome.com/devtools/docs/javascript-debugging
          // this makes source maps inside style tags work properly in Chrome
          code += '\n/*# sourceURL=' + css.map.sources[0] + ' */'; // http://stackoverflow.com/a/26603875

          code += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(css.map)))) + ' */';
        }

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';
          if (css.media) el.setAttribute('media', css.media);

          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */


  var ThreadList$1 = __vue_normalize__$12({
    render: __vue_render__$12,
    staticRenderFns: __vue_staticRenderFns__$12
  }, __vue_inject_styles__$12, __vue_script__$12, __vue_scope_id__$12, __vue_is_functional_template__$12, __vue_module_identifier__$I, __vue_create_injector__$I);

  //
  var script$11 = {
    name: 'unseen-divider',
    props: {
      count: {
        type: Number,
        required: true
      }
    },
    computed: {
      unseenCommentsLabel: function unseenCommentsLabel(_ref) {
        var count = _ref.count;
        return "".concat(count, " new ").concat(pluralize__default['default']('message', count));
      }
    }
  };

  /* script */
  var __vue_script__$11 = script$11;
  /* template */

  var __vue_render__$11 = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      staticClass: "unseen-divider"
    }, [_c('v-divider'), _vm._v(" "), _c('v-chip', {
      attrs: {
        "close-icon": "mdi-close",
        "color": "teal accent-4",
        "outlined": "",
        "small": "",
        "close": ""
      },
      on: {
        "click": function click($event) {
          return _vm.$emit('seen');
        },
        "click:close": function clickClose($event) {
          return _vm.$emit('seen');
        }
      }
    }, [_c('v-icon', {
      staticClass: "mr-1",
      attrs: {
        "size": "14"
      }
    }, [_vm._v("mdi-arrow-down")]), _vm._v(" "), _c('span', {
      staticClass: "mr-2"
    }, [_vm._v(_vm._s(_vm.unseenCommentsLabel))])], 1)], 1);
  };

  var __vue_staticRenderFns__$11 = [];
  /* style */

  var __vue_inject_styles__$11 = function __vue_inject_styles__(inject) {
    if (!inject) return;
    inject("data-v-221b9d72_0", {
      source: ".unseen-divider[data-v-221b9d72]{text-align:center}.unseen-divider .v-divider[data-v-221b9d72]{margin:1rem 0 .25rem}.unseen-divider[data-v-221b9d72]  .v-chip.v-chip--outlined.v-chip{margin:-1.5rem 0 .5rem 0;border-radius:1rem!important;background-color:#fafafa!important}.unseen-divider[data-v-221b9d72]  .v-chip.v-chip--outlined.v-chip .v-chip__content .v-chip__close{margin-top:.125rem;font-size:.75rem!important}",
      map: undefined,
      media: undefined
    });
  };
  /* scoped */


  var __vue_scope_id__$11 = "data-v-221b9d72";
  /* module identifier */

  var __vue_module_identifier__$H = undefined;
  /* functional template */

  var __vue_is_functional_template__$11 = false;
  /* component normalizer */

  function __vue_normalize__$11(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "UnseenDivider.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    {
      var hook;

      if (style) {
        hook = function hook(context) {
          style.call(this, createInjector(context));
        };
      }

      if (hook !== undefined) {
        if (component.functional) {
          // register for functional component in vue file
          var originalRender = component.render;

          component.render = function renderWithStyleInjection(h, context) {
            hook.call(context);
            return originalRender(h, context);
          };
        } else {
          // inject component registration as beforeCreate hook
          var existing = component.beforeCreate;
          component.beforeCreate = existing ? [].concat(existing, hook) : [hook];
        }
      }
    }

    return component;
  }
  /* style inject */


  function __vue_create_injector__$H() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$H.styles || (__vue_create_injector__$H.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());
    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = {
        ids: [],
        parts: [],
        element: undefined
      });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;
        style.ids.push(id);

        if (css.map) {
          // https://developer.chrome.com/devtools/docs/javascript-debugging
          // this makes source maps inside style tags work properly in Chrome
          code += '\n/*# sourceURL=' + css.map.sources[0] + ' */'; // http://stackoverflow.com/a/26603875

          code += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(css.map)))) + ' */';
        }

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';
          if (css.media) el.setAttribute('media', css.media);

          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */


  var UnseenDivider$1 = __vue_normalize__$11({
    render: __vue_render__$11,
    staticRenderFns: __vue_staticRenderFns__$11
  }, __vue_inject_styles__$11, __vue_script__$11, __vue_scope_id__$11, __vue_is_functional_template__$11, __vue_module_identifier__$H, __vue_create_injector__$H);

  var script$10 = {
    name: 'discussion-thread',
    props: {
      items: {
        type: Array,
        required: true
      },
      showAll: {
        type: Boolean,
        "default": false
      },
      minDisplayed: {
        type: Number,
        "default": 5
      },
      isActivityThread: {
        type: Boolean,
        "default": false
      },
      unseenCount: {
        type: Number,
        required: true
      },
      user: {
        type: Object,
        required: true
      }
    },
    data: function data() {
      return {
        isVisible: false
      };
    },
    computed: {
      visibleComments: function visibleComments() {
        var items = this.items,
            minDisplayed = this.minDisplayed,
            showAll = this.showAll;
        var comments = showAll ? items : takeRgt__default['default'](items, minDisplayed);

        var _partition = partition__default['default'](comments, 'unseen'),
            _partition2 = _slicedToArray$1(_partition, 2),
            unseen = _partition2[0],
            seen = _partition2[1];

        return {
          seen: seen,
          unseen: unseen
        };
      }
    },
    methods: {
      onUpdate: function onUpdate(comment, content) {
        this.$emit('update', Object.assign({}, comment, {
          content: content
        }));
      },
      onIntersect: function onIntersect(_entries, _observer, isIntersected) {
        this.isVisible = isIntersected;
      },
      revealUnseen: function revealUnseen(count) {
        var $refs = this.$refs,
            minDisplayed = this.minDisplayed;
        if ((count || this.unseenCount) < minDisplayed) return;
        this.$emit('showAll', true);
        this.$nextTick(function () {
          var element = $refs.unseenDivider.$el;
          if (!element) return;
          element.scrollIntoView({
            behavior: 'smooth'
          });
        });
      },
      markSeen: function markSeen() {
        this.$emit('seen');
        this.$emit('showAll', false);
      }
    },
    watch: {
      isVisible: function isVisible(val) {
        if (!val || !this.unseenCount) return;
        this.revealUnseen();
      },
      unseenCount: {
        immediate: true,
        handler: 'revealUnseen'
      }
    },
    components: {
      UnseenDivider: UnseenDivider$1,
      ThreadList: ThreadList$1
    }
  };

  /* script */
  var __vue_script__$10 = script$10;
  /* template */

  var __vue_render__$10 = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      directives: [{
        name: "intersect",
        rawName: "v-intersect",
        value: _vm.onIntersect,
        expression: "onIntersect"
      }],
      staticClass: "discussion-thread",
      "class": {
        'scroll-container': !_vm.isActivityThread
      }
    }, [_c('thread-list', _vm._b({
      on: {
        "update": _vm.onUpdate,
        "remove": function remove($event) {
          return _vm.$emit('remove', $event);
        },
        "resolve": function resolve($event) {
          return _vm.$emit('resolve', $event);
        },
        "unresolve": function unresolve($event) {
          return _vm.$emit('unresolve', $event);
        }
      }
    }, 'thread-list', {
      isActivityThread: _vm.isActivityThread,
      user: _vm.user,
      comments: _vm.visibleComments.seen
    }, false)), _vm._v(" "), _c('transition', {
      attrs: {
        "name": "fade"
      }
    }, [_vm.unseenCount ? _c('unseen-divider', {
      ref: "unseenDivider",
      attrs: {
        "count": _vm.unseenCount
      },
      on: {
        "seen": _vm.markSeen
      }
    }) : _vm._e()], 1), _vm._v(" "), _c('thread-list', _vm._b({
      on: {
        "update": _vm.onUpdate,
        "remove": function remove($event) {
          return _vm.$emit('remove', $event);
        },
        "resolve": function resolve($event) {
          return _vm.$emit('resolve', $event);
        },
        "unresolve": function unresolve($event) {
          return _vm.$emit('unresolve', $event);
        }
      }
    }, 'thread-list', {
      isActivityThread: _vm.isActivityThread,
      user: _vm.user,
      comments: _vm.visibleComments.unseen
    }, false))], 1);
  };

  var __vue_staticRenderFns__$10 = [];
  /* style */

  var __vue_inject_styles__$10 = function __vue_inject_styles__(inject) {
    if (!inject) return;
    inject("data-v-c6af8436_0", {
      source: ".discussion-thread[data-v-c6af8436]{width:100%}.discussion-thread.scroll-container[data-v-c6af8436]{max-height:31.25rem;overflow-y:scroll;overflow-x:hidden;padding-right:1.5rem;box-sizing:content-box}.discussion-thread .fade-enter-active[data-v-c6af8436],.discussion-thread .fade-leave-active[data-v-c6af8436]{transition:opacity .5s}.discussion-thread .fade-enter[data-v-c6af8436],.discussion-thread .fade-leave-to[data-v-c6af8436]{opacity:0}",
      map: undefined,
      media: undefined
    });
  };
  /* scoped */


  var __vue_scope_id__$10 = "data-v-c6af8436";
  /* module identifier */

  var __vue_module_identifier__$G = undefined;
  /* functional template */

  var __vue_is_functional_template__$10 = false;
  /* component normalizer */

  function __vue_normalize__$10(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "index.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    {
      var hook;

      if (style) {
        hook = function hook(context) {
          style.call(this, createInjector(context));
        };
      }

      if (hook !== undefined) {
        if (component.functional) {
          // register for functional component in vue file
          var originalRender = component.render;

          component.render = function renderWithStyleInjection(h, context) {
            hook.call(context);
            return originalRender(h, context);
          };
        } else {
          // inject component registration as beforeCreate hook
          var existing = component.beforeCreate;
          component.beforeCreate = existing ? [].concat(existing, hook) : [hook];
        }
      }
    }

    return component;
  }
  /* style inject */


  function __vue_create_injector__$G() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$G.styles || (__vue_create_injector__$G.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());
    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = {
        ids: [],
        parts: [],
        element: undefined
      });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;
        style.ids.push(id);

        if (css.map) {
          // https://developer.chrome.com/devtools/docs/javascript-debugging
          // this makes source maps inside style tags work properly in Chrome
          code += '\n/*# sourceURL=' + css.map.sources[0] + ' */'; // http://stackoverflow.com/a/26603875

          code += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(css.map)))) + ' */';
        }

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';
          if (css.media) el.setAttribute('media', css.media);

          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */


  var DiscussionThread$1 = __vue_normalize__$10({
    render: __vue_render__$10,
    staticRenderFns: __vue_staticRenderFns__$10
  }, __vue_inject_styles__$10, __vue_script__$10, __vue_scope_id__$10, __vue_is_functional_template__$10, __vue_module_identifier__$G, __vue_create_injector__$G);

  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  var script$$ = {
    name: 'resolve-comments-btn'
  };

  /* script */
  var __vue_script__$$ = script$$;
  /* template */

  var __vue_render__$$ = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      staticClass: "resolve-btn-container"
    }, [_c('v-tooltip', {
      attrs: {
        "open-delay": "800",
        "left": ""
      },
      scopedSlots: _vm._u([{
        key: "activator",
        fn: function fn(ref) {
          var on = ref.on;
          return [_c('v-btn', _vm._g({
            staticClass: "px-1",
            attrs: {
              "color": "teal accent-4",
              "small": "",
              "text": ""
            }
          }, Object.assign({}, _vm.$listeners, on)), [_c('v-icon', {
            staticClass: "mr-2",
            attrs: {
              "size": "24",
              "color": "teal accent-4"
            }
          }, [_vm._v("\n          mdi-check-box-outline\n        ")]), _vm._v("\n        Resolve All\n      ")], 1)];
        }
      }])
    }, [_vm._v(" "), _c('span', [_vm._v("Mark all as resolved and hide discussion")])])], 1);
  };

  var __vue_staticRenderFns__$$ = [];
  /* style */

  var __vue_inject_styles__$$ = undefined;
  /* scoped */

  var __vue_scope_id__$$ = undefined;
  /* functional template */

  var __vue_is_functional_template__$$ = false;
  /* component normalizer */

  function __vue_normalize__$$(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "ResolveButton.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */

  /* style inject SSR */


  var ResolveButton$1 = __vue_normalize__$$({
    render: __vue_render__$$,
    staticRenderFns: __vue_staticRenderFns__$$
  }, __vue_inject_styles__$$, __vue_script__$$, __vue_scope_id__$$, __vue_is_functional_template__$$);

  //

  var initCommentInput$1 = function initCommentInput() {
    return {
      content: ''
    };
  };

  var script$_ = {
    name: 'tailor-embedded-discussion',
    inheritAttrs: true,
    props: {
      comments: {
        type: Array,
        "default": function _default() {
          return [];
        }
      },
      unseenComments: {
        type: Array,
        "default": function _default() {
          return [];
        }
      },
      commentsShownLimit: {
        type: Number,
        "default": 5
      },
      scrollTarget: {
        type: String,
        "default": 'discussion'
      },
      showHeading: {
        type: Boolean,
        "default": false
      },
      showNotifications: {
        type: Boolean,
        "default": false
      },
      isActivityThread: {
        type: Boolean,
        "default": false
      },
      hasUnresolvedComments: {
        type: Boolean,
        "default": false
      },
      isVisible: {
        type: Boolean,
        "default": false
      },
      user: {
        type: Object,
        required: true
      }
    },
    data: function data() {
      return {
        showAll: false,
        comment: initCommentInput$1()
      };
    },
    computed: {
      thread: function thread() {
        var comments = this.comments,
            unseenComments = this.unseenComments;
        var processedThread = comments.map(function (comment) {
          var unseen = unseenComments.find(function (it) {
            return it.id === comment.id;
          });
          return Object.assign({}, comment, {
            unseen: !!unseen
          });
        });
        return orderBy__default['default'](processedThread, ['unseen', 'createdAt'], 'asc');
      },
      commentsCount: function commentsCount(vm) {
        return vm.thread.length;
      },
      hasHiddenComments: function hasHiddenComments(vm) {
        return vm.commentsShownLimit < vm.commentsCount;
      },
      isTextEditorEmpty: function isTextEditorEmpty(vm) {
        var _vm$comment$content;

        return !((_vm$comment$content = vm.comment.content) !== null && _vm$comment$content !== void 0 && _vm$comment$content.trim());
      },
      showResolveButton: function showResolveButton(vm) {
        return vm.hasUnresolvedComments && !vm.isActivityThread;
      }
    },
    methods: Object.assign({}, vueRadio.mapRequests('app', ['showConfirmationModal']), {
      post: function post() {
        var _this = this;

        var scrollTarget = this.scrollTarget,
            comment = this.comment,
            author = this.user;
        if (!comment.content) return;
        var payload = {
          content: comment.content,
          author: author,
          createdAt: Date.now(),
          updatedAt: Date.now()
        };
        this.comment = initCommentInput$1();
        this.$emit('save', payload); // Keep editor/discussion container inside viewport.

        var scrollOptions = {
          block: 'center',
          behavior: 'smooth'
        };
        this.$nextTick(function () {
          return _this.$refs[scrollTarget].scrollIntoView(scrollOptions);
        });
      },
      remove: function remove(comment) {
        var _this2 = this;

        this.showConfirmationModal(Object.assign({
          title: 'Remove comment',
          message: 'Are you sure you want to remove this comment?',
          action: function action() {
            return _this2.$emit('remove', comment);
          }
        }, this.onConfirmationActive()));
      },
      resolveAll: function resolveAll() {
        var _this3 = this;

        this.showConfirmationModal(Object.assign({
          title: 'Resolve all comments',
          message: 'Are you sure you want to resolve all comments?',
          action: function action() {
            return _this3.$emit('resolve');
          }
        }, this.onConfirmationActive()));
      },
      onConfirmationActive: function onConfirmationActive() {
        var _this4 = this;

        var onOpen = function onOpen() {
          return _this4.$emit('update:confirmationActive', true);
        };

        var onClose = function onClose() {
          return _this4.$emit('update:confirmationActive', false);
        };

        return {
          onOpen: onOpen,
          onClose: onClose
        };
      }
    }),
    watch: {
      commentsCount: function commentsCount() {
        this.$emit('change', this.thread);
      },
      isVisible: {
        immediate: true,
        handler: function handler(val) {
          var _this5 = this;

          if (!val && this.isActivityThread) return; // Focus comment input manually with delay to avoid
          // element focus prioritization (e.g HTML element)

          setTimeout(function () {
            return _this5.$refs.commentInput.focus();
          }, 500);
        }
      }
    },
    created: function created() {
      this.comment = initCommentInput$1();
    },
    components: {
      DiscussionThread: DiscussionThread$1,
      ResolveButton: ResolveButton$1
    }
  };

  /* script */
  var __vue_script__$_ = script$_;
  /* template */

  var __vue_render__$_ = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      ref: "discussion",
      staticClass: "embedded-discussion"
    }, [_vm.showResolveButton ? _c('resolve-button', {
      on: {
        "click": _vm.resolveAll
      }
    }) : _vm._e(), _vm._v(" "), _c('div', {
      "class": {
        'pb-7': !_vm.showHeading && _vm.hasHiddenComments
      }
    }, [_vm.hasHiddenComments ? _c('v-btn', {
      staticClass: "float-right mt-1",
      attrs: {
        "text": "",
        "x-small": ""
      },
      on: {
        "click": function click($event) {
          _vm.showAll = !_vm.showAll;
        }
      }
    }, [_vm._v("\n      Show " + _vm._s(_vm.showAll ? 'less' : 'more') + "\n    ")]) : _vm._e()], 1), _vm._v(" "), _vm.showHeading ? _c('div', {
      staticClass: "header d-flex grey--text text--darken-3"
    }, [_c('v-icon', {
      staticClass: "mr-2",
      attrs: {
        "color": "grey darken-3"
      }
    }, [_vm._v("\n      mdi-forum-outline\n    ")]), _vm._v("\n    Comments\n  ")], 1) : _vm._e(), _vm._v(" "), !_vm.commentsCount && _vm.showNotifications ? _c('v-alert', {
      staticClass: "alert",
      attrs: {
        "color": "primary lighten-5",
        "icon": "mdi-keyboard-outline",
        "prominent": ""
      }
    }, [_c('span', {
      staticClass: "px-1 subtitle-2"
    }, [_vm._v("\n      Be the First to Comment!\n    ")])]) : _vm._e(), _vm._v(" "), _vm.thread.length ? _c('discussion-thread', {
      staticClass: "mt-2",
      attrs: {
        "items": _vm.thread,
        "show-all": _vm.showAll,
        "min-displayed": _vm.commentsShownLimit,
        "is-activity-thread": _vm.isActivityThread,
        "unseen-count": _vm.unseenComments.length,
        "user": _vm.user
      },
      on: {
        "update": function update($event) {
          return _vm.$emit('update', $event);
        },
        "resolve": function resolve($event) {
          return _vm.$emit('resolve', $event);
        },
        "unresolve": function unresolve($event) {
          return _vm.$emit('unresolve', $event);
        },
        "seen": function seen($event) {
          return _vm.$emit('seen');
        },
        "remove": _vm.remove,
        "showAll": function showAll($event) {
          _vm.showAll = $event;
        }
      }
    }) : _vm._e(), _vm._v(" "), _c('div', {
      ref: "inputContainer",
      staticClass: "text-right"
    }, [_c('v-textarea', {
      ref: "commentInput",
      staticClass: "comment-input",
      attrs: {
        "placeholder": _vm.commentsCount ? 'Add a comment...' : 'Start the discussion...',
        "rows": "3",
        "outlined": "",
        "auto-grow": "",
        "clearable": "",
        "counter": ""
      },
      on: {
        "focus": function focus($event) {
          return _vm.$emit('seen');
        }
      },
      model: {
        value: _vm.comment.content,
        callback: function callback($$v) {
          _vm.$set(_vm.comment, "content", typeof $$v === 'string' ? $$v.trim() : $$v);
        },
        expression: "comment.content"
      }
    }), _vm._v(" "), _c('v-btn', {
      attrs: {
        "disabled": _vm.isTextEditorEmpty,
        "icon": ""
      },
      on: {
        "click": _vm.post
      }
    }, [_c('v-icon', [_vm._v("mdi-send")])], 1)], 1)], 1);
  };

  var __vue_staticRenderFns__$_ = [];
  /* style */

  var __vue_inject_styles__$_ = function __vue_inject_styles__(inject) {
    if (!inject) return;
    inject("data-v-5744b719_0", {
      source: ".embedded-discussion[data-v-5744b719]{font-family:Roboto,Arial,sans-serif}.embedded-discussion .resolve-btn-container[data-v-5744b719]{display:flex;justify-content:flex-end;margin:.5rem 0 0 0}.embedded-discussion .header[data-v-5744b719]{margin:.875rem 0 1.625rem 0;font-size:1.125rem;font-weight:400}.embedded-discussion .comment-input[data-v-5744b719]{margin:0 .25rem 0 .25rem}.embedded-discussion .alert[data-v-5744b719]  .v-icon{color:var(--v-primary-darken2)!important}",
      map: undefined,
      media: undefined
    });
  };
  /* scoped */


  var __vue_scope_id__$_ = "data-v-5744b719";
  /* module identifier */

  var __vue_module_identifier__$F = undefined;
  /* functional template */

  var __vue_is_functional_template__$_ = false;
  /* component normalizer */

  function __vue_normalize__$_(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "index.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    {
      var hook;

      if (style) {
        hook = function hook(context) {
          style.call(this, createInjector(context));
        };
      }

      if (hook !== undefined) {
        if (component.functional) {
          // register for functional component in vue file
          var originalRender = component.render;

          component.render = function renderWithStyleInjection(h, context) {
            hook.call(context);
            return originalRender(h, context);
          };
        } else {
          // inject component registration as beforeCreate hook
          var existing = component.beforeCreate;
          component.beforeCreate = existing ? [].concat(existing, hook) : [hook];
        }
      }
    }

    return component;
  }
  /* style inject */


  function __vue_create_injector__$F() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$F.styles || (__vue_create_injector__$F.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());
    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = {
        ids: [],
        parts: [],
        element: undefined
      });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;
        style.ids.push(id);

        if (css.map) {
          // https://developer.chrome.com/devtools/docs/javascript-debugging
          // this makes source maps inside style tags work properly in Chrome
          code += '\n/*# sourceURL=' + css.map.sources[0] + ' */'; // http://stackoverflow.com/a/26603875

          code += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(css.map)))) + ' */';
        }

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';
          if (css.media) el.setAttribute('media', css.media);

          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */


  var Discussion$3 = __vue_normalize__$_({
    render: __vue_render__$_,
    staticRenderFns: __vue_staticRenderFns__$_
  }, __vue_inject_styles__$_, __vue_script__$_, __vue_scope_id__$_, __vue_is_functional_template__$_, __vue_module_identifier__$F, __vue_create_injector__$F);

  //

  var getActivatorOptions$1 = function getActivatorOptions(unseenComments) {
    return {
      unseen: {
        "class": 'teal accent-4 white--text',
        tooltip: 'View new comments',
        text: unseenComments.length
      },
      preview: {
        icon: 'mdi-comment-text-multiple-outline',
        color: 'primary darken-4',
        tooltip: 'View comments'
      },
      post: {
        icon: 'mdi-message-plus-outline',
        color: 'primary darken-4',
        tooltip: 'Post a comment'
      }
    };
  };

  var script$Z = {
    name: 'tailor-element-discussion',
    props: {
      id: {
        type: Number,
        "default": null
      },
      uid: {
        type: String,
        required: true
      },
      comments: {
        type: Array,
        required: true
      },
      hasUnresolvedComments: {
        type: Boolean,
        "default": false
      },
      lastSeen: {
        type: Number,
        required: true
      },
      user: {
        type: Object,
        required: true
      }
    },
    data: function data() {
      return {
        isVisible: false,
        isConfirmationActive: false
      };
    },
    computed: Object.assign({}, vueRadio.mapChannels({
      editorBus: 'editor'
    }), {
      events: function events() {
        return utils.Events.Discussion;
      },
      lastCommentAt: function lastCommentAt(vm) {
        return new Date(get__default['default'](vm.comments[0], 'createdAt', 0)).getTime();
      },
      unseenComments: function unseenComments() {
        var comments = this.comments,
            user = this.user,
            lastSeen = this.lastSeen;
        return comments.filter(function (it) {
          var createdAt = new Date(it.createdAt).getTime();
          return it.author.id !== user.id && createdAt > lastSeen;
        });
      },
      activator: function activator() {
        var comments = this.comments,
            unseenComments = this.unseenComments;
        var type = unseenComments.length ? 'unseen' : comments.length ? 'preview' : 'post';
        return getActivatorOptions$1(unseenComments)[type];
      }
    }),
    methods: {
      save: function save(data) {
        var author = this.user,
            elementId = this.id,
            hasUnresolvedComments = this.hasUnresolvedComments;
        return this.editorBus.emit(utils.Events.Discussion.SAVE, Object.assign({}, data, {
          author: author,
          contentElementId: elementId,
          hasUnresolvedComments: hasUnresolvedComments
        }));
      },
      setLastSeen: function setLastSeen(timeout) {
        var elementUid = this.uid,
            lastCommentAt = this.lastCommentAt,
            events = this.events;
        var options = {
          elementUid: elementUid,
          lastCommentAt: lastCommentAt,
          timeout: timeout
        };
        this.editorBus.emit(events.SET_LAST_SEEN, options);
      },
      resolve: function resolve() {
        var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
            id = _ref.id,
            resolvedAt = _ref.resolvedAt;

        var contentElementId = this.id,
            events = this.events;
        this.editorBus.emit(events.RESOLVE, {
          id: id,
          contentElementId: contentElementId,
          resolvedAt: resolvedAt
        });
      }
    },
    watch: {
      isVisible: function isVisible(val) {
        if (val) this.$emit('open');
      }
    },
    components: {
      Discussion: Discussion$3
    }
  };

  /* script */
  var __vue_script__$Z = script$Z;
  /* template */

  var __vue_render__$Z = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('v-menu', {
      attrs: {
        "close-on-content-click": false,
        "close-on-click": !_vm.isConfirmationActive,
        "min-width": "300",
        "transition": "slide-y-transition",
        "left": "",
        "offset-y": "",
        "attach": ""
      },
      nativeOn: {
        "click": function click($event) {
          $event.stopPropagation();
        }
      },
      scopedSlots: _vm._u([{
        key: "activator",
        fn: function fn(ref) {
          var menu = ref.on;
          return [_c('v-tooltip', {
            attrs: {
              "open-delay": "800",
              "left": ""
            },
            scopedSlots: _vm._u([{
              key: "activator",
              fn: function fn(ref) {
                var tooltip = ref.on;
                return [_c('v-btn', _vm._g({
                  "class": _vm.activator["class"],
                  attrs: {
                    "x-small": "",
                    "icon": ""
                  }
                }, Object.assign({}, menu, tooltip)), [_vm.activator.text ? _c('div', {
                  staticClass: "unseen"
                }, [_vm._v(_vm._s(_vm.activator.text))]) : _c('v-icon', {
                  attrs: {
                    "color": _vm.activator.color,
                    "size": "18"
                  }
                }, [_vm._v("\n            " + _vm._s(_vm.activator.icon) + "\n          ")])], 1)];
              }
            }], null, true)
          }, [_vm._v(" "), _c('span', [_vm._v(_vm._s(_vm.activator.tooltip))])])];
        }
      }]),
      model: {
        value: _vm.isVisible,
        callback: function callback($$v) {
          _vm.isVisible = $$v;
        },
        expression: "isVisible"
      }
    }, [_vm._v(" "), _c('discussion', _vm._b({
      staticClass: "pa-2",
      attrs: {
        "confirmation-active": _vm.isConfirmationActive
      },
      on: {
        "save": _vm.save,
        "update": _vm.save,
        "remove": function remove($event) {
          return _vm.editorBus.emit(_vm.events.REMOVE, $event);
        },
        "seen": _vm.setLastSeen,
        "resolve": _vm.resolve,
        "update:confirmationActive": function updateConfirmationActive($event) {
          _vm.isConfirmationActive = $event;
        },
        "update:confirmation-active": function updateConfirmationActive($event) {
          _vm.isConfirmationActive = $event;
        }
      }
    }, 'discussion', {
      comments: _vm.comments,
      unseenComments: _vm.unseenComments,
      hasUnresolvedComments: _vm.hasUnresolvedComments,
      user: _vm.user,
      isVisible: _vm.isVisible
    }, false))], 1);
  };

  var __vue_staticRenderFns__$Z = [];
  /* style */

  var __vue_inject_styles__$Z = function __vue_inject_styles__(inject) {
    if (!inject) return;
    inject("data-v-382b8ce9_0", {
      source: "[data-v-382b8ce9] .v-menu__content{background:#fff}[data-v-382b8ce9] .v-menu__content .embedded-discussion{text-align:left}[data-v-382b8ce9] .v-menu__content .comment .author{font-size:.875rem}.unseen[data-v-382b8ce9]{font-size:.75rem}",
      map: undefined,
      media: undefined
    });
  };
  /* scoped */


  var __vue_scope_id__$Z = "data-v-382b8ce9";
  /* module identifier */

  var __vue_module_identifier__$E = undefined;
  /* functional template */

  var __vue_is_functional_template__$Z = false;
  /* component normalizer */

  function __vue_normalize__$Z(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "ElementDiscussion.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    {
      var hook;

      if (style) {
        hook = function hook(context) {
          style.call(this, createInjector(context));
        };
      }

      if (hook !== undefined) {
        if (component.functional) {
          // register for functional component in vue file
          var originalRender = component.render;

          component.render = function renderWithStyleInjection(h, context) {
            hook.call(context);
            return originalRender(h, context);
          };
        } else {
          // inject component registration as beforeCreate hook
          var existing = component.beforeCreate;
          component.beforeCreate = existing ? [].concat(existing, hook) : [hook];
        }
      }
    }

    return component;
  }
  /* style inject */


  function __vue_create_injector__$E() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$E.styles || (__vue_create_injector__$E.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());
    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = {
        ids: [],
        parts: [],
        element: undefined
      });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;
        style.ids.push(id);

        if (css.map) {
          // https://developer.chrome.com/devtools/docs/javascript-debugging
          // this makes source maps inside style tags work properly in Chrome
          code += '\n/*# sourceURL=' + css.map.sources[0] + ' */'; // http://stackoverflow.com/a/26603875

          code += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(css.map)))) + ' */';
        }

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';
          if (css.media) el.setAttribute('media', css.media);

          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */


  var Discussion$2 = __vue_normalize__$Z({
    render: __vue_render__$Z,
    staticRenderFns: __vue_staticRenderFns__$Z
  }, __vue_inject_styles__$Z, __vue_script__$Z, __vue_scope_id__$Z, __vue_is_functional_template__$Z, __vue_module_identifier__$E, __vue_create_injector__$E);

  //
  var script$Y = {
    name: 'tailor-publish-diff-chip',
    props: {
      changeType: {
        validator: function validator(value) {
          if (!value) return true;
          return Object.values(utils.publishDiffChangeTypes).includes(value);
        },
        "default": null
      }
    }
  };

  /* script */
  var __vue_script__$Y = script$Y;
  /* template */

  var __vue_render__$Y = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _vm.changeType ? _c('v-chip', {
      staticClass: "readonly font-weight-medium text-capitalize",
      attrs: {
        "text-color": _vm.changeType === 'new' ? 'success' : 'secondary',
        "color": "primary lighten-5",
        "small": "",
        "round": ""
      }
    }, [_vm._v("\n  " + _vm._s(_vm.changeType) + "\n")]) : _vm._e();
  };

  var __vue_staticRenderFns__$Y = [];
  /* style */

  var __vue_inject_styles__$Y = undefined;
  /* scoped */

  var __vue_scope_id__$Y = undefined;
  /* functional template */

  var __vue_is_functional_template__$Y = false;
  /* component normalizer */

  function __vue_normalize__$Y(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "PublishDiffChip.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */

  /* style inject SSR */


  var PublishDiffChip$1 = __vue_normalize__$Y({
    render: __vue_render__$Y,
    staticRenderFns: __vue_staticRenderFns__$Y
  }, __vue_inject_styles__$Y, __vue_script__$Y, __vue_scope_id__$Y, __vue_is_functional_template__$Y);

  //
  var script$X = {
    name: 'tailor-content-element',
    inject: {
      $getCurrentUser: {},
      $editorState: {
        "default": {}
      }
    },
    inheritAttrs: false,
    props: {
      element: {
        type: Object,
        required: true
      },
      parent: {
        type: Object,
        "default": null
      },
      isHovered: {
        type: Boolean,
        "default": false
      },
      isDragged: {
        type: Boolean,
        "default": false
      },
      isDisabled: {
        type: Boolean,
        "default": false
      },
      frame: {
        type: Boolean,
        "default": true
      },
      dense: {
        type: Boolean,
        "default": false
      },
      showDiscussion: {
        type: Boolean,
        "default": false
      }
    },
    data: function data() {
      return {
        isFocused: false,
        isSaving: false,
        activeUsers: []
      };
    },
    computed: Object.assign({}, vueRadio.mapChannels({
      editorBus: 'editor'
    }), {
      id: function id(vm) {
        return utils.getElementId(vm.element);
      },
      componentName: function componentName(vm) {
        return utils.getComponentName(vm.element.type);
      },
      isEmbed: function isEmbed(vm) {
        return !!vm.parent || !vm.element.uid;
      },
      isHighlighted: function isHighlighted(vm) {
        return vm.isFocused || vm.isHovered;
      },
      hasComments: function hasComments(vm) {
        var _vm$element$comments;

        return !!((_vm$element$comments = vm.element.comments) !== null && _vm$element$comments !== void 0 && _vm$element$comments.length);
      },
      elementBus: function elementBus(vm) {
        return vm.$radio.channel("element:".concat(vm.id));
      },
      currentUser: function currentUser(vm) {
        return vm.$getCurrentUser();
      }
    }),
    methods: {
      onSelect: function onSelect(e) {
        if (this.isDisabled || this.$editorState.isPublishDiff || e.component) return;
        this.focus();
        e.component = {
          name: 'content-element',
          data: this.element
        };
      },
      onSave: function onSave(data) {
        if (!this.isEmbed) this.isSaving = true;
        this.$emit('save', data);
      },
      focus: function focus() {
        this.editorBus.emit('element:focus', this.element, this.parent);
      }
    },
    created: function created() {
      var _this = this;

      var deferSaveFlag = function deferSaveFlag() {
        return setTimeout(function () {
          return _this.isSaving = false;
        }, 1000);
      }; // Element listeners


      this.elementBus.on('delete', function () {
        return _this.$emit('delete');
      });
      this.elementBus.on('save:meta', function (meta) {
        return _this.$emit('save:meta', meta);
      });
      this.elementBus.on('saved', deferSaveFlag); // Editor listeners

      this.editorBus.on('element:select', function (_ref) {
        var elementId = _ref.elementId,
            _ref$isSelected = _ref.isSelected,
            isSelected = _ref$isSelected === void 0 ? true : _ref$isSelected,
            user = _ref.user;
        if (_this.id !== elementId) return; // If current user; focus element

        if (!user || user.id === _this.currentUser.id) {
          _this.isFocused = isSelected;
          if (isSelected) _this.focus();
          return;
        } // If other user, toggle within active users list


        if (isSelected && !_this.activeUsers.find(function (it) {
          return it.id === user.id;
        })) {
          _this.activeUsers.push(user);
        } else if (!isSelected && _this.activeUsers.find(function (it) {
          return it.id === user.id;
        })) {
          _this.activeUsers = _this.activeUsers.filter(function (it) {
            return it.id !== user.id;
          });
        }
      });
      this.editorBus.on('element:focus', function (element) {
        _this.isFocused = !!element && utils.getElementId(element) === _this.id;
      });
    },
    provide: function provide() {
      return {
        $elementBus: this.elementBus
      };
    },
    components: {
      ActiveUsers: ActiveUsers$1,
      Discussion: Discussion$2,
      PublishDiffChip: PublishDiffChip$1
    }
  };

  /* script */
  var __vue_script__$X = script$X;
  /* template */

  var __vue_render__$X = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      staticClass: "content-element",
      "class": [_vm.element.changeSincePublish, {
        selected: _vm.activeUsers.length,
        focused: _vm.isFocused,
        diff: _vm.$editorState.isPublishDiff,
        frame: _vm.frame
      }],
      on: {
        "click": _vm.onSelect
      }
    }, [_c('div', {
      staticClass: "header d-flex",
      "class": {
        visible: _vm.$editorState.isPublishDiff && _vm.element.changeSincePublish
      }
    }, [_c('publish-diff-chip', {
      staticClass: "ml-auto ",
      attrs: {
        "change-type": _vm.element.changeSincePublish
      }
    })], 1), _vm._v(" "), _c('active-users', {
      staticClass: "active-users",
      attrs: {
        "users": _vm.activeUsers,
        "size": 20
      }
    }), _vm._v(" "), _c(_vm.componentName, _vm._b({
      tag: "component",
      attrs: {
        "id": "element_" + _vm.id
      },
      on: {
        "add": function add($event) {
          return _vm.$emit('add', $event);
        },
        "save": _vm.onSave,
        "delete": function _delete($event) {
          return _vm.$emit('delete');
        },
        "focus": _vm.onSelect
      }
    }, 'component', Object.assign({}, _vm.$attrs, {
      element: _vm.element,
      isFocused: _vm.isFocused,
      isDragged: _vm.isDragged,
      isDisabled: _vm.isDisabled,
      dense: _vm.dense
    }), false)), _vm._v(" "), !_vm.isDisabled ? _c('div', {
      staticClass: "element-actions"
    }, [_vm.showDiscussion ? _c('div', {
      "class": {
        'is-visible': _vm.isHighlighted || _vm.hasComments
      }
    }, [_c('discussion', _vm._b({
      attrs: {
        "user": _vm.currentUser
      },
      on: {
        "open": _vm.focus
      }
    }, 'discussion', _vm.element, false))], 1) : _vm._e(), _vm._v(" "), !_vm.parent ? _c('div', {
      "class": {
        'is-visible': _vm.isHighlighted
      }
    }, [_c('v-btn', {
      attrs: {
        "color": "pink lighten-1",
        "dark": "",
        "icon": "",
        "x-small": ""
      },
      on: {
        "click": function click($event) {
          return _vm.$emit('delete');
        }
      }
    }, [_c('v-icon', {
      attrs: {
        "size": "20"
      }
    }, [_vm._v("mdi-delete-outline")])], 1)], 1) : _vm._e()]) : _vm._e(), _vm._v(" "), _vm.isSaving ? _c('v-progress-linear', {
      staticClass: "save-indicator",
      attrs: {
        "height": "2",
        "color": "teal accent-2",
        "indeterminate": ""
      }
    }) : _vm._e()], 1);
  };

  var __vue_staticRenderFns__$X = [];
  /* style */

  var __vue_inject_styles__$X = function __vue_inject_styles__(inject) {
    if (!inject) return;
    inject("data-v-74c5ccda_0", {
      source: ".content-element[data-v-74c5ccda]{position:relative;border:1px solid transparent}.content-element[data-v-74c5ccda]::after{content:'';display:none;position:absolute;top:0;right:-.125rem;width:.125rem;height:100%}.content-element.focused[data-v-74c5ccda]{border:1px dashed #1de9b6}.content-element.focused[data-v-74c5ccda]::after{display:block;background:#1de9b6}.content-element.selected[data-v-74c5ccda]{border:1px dashed #ff4081}.content-element.selected[data-v-74c5ccda]::after{display:block;background:#ff4081}.frame[data-v-74c5ccda]{padding:10px 20px;border:1px solid #e1e1e1}.element-actions[data-v-74c5ccda]{display:flex;flex-direction:column;position:absolute;top:-.0625rem;right:-1.25rem;width:1.5rem;height:100%;padding-left:.75rem}.element-actions>*[data-v-74c5ccda]{min-height:1.75rem;opacity:0;transition:opacity .1s linear}.element-actions>.is-visible[data-v-74c5ccda]{opacity:1;transition:opacity .5s linear}.active-users[data-v-74c5ccda]{position:absolute;top:0;left:-1.625rem}.save-indicator[data-v-74c5ccda]{position:absolute;bottom:-.125rem;left:0}.header[data-v-74c5ccda]{width:100%;max-height:0}.header.visible[data-v-74c5ccda]{max-height:unset;padding:0 0 .5rem}.diff.new[data-v-74c5ccda]{border:none;box-shadow:0 0 0 2px var(--v-success-lighten2)!important}.diff.changed[data-v-74c5ccda],.diff.removed[data-v-74c5ccda]{border:none;box-shadow:0 0 0 2px var(--v-secondary-lighten4)!important}.diff .element-actions[data-v-74c5ccda]{display:none}",
      map: undefined,
      media: undefined
    });
  };
  /* scoped */


  var __vue_scope_id__$X = "data-v-74c5ccda";
  /* module identifier */

  var __vue_module_identifier__$D = undefined;
  /* functional template */

  var __vue_is_functional_template__$X = false;
  /* component normalizer */

  function __vue_normalize__$X(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "ContentElement.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    {
      var hook;

      if (style) {
        hook = function hook(context) {
          style.call(this, createInjector(context));
        };
      }

      if (hook !== undefined) {
        if (component.functional) {
          // register for functional component in vue file
          var originalRender = component.render;

          component.render = function renderWithStyleInjection(h, context) {
            hook.call(context);
            return originalRender(h, context);
          };
        } else {
          // inject component registration as beforeCreate hook
          var existing = component.beforeCreate;
          component.beforeCreate = existing ? [].concat(existing, hook) : [hook];
        }
      }
    }

    return component;
  }
  /* style inject */


  function __vue_create_injector__$D() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$D.styles || (__vue_create_injector__$D.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());
    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = {
        ids: [],
        parts: [],
        element: undefined
      });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;
        style.ids.push(id);

        if (css.map) {
          // https://developer.chrome.com/devtools/docs/javascript-debugging
          // this makes source maps inside style tags work properly in Chrome
          code += '\n/*# sourceURL=' + css.map.sources[0] + ' */'; // http://stackoverflow.com/a/26603875

          code += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(css.map)))) + ' */';
        }

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';
          if (css.media) el.setAttribute('media', css.media);

          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */


  var ContentElement$3 = __vue_normalize__$X({
    render: __vue_render__$X,
    staticRenderFns: __vue_staticRenderFns__$X
  }, __vue_inject_styles__$X, __vue_script__$X, __vue_scope_id__$X, __vue_is_functional_template__$X, __vue_module_identifier__$D, __vue_create_injector__$D);

  //
  var script$W = {
    name: 'content-element-preview',
    props: {
      element: {
        type: Object,
        required: true
      },
      selectable: {
        type: Boolean,
        "default": false
      },
      isSelected: {
        type: Boolean,
        "default": false
      },
      selectionDisabled: {
        type: Boolean,
        "default": false
      }
    },
    computed: {
      disabled: function disabled(vm) {
        return vm.selectionDisabled && !vm.isSelected;
      },
      elementWidth: function elementWidth(vm) {
        return "col-xs-".concat(get__default['default'](vm.element, 'data.width', 12));
      }
    },
    methods: {
      toggleSelection: function toggleSelection() {
        if (!this.selectable || this.disabled) return;
        this.$emit('toggle');
      }
    },
    components: {
      ContentElement: ContentElement$3
    }
  };

  /* script */
  var __vue_script__$W = script$W;
  /* template */

  var __vue_render__$W = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      staticClass: "element-preview-container float-none",
      "class": _vm.elementWidth
    }, [_vm.selectable ? _c('v-checkbox', {
      attrs: {
        "input-value": _vm.isSelected,
        "disabled": _vm.disabled,
        "color": "primary darken-4"
      },
      on: {
        "click": _vm.toggleSelection
      }
    }) : _vm._e(), _vm._v(" "), _c('v-hover', {
      scopedSlots: _vm._u([{
        key: "default",
        fn: function fn(ref) {
          var hover = ref.hover;
          return [_c('div', {
            staticClass: "element-wrapper flex-grow-1"
          }, [_c('content-element', _vm._b({
            staticClass: "content-element",
            "class": {
              selected: _vm.isSelected
            },
            attrs: {
              "element": _vm.element,
              "set-width": false
            }
          }, 'content-element', _vm.$attrs, false)), _vm._v(" "), _c('v-tooltip', {
            attrs: {
              "open-delay": "400",
              "top": ""
            },
            scopedSlots: _vm._u([{
              key: "activator",
              fn: function fn(ref) {
                var on = ref.on;
                return [_c('v-btn', _vm._g({
                  staticClass: "open-element-button",
                  "class": {
                    visible: hover
                  },
                  attrs: {
                    "color": "blue-grey darken-4",
                    "fab": "",
                    "depressed": "",
                    "x-small": ""
                  },
                  on: {
                    "click": function click($event) {
                      $event.stopPropagation();
                      return _vm.$emit('element:open', _vm.element.uid);
                    }
                  }
                }, on), [_c('v-icon', {
                  attrs: {
                    "color": "secondary lighten-4",
                    "dense": ""
                  }
                }, [_vm._v("mdi-open-in-new")])], 1)];
              }
            }], null, true)
          }, [_vm._v(" "), _c('span', [_vm._v("Open in editor")])])], 1)];
        }
      }])
    })], 1);
  };

  var __vue_staticRenderFns__$W = [];
  /* style */

  var __vue_inject_styles__$W = function __vue_inject_styles__(inject) {
    if (!inject) return;
    inject("data-v-72d4e8ff_0", {
      source: ".element-preview-container[data-v-72d4e8ff]{display:flex;position:relative;margin:.25rem 0}.element-preview-container .v-input[data-v-72d4e8ff]{margin:0}.content-element[data-v-72d4e8ff]{flex:1 0;margin:.4375rem 0 0 .25rem;box-shadow:none;border:1px solid #e1e1e1}.content-element.selected[data-v-72d4e8ff]{border-style:dashed;border-color:#444}.content-element.selected[data-v-72d4e8ff]::after{display:none}.element-preview-container[data-v-72d4e8ff]  .contained-content{margin:0}.element-preview-container[data-v-72d4e8ff]  .contained-content .message span:not(.heading){display:none}.element-preview-container[data-v-72d4e8ff]  .contained-content .ql-editor{word-break:break-all}.element-wrapper[data-v-72d4e8ff]{position:relative}.open-element-button[data-v-72d4e8ff]{position:absolute;top:0;right:-.75rem;transition:opacity .4s}.open-element-button[data-v-72d4e8ff]:not(.visible){opacity:0}",
      map: undefined,
      media: undefined
    });
  };
  /* scoped */


  var __vue_scope_id__$W = "data-v-72d4e8ff";
  /* module identifier */

  var __vue_module_identifier__$C = undefined;
  /* functional template */

  var __vue_is_functional_template__$W = false;
  /* component normalizer */

  function __vue_normalize__$W(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "Element.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    {
      var hook;

      if (style) {
        hook = function hook(context) {
          style.call(this, createInjector(context));
        };
      }

      if (hook !== undefined) {
        if (component.functional) {
          // register for functional component in vue file
          var originalRender = component.render;

          component.render = function renderWithStyleInjection(h, context) {
            hook.call(context);
            return originalRender(h, context);
          };
        } else {
          // inject component registration as beforeCreate hook
          var existing = component.beforeCreate;
          component.beforeCreate = existing ? [].concat(existing, hook) : [hook];
        }
      }
    }

    return component;
  }
  /* style inject */


  function __vue_create_injector__$C() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$C.styles || (__vue_create_injector__$C.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());
    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = {
        ids: [],
        parts: [],
        element: undefined
      });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;
        style.ids.push(id);

        if (css.map) {
          // https://developer.chrome.com/devtools/docs/javascript-debugging
          // this makes source maps inside style tags work properly in Chrome
          code += '\n/*# sourceURL=' + css.map.sources[0] + ' */'; // http://stackoverflow.com/a/26603875

          code += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(css.map)))) + ' */';
        }

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';
          if (css.media) el.setAttribute('media', css.media);

          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */


  var ContentElement$2 = __vue_normalize__$W({
    render: __vue_render__$W,
    staticRenderFns: __vue_staticRenderFns__$W
  }, __vue_inject_styles__$W, __vue_script__$W, __vue_scope_id__$W, __vue_is_functional_template__$W, __vue_module_identifier__$C, __vue_create_injector__$C);

  //
  var script$V = {
    name: 'content-preview',
    props: {
      contentContainers: {
        type: Array,
        required: true
      },
      selectable: {
        type: Boolean,
        "default": false
      },
      multiple: {
        type: Boolean,
        "default": true
      },
      allowedTypes: {
        type: Array,
        "default": function _default() {
          return [];
        }
      },
      selected: {
        type: Array,
        "default": function _default() {
          return [];
        }
      }
    },
    computed: {
      isSelectionDisabled: function isSelectionDisabled() {
        return this.selectable && !this.multiple && !!this.selected.length;
      },
      selectionMap: function selectionMap(vm) {
        return keyBy__default['default'](vm.selected, 'id');
      },
      processedContainers: function processedContainers() {
        var containers = this.contentContainers,
            allowedTypes = this.allowedTypes;
        if (!allowedTypes.length) return containers;
        return containers.map(function (container) {
          return Object.assign({}, container, {
            elements: container.elements.filter(function (it) {
              return allowedTypes.includes(it.type);
            })
          });
        });
      },
      elements: function elements() {
        var containers = this.processedContainers;
        return containers.reduce(function (acc, it) {
          return acc.concat(it.elements);
        }, []);
      }
    },
    components: {
      ContentElement: ContentElement$2
    }
  };

  /* script */
  var __vue_script__$V = script$V;
  /* template */

  var __vue_render__$V = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      staticClass: "content-preview"
    }, [!_vm.elements.length ? _c('v-alert', {
      staticClass: "mx-4",
      attrs: {
        "color": "grey darken-4",
        "text": ""
      }
    }, [_vm._v("\n    No available elements.\n  ")]) : _vm._e(), _vm._v(" "), _vm._l(_vm.processedContainers, function (container) {
      return _c('div', {
        key: container.id,
        staticClass: "content-container d-flex flex-wrap"
      }, _vm._l(container.elements, function (element) {
        return _c('content-element', {
          key: element.id,
          attrs: {
            "element": element,
            "selectable": _vm.selectable,
            "is-selected": !!_vm.selectionMap[element.id],
            "selection-disabled": _vm.isSelectionDisabled,
            "is-disabled": ""
          },
          on: {
            "toggle": function toggle($event) {
              return _vm.$emit('toggle', element);
            },
            "element:open": function elementOpen($event) {
              return _vm.$emit('element:open', $event);
            }
          }
        });
      }), 1);
    })], 2);
  };

  var __vue_staticRenderFns__$V = [];
  /* style */

  var __vue_inject_styles__$V = function __vue_inject_styles__(inject) {
    if (!inject) return;
    inject("data-v-2013b96d_0", {
      source: ".content-preview .v-alert[data-v-2013b96d]{display:flex;align-items:center;justify-content:center;height:19rem}.content-preview .content-container[data-v-2013b96d]:last-child{margin-bottom:.625rem}",
      map: undefined,
      media: undefined
    });
  };
  /* scoped */


  var __vue_scope_id__$V = "data-v-2013b96d";
  /* module identifier */

  var __vue_module_identifier__$B = undefined;
  /* functional template */

  var __vue_is_functional_template__$V = false;
  /* component normalizer */

  function __vue_normalize__$V(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "index.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    {
      var hook;

      if (style) {
        hook = function hook(context) {
          style.call(this, createInjector(context));
        };
      }

      if (hook !== undefined) {
        if (component.functional) {
          // register for functional component in vue file
          var originalRender = component.render;

          component.render = function renderWithStyleInjection(h, context) {
            hook.call(context);
            return originalRender(h, context);
          };
        } else {
          // inject component registration as beforeCreate hook
          var existing = component.beforeCreate;
          component.beforeCreate = existing ? [].concat(existing, hook) : [hook];
        }
      }
    }

    return component;
  }
  /* style inject */


  function __vue_create_injector__$B() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$B.styles || (__vue_create_injector__$B.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());
    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = {
        ids: [],
        parts: [],
        element: undefined
      });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;
        style.ids.push(id);

        if (css.map) {
          // https://developer.chrome.com/devtools/docs/javascript-debugging
          // this makes source maps inside style tags work properly in Chrome
          code += '\n/*# sourceURL=' + css.map.sources[0] + ' */'; // http://stackoverflow.com/a/26603875

          code += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(css.map)))) + ' */';
        }

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';
          if (css.media) el.setAttribute('media', css.media);

          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */


  var ContentPreview$1 = __vue_normalize__$V({
    render: __vue_render__$V,
    staticRenderFns: __vue_staticRenderFns__$V
  }, __vue_inject_styles__$V, __vue_script__$V, __vue_scope_id__$V, __vue_is_functional_template__$V, __vue_module_identifier__$B, __vue_create_injector__$B);

  function createCommonjsModule(fn, basedir, module) {
  	return module = {
  	  path: basedir,
  	  exports: {},
  	  require: function (path, base) {
        return commonjsRequire(path, (base === undefined || base === null) ? module.path : base);
      }
  	}, fn(module, module.exports), module.exports;
  }

  function getCjsExportFromNamespace (n) {
  	return n && n['default'] || n;
  }

  function commonjsRequire () {
  	throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
  }

  var delay_1 = createCommonjsModule(function (module) {

  var randomInteger = function randomInteger(minimum, maximum) {
    return Math.floor(Math.random() * (maximum - minimum + 1) + minimum);
  };

  var createAbortError = function createAbortError() {
    var error = new Error('Delay aborted');
    error.name = 'AbortError';
    return error;
  };

  var createDelay = function createDelay(_ref) {
    var defaultClear = _ref.clearTimeout,
        set = _ref.setTimeout,
        willResolve = _ref.willResolve;
    return function (ms) {
      var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          value = _ref2.value,
          signal = _ref2.signal;

      if (signal && signal.aborted) {
        return Promise.reject(createAbortError());
      }

      var timeoutId;
      var settle;
      var rejectFn;
      var clear = defaultClear || clearTimeout;

      var signalListener = function signalListener() {
        clear(timeoutId);
        rejectFn(createAbortError());
      };

      var cleanup = function cleanup() {
        if (signal) {
          signal.removeEventListener('abort', signalListener);
        }
      };

      var delayPromise = new Promise(function (resolve, reject) {
        settle = function settle() {
          cleanup();

          if (willResolve) {
            resolve(value);
          } else {
            reject(value);
          }
        };

        rejectFn = reject;
        timeoutId = (set || setTimeout)(settle, ms);
      });

      if (signal) {
        signal.addEventListener('abort', signalListener, {
          once: true
        });
      }

      delayPromise.clear = function () {
        clear(timeoutId);
        timeoutId = null;
        settle();
      };

      return delayPromise;
    };
  };

  var delay = createDelay({
    willResolve: true
  });
  delay.reject = createDelay({
    willResolve: false
  });

  delay.range = function (minimum, maximum, options) {
    return delay(randomInteger(minimum, maximum), options);
  };

  delay.createWithTimers = function (_ref3) {
    var clearTimeout = _ref3.clearTimeout,
        setTimeout = _ref3.setTimeout;
    var delay = createDelay({
      clearTimeout: clearTimeout,
      setTimeout: setTimeout,
      willResolve: true
    });
    delay.reject = createDelay({
      clearTimeout: clearTimeout,
      setTimeout: setTimeout,
      willResolve: false
    });
    return delay;
  };

  module.exports = delay; // TODO: Remove this for the next major release

  module.exports["default"] = delay;
  });

  var pMinDelay_1 = createCommonjsModule(function (module) {



  var pMinDelay = async function pMinDelay(promise, minimumDelay, options) {
    options = Object.assign({
      delayRejection: true
    }, options);
    var promiseError;

    if (options.delayRejection) {
      promise = promise["catch"](function (error) {
        promiseError = error;
      });
    }

    var value = await Promise.all([promise, delay_1(minimumDelay)]);
    return promiseError ? Promise.reject(promiseError) : value[0];
  };

  module.exports = pMinDelay; // TODO: Remove this for the next major release

  module.exports["default"] = pMinDelay;
  });

  function loader$1(action, name) {
    var minDuration = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    return function () {
      var _this = this;

      this[name] = true;
      return pMinDelay_1(Promise.resolve(action.call.apply(action, [this].concat(Array.prototype.slice.call(arguments)))), minDuration)["finally"](function () {
        return _this[name] = false;
      });
    };
  }

  //
  var toTreeFormat$1 = utils.activity.toTreeFormat,
      getOutlineChildrenFilterFn$1 = utils.activity.getOutlineChildrenFilterFn;
  var script$U = {
    name: 'select-activity',
    inject: ['$schemaService'],
    props: {
      selectedElements: {
        type: Array,
        "default": function _default() {
          return [];
        }
      },
      activities: {
        type: Array,
        "default": function _default() {
          return [];
        }
      }
    },
    data: function data() {
      return {
        search: ''
      };
    },
    computed: {
      groupedSelection: function groupedSelection(vm) {
        return groupBy__default['default'](vm.selectedElements, 'outlineId');
      },
      expandedActivityIds: function expandedActivityIds(vm) {
        return map__default['default'](vm.activities, 'id');
      },
      activityTree: function activityTree() {
        return toTreeFormat$1(this.activities, {
          filterNodesFn: getOutlineChildrenFilterFn$1(this.$schemaService)
        });
      },
      noResultsMessage: function noResultsMessage() {
        var activities = this.activities,
            search = this.search,
            $refs = this.$refs;
        if (!activities.length) return 'Empty repository';
        if (!search || !$refs) return '';
        var _$refs$treeview = $refs.treeview,
            excludedItems = _$refs$treeview.excludedItems,
            nodes = _$refs$treeview.nodes;
        var hasSearchResults = excludedItems.size !== Object.keys(nodes).length;
        return !hasSearchResults && 'No matches found';
      }
    },
    methods: {
      hasContentContainers: function hasContentContainers(type) {
        return this.$schemaService.isEditable(type);
      },
      getChipLabel: function getChipLabel(_ref) {
        var length = _ref.length;
        return "".concat(length, " ").concat(pluralize__default['default']('element', length), " selected");
      }
    }
  };

  /* script */
  var __vue_script__$U = script$U;
  /* template */

  var __vue_render__$U = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      staticClass: "mx-3"
    }, [_c('v-text-field', {
      attrs: {
        "disabled": !_vm.activities.length,
        "placeholder": "Filter items...",
        "prepend-inner-icon": "mdi-filter-outline",
        "clear-icon": "mdi-close-circle-outline",
        "clearable": "",
        "outlined": ""
      },
      model: {
        value: _vm.search,
        callback: function callback($$v) {
          _vm.search = $$v;
        },
        expression: "search"
      }
    }), _vm._v(" "), _c('v-treeview', {
      directives: [{
        name: "show",
        rawName: "v-show",
        value: !_vm.noResultsMessage,
        expression: "!noResultsMessage"
      }],
      ref: "treeview",
      staticClass: "py-3 px-1 treeview",
      attrs: {
        "items": _vm.activityTree,
        "search": _vm.search,
        "open": _vm.expandedActivityIds,
        "transition": "",
        "open-on-click": ""
      },
      scopedSlots: _vm._u([{
        key: "label",
        fn: function fn(ref) {
          var ref_item = ref.item;
          var id = ref_item.id;
          var data = ref_item.data;
          return [_vm._v("\n      " + _vm._s(data.name) + "\n      "), _vm.groupedSelection[id] ? _c('v-chip', {
            staticClass: "readonly custom-chip",
            attrs: {
              "rounded": "",
              "small": ""
            }
          }, [_vm._v("\n        " + _vm._s(_vm.getChipLabel(_vm.groupedSelection[id])) + "\n      ")]) : _vm._e()];
        }
      }, {
        key: "append",
        fn: function fn(ref) {
          var item = ref.item;
          return [_vm.hasContentContainers(item.type) ? _c('v-btn', {
            attrs: {
              "color": "primary darken-2",
              "outlined": "",
              "small": ""
            },
            on: {
              "click": function click($event) {
                return _vm.$emit('selected', item);
              }
            }
          }, [_vm._v("\n        View elements\n      ")]) : _vm._e()];
        }
      }])
    }), _vm._v(" "), _c('v-alert', {
      attrs: {
        "value": !!_vm.noResultsMessage,
        "color": "primary darken-2",
        "dark": ""
      }
    }, [_vm._v("\n    " + _vm._s(_vm.noResultsMessage) + "\n  ")])], 1);
  };

  var __vue_staticRenderFns__$U = [];
  /* style */

  var __vue_inject_styles__$U = function __vue_inject_styles__(inject) {
    if (!inject) return;
    inject("data-v-466d804b_0", {
      source: ".treeview[data-v-466d804b]{max-height:19rem;text-align:left;background-color:#fcfcfc;border:1px solid #eee;overflow-y:scroll}.treeview .v-chip.custom-chip[data-v-466d804b]{border-radius:12px!important}.treeview[data-v-466d804b]  .v-treeview-node--leaf>.treeview ::v-deep .v-treeview-node__content>*,.treeview[data-v-466d804b]  .v-treeview-node--leaf>.treeview ::v-deep .v-treeview-node__root{cursor:auto}",
      map: undefined,
      media: undefined
    });
  };
  /* scoped */


  var __vue_scope_id__$U = "data-v-466d804b";
  /* module identifier */

  var __vue_module_identifier__$A = undefined;
  /* functional template */

  var __vue_is_functional_template__$U = false;
  /* component normalizer */

  function __vue_normalize__$U(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "SelectActivity.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    {
      var hook;

      if (style) {
        hook = function hook(context) {
          style.call(this, createInjector(context));
        };
      }

      if (hook !== undefined) {
        if (component.functional) {
          // register for functional component in vue file
          var originalRender = component.render;

          component.render = function renderWithStyleInjection(h, context) {
            hook.call(context);
            return originalRender(h, context);
          };
        } else {
          // inject component registration as beforeCreate hook
          var existing = component.beforeCreate;
          component.beforeCreate = existing ? [].concat(existing, hook) : [hook];
        }
      }
    }

    return component;
  }
  /* style inject */


  function __vue_create_injector__$A() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$A.styles || (__vue_create_injector__$A.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());
    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = {
        ids: [],
        parts: [],
        element: undefined
      });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;
        style.ids.push(id);

        if (css.map) {
          // https://developer.chrome.com/devtools/docs/javascript-debugging
          // this makes source maps inside style tags work properly in Chrome
          code += '\n/*# sourceURL=' + css.map.sources[0] + ' */'; // http://stackoverflow.com/a/26603875

          code += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(css.map)))) + ' */';
        }

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';
          if (css.media) el.setAttribute('media', css.media);

          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */


  var SelectActivity$1 = __vue_normalize__$U({
    render: __vue_render__$U,
    staticRenderFns: __vue_staticRenderFns__$U
  }, __vue_inject_styles__$U, __vue_script__$U, __vue_scope_id__$U, __vue_is_functional_template__$U, __vue_module_identifier__$A, __vue_create_injector__$A);

  //
  var script$T = {
    name: 'select-repository',
    props: {
      repository: {
        type: Object,
        "default": null
      }
    },
    inject: ['$api'],
    data: function data() {
      return {
        repositories: [],
        loading: false
      };
    },
    methods: {
      selectRepository: function selectRepository(repository) {
        if (find__default['default'](this.repositories, {
          id: repository.id
        })) {
          this.$emit('selected', repository);
        }
      },
      fetchRepositories: debounce__default['default'](loader$1(function (search) {
        var _this = this;

        return this.$api.fetchRepositories({
          search: search
        }).then(function (repositories) {
          _this.repositories = sortBy__default['default'](repositories, 'name');
        });
      }, 'loading'), 500)
    },
    created: function created() {
      this.fetchRepositories();
    }
  };

  /* script */
  var __vue_script__$T = script$T;
  /* template */

  var __vue_render__$T = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('v-combobox', _vm._b({
      staticClass: "mx-3",
      attrs: {
        "value": _vm.repository,
        "items": _vm.repositories,
        "loading": _vm.loading,
        "item-value": "id",
        "item-text": "name",
        "label": "Select repository",
        "placeholder": "Type to search repositories...",
        "outlined": "",
        "return-object": ""
      },
      on: {
        "input": _vm.selectRepository,
        "update:search-input": _vm.fetchRepositories
      }
    }, 'v-combobox', _vm.$attrs, false));
  };

  var __vue_staticRenderFns__$T = [];
  /* style */

  var __vue_inject_styles__$T = undefined;
  /* scoped */

  var __vue_scope_id__$T = undefined;
  /* functional template */

  var __vue_is_functional_template__$T = false;
  /* component normalizer */

  function __vue_normalize__$T(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "SelectRepository.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */

  /* style inject SSR */


  var SelectRepository$1 = __vue_normalize__$T({
    render: __vue_render__$T,
    staticRenderFns: __vue_staticRenderFns__$T
  }, __vue_inject_styles__$T, __vue_script__$T, __vue_scope_id__$T, __vue_is_functional_template__$T);

  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  var script$S = {
    name: 'tailor-dialog',
    props: {
      headerIcon: {
        type: String,
        "default": null
      },
      width: {
        type: [Number, String],
        "default": 500
      },
      paddingless: {
        type: Boolean,
        "default": false
      }
    }
  };

  /* script */
  var __vue_script__$S = script$S;
  /* template */

  var __vue_render__$S = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('v-dialog', _vm._g(_vm._b({
      attrs: {
        "width": _vm.width
      },
      scopedSlots: _vm._u([_vm._l(_vm.$scopedSlots, function (_, slot) {
        return {
          key: slot,
          fn: function fn(scope) {
            return [_vm._t(slot, null, null, scope)];
          }
        };
      })], null, true)
    }, 'v-dialog', _vm.$attrs, false), _vm.$listeners), [_vm._v(" "), _c('v-card', [_c('v-card-title', {
      staticClass: "dialog-title primary darken-3",
      attrs: {
        "primary-title": ""
      }
    }, [_vm.headerIcon ? _c('v-avatar', {
      staticClass: "mr-3",
      attrs: {
        "color": "secondary",
        "size": "38"
      }
    }, [_c('v-icon', {
      attrs: {
        "dark": ""
      }
    }, [_vm._v(_vm._s(_vm.headerIcon))])], 1) : _vm._e(), _vm._v(" "), _c('div', {
      staticClass: "text-truncate"
    }, [_vm._t("header")], 2)], 1), _vm._v(" "), _c('v-card-text', {
      "class": [_vm.paddingless ? 'pa-0' : 'pt-7 px-4 pb-2']
    }, [_vm._t("body")], 2), _vm._v(" "), _vm.$slots.actions ? _c('v-card-actions', {
      staticClass: "px-4 pb-3"
    }, [_c('v-spacer'), _vm._v(" "), _vm._t("actions")], 2) : _vm._e()], 1)], 1);
  };

  var __vue_staticRenderFns__$S = [];
  /* style */

  var __vue_inject_styles__$S = function __vue_inject_styles__(inject) {
    if (!inject) return;
    inject("data-v-b6f646a2_0", {
      source: ".dialog-title[data-v-b6f646a2]{display:flex;color:#f1f1f1}.dialog-title .text-truncate[data-v-b6f646a2]{flex:1;text-align:left}",
      map: undefined,
      media: undefined
    });
  };
  /* scoped */


  var __vue_scope_id__$S = "data-v-b6f646a2";
  /* module identifier */

  var __vue_module_identifier__$z = undefined;
  /* functional template */

  var __vue_is_functional_template__$S = false;
  /* component normalizer */

  function __vue_normalize__$S(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "TailorDialog.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    {
      var hook;

      if (style) {
        hook = function hook(context) {
          style.call(this, createInjector(context));
        };
      }

      if (hook !== undefined) {
        if (component.functional) {
          // register for functional component in vue file
          var originalRender = component.render;

          component.render = function renderWithStyleInjection(h, context) {
            hook.call(context);
            return originalRender(h, context);
          };
        } else {
          // inject component registration as beforeCreate hook
          var existing = component.beforeCreate;
          component.beforeCreate = existing ? [].concat(existing, hook) : [hook];
        }
      }
    }

    return component;
  }
  /* style inject */


  function __vue_create_injector__$z() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$z.styles || (__vue_create_injector__$z.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());
    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = {
        ids: [],
        parts: [],
        element: undefined
      });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;
        style.ids.push(id);

        if (css.map) {
          // https://developer.chrome.com/devtools/docs/javascript-debugging
          // this makes source maps inside style tags work properly in Chrome
          code += '\n/*# sourceURL=' + css.map.sources[0] + ' */'; // http://stackoverflow.com/a/26603875

          code += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(css.map)))) + ' */';
        }

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';
          if (css.media) el.setAttribute('media', css.media);

          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */


  var TailorDialog$1 = __vue_normalize__$S({
    render: __vue_render__$S,
    staticRenderFns: __vue_staticRenderFns__$S
  }, __vue_inject_styles__$S, __vue_script__$S, __vue_scope_id__$S, __vue_is_functional_template__$S, __vue_module_identifier__$z, __vue_create_injector__$z);

  var getDescendants$1 = utils.activity.getDescendants;
  var TOGGLE_BUTTON$1 = {
    SELECT: {
      label: 'Select all',
      icon: 'checkbox-multiple-marked-outline'
    },
    DESELECT: {
      label: 'Deselect all',
      icon: 'checkbox-multiple-blank-outline'
    }
  };
  var script$R = {
    name: 'select-element',
    inject: ['$schemaService', '$repository', '$api'],
    props: {
      selected: {
        type: Array,
        "default": function _default() {
          return [];
        }
      },
      heading: {
        type: String,
        required: true
      },
      allowedTypes: {
        type: Array,
        required: true
      },
      multiple: {
        type: Boolean,
        "default": true
      },
      submitLabel: {
        type: String,
        "default": 'Save'
      },
      headerIcon: {
        type: String,
        "default": 'mdi-toy-brick-plus-outline'
      },
      onlyCurrentRepo: {
        type: Boolean,
        "default": false
      }
    },
    data: function data() {
      return {
        items: {
          activities: [],
          contentContainers: []
        },
        selection: {
          repository: null,
          activity: null,
          elements: []
        },
        loadingContent: false
      };
    },
    computed: {
      currentRepository: function currentRepository(vm) {
        return vm.$repository;
      },
      allElementsSelected: function allElementsSelected(vm) {
        return vm.selection.elements.length === vm.elements.length;
      },
      rootContainerTypes: function rootContainerTypes() {
        var _this$selection$activ;

        var type = (_this$selection$activ = this.selection.activity) === null || _this$selection$activ === void 0 ? void 0 : _this$selection$activ.type;
        return type && this.getContainerTypes(type);
      },
      processedContainers: function processedContainers() {
        var _this = this;

        var activity = this.selection.activity,
            activities = this.items.activities;
        if (!activity || !activities.length) return [];
        var containers = sortBy__default['default'](activities.filter(this.isRootContainer), [this.getTypePosition, 'position', 'createdAt']);
        return flatMap__default['default'](containers, function (it) {
          return [it].concat(_toConsumableArray$1(_this.getSubcontainers(it)));
        });
      },
      elements: function elements() {
        var _this2 = this;

        var elements = flatMap__default['default'](this.items.contentContainers, 'elements');
        if (!this.allowedTypes.length) return elements;
        return elements.filter(function (it) {
          return _this2.allowedTypes.includes(it.type);
        });
      },
      toggleButton: function toggleButton() {
        var allElementsSelected = this.allElementsSelected,
            elements = this.elements,
            multiple = this.multiple,
            selection = this.selection;
        if (!multiple || !selection.activity || !elements.length) return;
        var SELECT = TOGGLE_BUTTON$1.SELECT,
            DESELECT = TOGGLE_BUTTON$1.DESELECT;
        return allElementsSelected ? DESELECT : SELECT;
      }
    },
    methods: {
      getContainerTypes: function getContainerTypes(type) {
        return map__default['default'](this.$schemaService.getSupportedContainers(type), 'type');
      },
      getTypePosition: function getTypePosition(_ref) {
        var type = _ref.type;
        return this.rootContainerTypes.indexOf(type);
      },
      isRootContainer: function isRootContainer(_ref2) {
        var parentId = _ref2.parentId,
            type = _ref2.type;
        var activity = this.selection.activity,
            rootContainerTypes = this.rootContainerTypes;
        return parentId === activity.id && rootContainerTypes.includes(type);
      },
      getSubcontainers: function getSubcontainers(container) {
        var activities = this.items.activities;
        return sortBy__default['default'](getDescendants$1(activities, container), 'position');
      },
      showActivityElements: async function showActivityElements(activity) {
        var _this3 = this;

        this.selection.activity = activity;
        var processedContainers = this.processedContainers;
        var elements = await this.fetchElements(processedContainers);
        this.items.contentContainers = processedContainers.map(function (container) {
          return _this3.assignElements(container, activity, elements);
        });
      },
      assignElements: function assignElements(container, activity, elements) {
        var containerElements = elements.filter(function (it) {
          return it.activityId === container.id;
        }).map(function (element) {
          return Object.assign({}, element, {
            activity: activity
          });
        });
        return Object.assign({}, container, {
          elements: sortBy__default['default'](containerElements, 'position')
        });
      },
      toggleElementSelection: function toggleElementSelection(element) {
        var elements = this.selection.elements;
        var existing = elements.find(function (it) {
          return it.id === element.id;
        });
        this.selection.elements = existing ? elements.filter(function (it) {
          return it.id !== element.id;
        }) : elements.concat(element);
      },
      toggleSelectAll: function toggleSelectAll() {
        this.selection.elements = this.allElementsSelected ? [] : this.elements;
      },
      deselectActivity: function deselectActivity() {
        this.selection.activity = null;
        this.items.contentContainers = [];
        this.selection.elements = _toConsumableArray$1(this.selected);
      },
      selectRepository: async function selectRepository(repository) {
        var currentRepository = this.currentRepository;
        this.selection.repository = repository;
        this.deselectActivity();
        this.items.activities = currentRepository.id === repository.id ? currentRepository.activities : await this.fetchActivities(repository);
      },
      fetchActivities: loader$1(function (repository) {
        return this.$api.fetchActivities(repository.id);
      }, 'loadingContent'),
      fetchElements: loader$1(function (containers) {
        var repositoryId = this.selection.repository.id;
        var queryOpts = {
          repositoryId: repositoryId,
          ids: containers.map(function (it) {
            return it.id;
          })
        };
        return this.$api.fetchContentElements(queryOpts);
      }, 'loadingContent', 500),
      save: function save() {
        this.$emit('selected', _toConsumableArray$1(this.selection.elements));
        this.close();
      },
      close: function close() {
        this.$emit('close');
      },
      openInEditor: function openInEditor(elementId) {
        var params = {
          activityId: this.selection.activity.id,
          repositoryId: this.selection.repository.id
        };
        var route = {
          name: 'editor',
          params: params,
          query: {
            elementId: elementId
          }
        };

        var _this$$router$resolve = this.$router.resolve(route),
            href = _this$$router$resolve.href;

        window.open(href, '_blank');
      }
    },
    created: function created() {
      this.selection.elements = _toConsumableArray$1(this.selected);
      this.selection.repository = this.currentRepository;
      this.items.activities = this.currentRepository.activities;
    },
    components: {
      ContentPreview: ContentPreview$1,
      SelectActivity: SelectActivity$1,
      SelectRepository: SelectRepository$1,
      TailorDialog: TailorDialog$1
    }
  };

  /* script */
  var __vue_script__$R = script$R;
  /* template */

  var __vue_render__$R = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('tailor-dialog', {
      attrs: {
        "value": true,
        "header-icon": _vm.headerIcon,
        "width": "650",
        "scrollable": ""
      },
      on: {
        "click:outside": _vm.close
      },
      scopedSlots: _vm._u([{
        key: "header",
        fn: function fn() {
          return [_vm._v(_vm._s(_vm.heading))];
        },
        proxy: true
      }, {
        key: "body",
        fn: function fn() {
          return [!_vm.selection.activity ? [_c('select-repository', {
            attrs: {
              "repository": _vm.selection.repository,
              "disabled": _vm.onlyCurrentRepo
            },
            on: {
              "selected": _vm.selectRepository
            }
          }), _vm._v(" "), _vm.loadingContent ? _c('v-progress-circular', {
            staticClass: "mt-5",
            attrs: {
              "indeterminate": ""
            }
          }) : _c('select-activity', {
            attrs: {
              "activities": _vm.items.activities,
              "selected-elements": _vm.selection.elements
            },
            on: {
              "selected": _vm.showActivityElements
            }
          })] : [_vm.toggleButton ? _c('div', {
            staticClass: "d-flex justify-end mb-2 px-4"
          }, [_c('v-btn', {
            attrs: {
              "outlined": ""
            },
            on: {
              "click": _vm.toggleSelectAll
            }
          }, [_c('v-icon', {
            staticClass: "mr-2"
          }, [_vm._v("mdi-" + _vm._s(_vm.toggleButton.icon))]), _vm._v("\n          " + _vm._s(_vm.toggleButton.label) + "\n        ")], 1)], 1) : _vm._e(), _vm._v(" "), _vm.loadingContent ? _c('v-progress-circular', {
            staticClass: "mt-5",
            attrs: {
              "indeterminate": ""
            }
          }) : _c('content-preview', {
            attrs: {
              "content-containers": _vm.items.contentContainers,
              "selected": _vm.selection.elements,
              "allowed-types": _vm.allowedTypes,
              "multiple": _vm.multiple,
              "selectable": ""
            },
            on: {
              "toggle": _vm.toggleElementSelection,
              "element:open": _vm.openInEditor
            }
          })]];
        },
        proxy: true
      }, {
        key: "actions",
        fn: function fn() {
          return [_vm.selection.activity ? _c('v-btn', {
            staticClass: "mr-2",
            attrs: {
              "text": "",
              "outlined": ""
            },
            on: {
              "click": _vm.deselectActivity
            }
          }, [_c('v-icon', {
            staticClass: "mr-2",
            attrs: {
              "dense": ""
            }
          }, [_vm._v("mdi-arrow-left")]), _vm._v("Back\n    ")], 1) : _vm._e(), _vm._v(" "), _c('v-btn', {
            staticClass: "ml-1",
            attrs: {
              "text": ""
            },
            on: {
              "click": _vm.close
            }
          }, [_vm._v("Cancel")]), _vm._v(" "), _c('v-btn', {
            staticClass: "mr-2",
            attrs: {
              "text": ""
            },
            on: {
              "click": _vm.save
            }
          }, [_vm._v(_vm._s(_vm.submitLabel))])];
        },
        proxy: true
      }])
    });
  };

  var __vue_staticRenderFns__$R = [];
  /* style */

  var __vue_inject_styles__$R = undefined;
  /* scoped */

  var __vue_scope_id__$R = undefined;
  /* functional template */

  var __vue_is_functional_template__$R = false;
  /* component normalizer */

  function __vue_normalize__$R(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "index.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */

  /* style inject SSR */


  var SelectElement$1 = __vue_normalize__$R({
    render: __vue_render__$R,
    staticRenderFns: __vue_staticRenderFns__$R
  }, __vue_inject_styles__$R, __vue_script__$R, __vue_scope_id__$R, __vue_is_functional_template__$R);

  //
  var DEFAULT_ELEMENT_WIDTH$1 = 100;
  var LAYOUT$1 = {
    HALF_WIDTH: 6,
    FULL_WIDTH: 12
  };
  var ELEMENT_GROUPS$1 = [{
    name: 'Content Elements',
    icon: 'mdi-set-center'
  }, {
    name: 'Assessments',
    icon: 'mdi-help-rhombus'
  }, {
    name: 'Nongraded questions',
    icon: 'mdi-comment-question-outline'
  }];

  var getQuestionData$1 = function getQuestionData(element, type) {
    var data = {
      width: LAYOUT$1.FULL_WIDTH
    };
    var question = [{
      id: utils.uuid(),
      data: data,
      type: 'JODIT_HTML',
      embedded: true
    }];
    return Object.assign({
      question: question,
      type: type
    }, element.data);
  };

  var script$Q = {
    name: 'tailor-add-element',
    inject: ['$teRegistry'],
    props: {
      items: {
        type: Array,
        required: true
      },
      activity: {
        type: Object,
        "default": null
      },
      position: {
        type: Number,
        "default": null
      },
      layout: {
        type: Boolean,
        "default": true
      },
      include: {
        type: Array,
        "default": null
      },
      show: {
        type: Boolean,
        "default": false
      },
      large: {
        type: Boolean,
        "default": false
      },
      label: {
        type: String,
        "default": 'Add content'
      },
      icon: {
        type: String,
        "default": 'mdi-plus'
      }
    },
    data: function data() {
      return {
        isVisible: false,
        elementWidth: DEFAULT_ELEMENT_WIDTH$1,
        showElementBrowser: false
      };
    },
    computed: {
      registry: function registry() {
        return this.$teRegistry.all;
      },
      questions: function questions() {
        return filter__default['default'](this.registry, {
          type: 'QUESTION'
        });
      },
      contentElements: function contentElements() {
        var _this = this;

        var items = filter__default['default'](this.registry, function (it) {
          return !utils.isQuestion(it.type);
        });
        if (!this.isSubset) return items;
        return filter__default['default'](items, function (it) {
          return _this.include.includes(it.type);
        });
      },
      assessments: function assessments() {
        var registry = this.registry,
            isSubset = this.isSubset,
            include = this.include,
            questions = this.questions;
        if (isSubset && !include.includes('ASSESSMENT')) return [];
        return filter__default['default'](registry, {
          type: 'ASSESSMENT'
        }).concat(questions.map(function (it) {
          return Object.assign({}, it, {
            type: 'ASSESSMENT'
          });
        }));
      },
      reflections: function reflections() {
        var registry = this.registry,
            isSubset = this.isSubset,
            include = this.include,
            questions = this.questions;
        if (isSubset && !include.includes('REFLECTION')) return [];
        return filter__default['default'](registry, {
          type: 'REFLECTION'
        }).concat(questions.map(function (it) {
          return Object.assign({}, it, {
            type: 'REFLECTION'
          });
        }));
      },
      isSubset: function isSubset() {
        return !!this.include && !!this.include.length;
      },
      library: function library() {
        var groups = [this.contentElements, this.assessments, this.reflections];
        return reduce__default['default'](groups, function (acc, elements, i) {
          if (elements.length) acc.push(Object.assign({}, ELEMENT_GROUPS$1[i], {
            elements: elements
          }));
          return acc;
        }, []);
      },
      processedWidth: function processedWidth() {
        return this.elementWidth === 50 ? LAYOUT$1.HALF_WIDTH : LAYOUT$1.FULL_WIDTH;
      },
      allowedTypes: function allowedTypes() {
        var elementWidth = this.elementWidth,
            include = this.include,
            layout = this.layout,
            library = this.library;
        var elements = flatMap__default['default'](library, 'elements');
        if (!layout) return include || [];
        var allowedElements = elementWidth === DEFAULT_ELEMENT_WIDTH$1 ? elements : reject__default['default'](elements, 'ui.forceFullWidth');
        var allowedTypes = allowedElements.map(function (it) {
          return it.type;
        });
        return include ? intersection__default['default'](include, allowedTypes) : allowedTypes;
      }
    },
    methods: {
      addElements: function addElements(elements) {
        var _this2 = this;

        var positions = utils.getPositions(this.items, this.position, elements.length);
        var items = elements.map(function (it, index) {
          return _this2.buildElement(Object.assign({}, it, {
            position: positions[index]
          }));
        });
        this.$emit('add', items);
        this.isVisible = false;
      },
      buildElement: function buildElement(el) {
        var width = this.processedWidth,
            activity = this.activity;
        var position = el.position,
            subtype = el.subtype,
            _el$data = el.data,
            data = _el$data === void 0 ? {} : _el$data,
            _el$initState = el.initState,
            initState = _el$initState === void 0 ? function () {
          return {};
        } : _el$initState;
        var element = Object.assign({
          position: position
        }, pick__default['default'](el, ['type', 'refs']), {
          data: Object.assign({}, initState(), data, {
            width: width
          })
        });
        var contextData = activity ? {
          activityId: activity.id
        } // If content element within activity
        : {
          id: utils.uuid(),
          embedded: true
        }; // If embed, assign id

        Object.assign(element, contextData);
        if (utils.isQuestion(element.type)) element.data = getQuestionData$1(element, subtype);
        if (element.type === 'REFLECTION') delete element.data.correct;
        return element;
      },
      onHidden: function onHidden() {
        this.elementWidth = DEFAULT_ELEMENT_WIDTH$1;
        this.$emit('hidden');
      },
      showElementPicker: function showElementPicker() {
        this.isVisible = true;
      }
    },
    watch: {
      isVisible: function isVisible(val, oldVal) {
        if (!val && oldVal) this.onHidden();
      },
      show: function show(val) {
        return val ? this.showElementPicker() : this.onHidden();
      }
    },
    components: {
      AddNewElement: AddNewElement$1,
      SelectElement: SelectElement$1
    }
  };

  /* script */
  var __vue_script__$Q = script$Q;
  /* template */

  var __vue_render__$Q = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      staticClass: "add-element-container"
    }, [_vm._t("default", [_vm.large ? _c('v-btn', {
      staticClass: "mt-3 mb-4",
      attrs: {
        "color": "primary darken-3",
        "text": ""
      },
      on: {
        "click": function click($event) {
          $event.stopPropagation();
          return _vm.showElementPicker($event);
        }
      }
    }, [_c('v-icon', {
      staticClass: "pr-2"
    }, [_vm._v(_vm._s(_vm.icon))]), _vm._v(_vm._s(_vm.label) + "\n    ")], 1) : _c('v-btn', {
      attrs: {
        "color": "primary darken-3",
        "icon": "",
        "text": ""
      },
      on: {
        "click": function click($event) {
          $event.stopPropagation();
          return _vm.showElementPicker($event);
        }
      }
    }, [_c('v-icon', [_vm._v(_vm._s(_vm.icon))])], 1)], {
      "addElement": _vm.showElementPicker
    }), _vm._v(" "), _vm.isVisible ? [_vm.showElementBrowser ? _c('select-element', {
      attrs: {
        "allowed-types": _vm.allowedTypes,
        "submit-label": "Copy",
        "heading": "Copy elements",
        "header-icon": "mdi-content-duplicate",
        "multiple": ""
      },
      on: {
        "selected": _vm.addElements,
        "close": function close($event) {
          _vm.showElementBrowser = false;
        }
      }
    }) : _c('add-new-element', {
      attrs: {
        "library": _vm.library,
        "allowed-types": _vm.allowedTypes
      },
      on: {
        "add": _vm.addElements
      },
      scopedSlots: _vm._u([{
        key: "header",
        fn: function fn() {
          return [_vm.layout ? _c('div', {
            staticClass: "mr-6"
          }, [_c('div', {
            staticClass: "pb-1 caption text-left"
          }, [_vm._v("Element width")]), _vm._v(" "), _c('v-btn-toggle', {
            attrs: {
              "color": "secondary accent-2",
              "mandatory": ""
            },
            model: {
              value: _vm.elementWidth,
              callback: function callback($$v) {
                _vm.elementWidth = $$v;
              },
              expression: "elementWidth"
            }
          }, [_c('v-btn', {
            attrs: {
              "value": 100,
              "height": "38",
              "icon": ""
            }
          }, [_c('v-icon', [_vm._v("mdi-square-outline")])], 1), _vm._v(" "), _c('v-btn', {
            attrs: {
              "value": 50,
              "height": "38",
              "icon": ""
            }
          }, [_c('v-icon', [_vm._v("mdi-select-compare")])], 1)], 1)], 1) : _vm._e(), _vm._v(" "), _c('v-btn', {
            staticClass: "mt-6",
            attrs: {
              "color": "primary darken-3",
              "depressed": ""
            },
            on: {
              "click": function click($event) {
                _vm.showElementBrowser = !_vm.showElementBrowser;
              }
            }
          }, [_c('v-icon', {
            staticClass: "mr-2",
            attrs: {
              "dense": ""
            }
          }, [_vm._v("mdi-content-copy")]), _vm._v("\n          Copy existing\n        ")], 1)];
        },
        proxy: true
      }], null, false, 2543524328),
      model: {
        value: _vm.isVisible,
        callback: function callback($$v) {
          _vm.isVisible = $$v;
        },
        expression: "isVisible"
      }
    })] : _vm._e()], 2);
  };

  var __vue_staticRenderFns__$Q = [];
  /* style */

  var __vue_inject_styles__$Q = undefined;
  /* scoped */

  var __vue_scope_id__$Q = undefined;
  /* functional template */

  var __vue_is_functional_template__$Q = false;
  /* component normalizer */

  function __vue_normalize__$Q(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "index.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */

  /* style inject SSR */


  var AddElement$1 = __vue_normalize__$Q({
    render: __vue_render__$Q,
    staticRenderFns: __vue_staticRenderFns__$Q
  }, __vue_inject_styles__$Q, __vue_script__$Q, __vue_scope_id__$Q, __vue_is_functional_template__$Q);

  function _extends() {
    _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends.apply(this, arguments);
  }

  /** Used for built-in method references. */
  var objectProto$f = Object.prototype;
  /** Used to check objects for own properties. */

  var hasOwnProperty$c = objectProto$f.hasOwnProperty;
  /**
   * The base implementation of `_.has` without support for deep paths.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {Array|string} key The key to check.
   * @returns {boolean} Returns `true` if `key` exists, else `false`.
   */

  function baseHas(object, key) {
    return object != null && hasOwnProperty$c.call(object, key);
  }

  /**
   * Checks if `value` is classified as an `Array` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an array, else `false`.
   * @example
   *
   * _.isArray([1, 2, 3]);
   * // => true
   *
   * _.isArray(document.body.children);
   * // => false
   *
   * _.isArray('abc');
   * // => false
   *
   * _.isArray(_.noop);
   * // => false
   */
  var isArray = Array.isArray;

  /** Detect free variable `global` from Node.js. */
  var freeGlobal = (typeof global === "undefined" ? "undefined" : _typeof(global)) == 'object' && global && global.Object === Object && global;

  /** Detect free variable `self`. */

  var freeSelf = (typeof self === "undefined" ? "undefined" : _typeof(self)) == 'object' && self && self.Object === Object && self;
  /** Used as a reference to the global object. */

  var root = freeGlobal || freeSelf || Function('return this')();

  /** Built-in value references. */

  var _Symbol = root.Symbol;

  /** Used for built-in method references. */

  var objectProto$e = Object.prototype;
  /** Used to check objects for own properties. */

  var hasOwnProperty$b = objectProto$e.hasOwnProperty;
  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */

  var nativeObjectToString$1 = objectProto$e.toString;
  /** Built-in value references. */

  var symToStringTag$1 = _Symbol ? _Symbol.toStringTag : undefined;
  /**
   * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the raw `toStringTag`.
   */

  function getRawTag(value) {
    var isOwn = hasOwnProperty$b.call(value, symToStringTag$1),
        tag = value[symToStringTag$1];

    try {
      value[symToStringTag$1] = undefined;
      var unmasked = true;
    } catch (e) {}

    var result = nativeObjectToString$1.call(value);

    if (unmasked) {
      if (isOwn) {
        value[symToStringTag$1] = tag;
      } else {
        delete value[symToStringTag$1];
      }
    }

    return result;
  }

  /** Used for built-in method references. */
  var objectProto$d = Object.prototype;
  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */

  var nativeObjectToString = objectProto$d.toString;
  /**
   * Converts `value` to a string using `Object.prototype.toString`.
   *
   * @private
   * @param {*} value The value to convert.
   * @returns {string} Returns the converted string.
   */

  function objectToString(value) {
    return nativeObjectToString.call(value);
  }

  /** `Object#toString` result references. */

  var nullTag = '[object Null]',
      undefinedTag = '[object Undefined]';
  /** Built-in value references. */

  var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;
  /**
   * The base implementation of `getTag` without fallbacks for buggy environments.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the `toStringTag`.
   */

  function baseGetTag(value) {
    if (value == null) {
      return value === undefined ? undefinedTag : nullTag;
    }

    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
  }

  /**
   * Checks if `value` is object-like. A value is object-like if it's not `null`
   * and has a `typeof` result of "object".
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
   * @example
   *
   * _.isObjectLike({});
   * // => true
   *
   * _.isObjectLike([1, 2, 3]);
   * // => true
   *
   * _.isObjectLike(_.noop);
   * // => false
   *
   * _.isObjectLike(null);
   * // => false
   */
  function isObjectLike(value) {
    return value != null && _typeof(value) == 'object';
  }

  /** `Object#toString` result references. */

  var symbolTag$3 = '[object Symbol]';
  /**
   * Checks if `value` is classified as a `Symbol` primitive or object.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
   * @example
   *
   * _.isSymbol(Symbol.iterator);
   * // => true
   *
   * _.isSymbol('abc');
   * // => false
   */

  function isSymbol(value) {
    return _typeof(value) == 'symbol' || isObjectLike(value) && baseGetTag(value) == symbolTag$3;
  }

  /** Used to match property names within property paths. */

  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
      reIsPlainProp = /^\w*$/;
  /**
   * Checks if `value` is a property name and not a property path.
   *
   * @private
   * @param {*} value The value to check.
   * @param {Object} [object] The object to query keys on.
   * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
   */

  function isKey(value, object) {
    if (isArray(value)) {
      return false;
    }

    var type = _typeof(value);

    if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol(value)) {
      return true;
    }

    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
  }

  /**
   * Checks if `value` is the
   * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
   * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an object, else `false`.
   * @example
   *
   * _.isObject({});
   * // => true
   *
   * _.isObject([1, 2, 3]);
   * // => true
   *
   * _.isObject(_.noop);
   * // => true
   *
   * _.isObject(null);
   * // => false
   */
  function isObject$2(value) {
    var type = _typeof(value);

    return value != null && (type == 'object' || type == 'function');
  }

  /** `Object#toString` result references. */

  var asyncTag = '[object AsyncFunction]',
      funcTag$2 = '[object Function]',
      genTag$1 = '[object GeneratorFunction]',
      proxyTag = '[object Proxy]';
  /**
   * Checks if `value` is classified as a `Function` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a function, else `false`.
   * @example
   *
   * _.isFunction(_);
   * // => true
   *
   * _.isFunction(/abc/);
   * // => false
   */

  function isFunction(value) {
    if (!isObject$2(value)) {
      return false;
    } // The use of `Object#toString` avoids issues with the `typeof` operator
    // in Safari 9 which returns 'object' for typed arrays and other constructors.


    var tag = baseGetTag(value);
    return tag == funcTag$2 || tag == genTag$1 || tag == asyncTag || tag == proxyTag;
  }

  /** Used to detect overreaching core-js shims. */

  var coreJsData = root['__core-js_shared__'];

  /** Used to detect methods masquerading as native. */

  var maskSrcKey = function () {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
    return uid ? 'Symbol(src)_1.' + uid : '';
  }();
  /**
   * Checks if `func` has its source masked.
   *
   * @private
   * @param {Function} func The function to check.
   * @returns {boolean} Returns `true` if `func` is masked, else `false`.
   */


  function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }

  /** Used for built-in method references. */
  var funcProto$1 = Function.prototype;
  /** Used to resolve the decompiled source of functions. */

  var funcToString$1 = funcProto$1.toString;
  /**
   * Converts `func` to its source code.
   *
   * @private
   * @param {Function} func The function to convert.
   * @returns {string} Returns the source code.
   */

  function toSource(func) {
    if (func != null) {
      try {
        return funcToString$1.call(func);
      } catch (e) {}

      try {
        return func + '';
      } catch (e) {}
    }

    return '';
  }

  /**
   * Used to match `RegExp`
   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
   */

  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
  /** Used to detect host constructors (Safari). */

  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  /** Used for built-in method references. */

  var funcProto = Function.prototype,
      objectProto$c = Object.prototype;
  /** Used to resolve the decompiled source of functions. */

  var funcToString = funcProto.toString;
  /** Used to check objects for own properties. */

  var hasOwnProperty$a = objectProto$c.hasOwnProperty;
  /** Used to detect if a method is native. */

  var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty$a).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
  /**
   * The base implementation of `_.isNative` without bad shim checks.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a native function,
   *  else `false`.
   */

  function baseIsNative(value) {
    if (!isObject$2(value) || isMasked(value)) {
      return false;
    }

    var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
  }

  /**
   * Gets the value at `key` of `object`.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */
  function getValue(object, key) {
    return object == null ? undefined : object[key];
  }

  /**
   * Gets the native function at `key` of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {string} key The key of the method to get.
   * @returns {*} Returns the function if it's native, else `undefined`.
   */

  function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : undefined;
  }

  /* Built-in method references that are verified to be native. */

  var nativeCreate = getNative(Object, 'create');

  /**
   * Removes all key-value entries from the hash.
   *
   * @private
   * @name clear
   * @memberOf Hash
   */

  function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
    this.size = 0;
  }

  /**
   * Removes `key` and its value from the hash.
   *
   * @private
   * @name delete
   * @memberOf Hash
   * @param {Object} hash The hash to modify.
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function hashDelete(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
  }

  /** Used to stand-in for `undefined` hash values. */

  var HASH_UNDEFINED$2 = '__lodash_hash_undefined__';
  /** Used for built-in method references. */

  var objectProto$b = Object.prototype;
  /** Used to check objects for own properties. */

  var hasOwnProperty$9 = objectProto$b.hasOwnProperty;
  /**
   * Gets the hash value for `key`.
   *
   * @private
   * @name get
   * @memberOf Hash
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */

  function hashGet(key) {
    var data = this.__data__;

    if (nativeCreate) {
      var result = data[key];
      return result === HASH_UNDEFINED$2 ? undefined : result;
    }

    return hasOwnProperty$9.call(data, key) ? data[key] : undefined;
  }

  /** Used for built-in method references. */

  var objectProto$a = Object.prototype;
  /** Used to check objects for own properties. */

  var hasOwnProperty$8 = objectProto$a.hasOwnProperty;
  /**
   * Checks if a hash value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf Hash
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */

  function hashHas(key) {
    var data = this.__data__;
    return nativeCreate ? data[key] !== undefined : hasOwnProperty$8.call(data, key);
  }

  /** Used to stand-in for `undefined` hash values. */

  var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';
  /**
   * Sets the hash `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf Hash
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the hash instance.
   */

  function hashSet(key, value) {
    var data = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED$1 : value;
    return this;
  }

  /**
   * Creates a hash object.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */

  function Hash(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;
    this.clear();

    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  } // Add methods to `Hash`.


  Hash.prototype.clear = hashClear;
  Hash.prototype['delete'] = hashDelete;
  Hash.prototype.get = hashGet;
  Hash.prototype.has = hashHas;
  Hash.prototype.set = hashSet;

  /**
   * Removes all key-value entries from the list cache.
   *
   * @private
   * @name clear
   * @memberOf ListCache
   */
  function listCacheClear() {
    this.__data__ = [];
    this.size = 0;
  }

  /**
   * Performs a
   * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * comparison between two values to determine if they are equivalent.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
   * @example
   *
   * var object = { 'a': 1 };
   * var other = { 'a': 1 };
   *
   * _.eq(object, object);
   * // => true
   *
   * _.eq(object, other);
   * // => false
   *
   * _.eq('a', 'a');
   * // => true
   *
   * _.eq('a', Object('a'));
   * // => false
   *
   * _.eq(NaN, NaN);
   * // => true
   */
  function eq(value, other) {
    return value === other || value !== value && other !== other;
  }

  /**
   * Gets the index at which the `key` is found in `array` of key-value pairs.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} key The key to search for.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */

  function assocIndexOf(array, key) {
    var length = array.length;

    while (length--) {
      if (eq(array[length][0], key)) {
        return length;
      }
    }

    return -1;
  }

  /** Used for built-in method references. */

  var arrayProto = Array.prototype;
  /** Built-in value references. */

  var splice = arrayProto.splice;
  /**
   * Removes `key` and its value from the list cache.
   *
   * @private
   * @name delete
   * @memberOf ListCache
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */

  function listCacheDelete(key) {
    var data = this.__data__,
        index = assocIndexOf(data, key);

    if (index < 0) {
      return false;
    }

    var lastIndex = data.length - 1;

    if (index == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index, 1);
    }

    --this.size;
    return true;
  }

  /**
   * Gets the list cache value for `key`.
   *
   * @private
   * @name get
   * @memberOf ListCache
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */

  function listCacheGet(key) {
    var data = this.__data__,
        index = assocIndexOf(data, key);
    return index < 0 ? undefined : data[index][1];
  }

  /**
   * Checks if a list cache value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf ListCache
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */

  function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
  }

  /**
   * Sets the list cache `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf ListCache
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the list cache instance.
   */

  function listCacheSet(key, value) {
    var data = this.__data__,
        index = assocIndexOf(data, key);

    if (index < 0) {
      ++this.size;
      data.push([key, value]);
    } else {
      data[index][1] = value;
    }

    return this;
  }

  /**
   * Creates an list cache object.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */

  function ListCache(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;
    this.clear();

    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  } // Add methods to `ListCache`.


  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype['delete'] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;

  /* Built-in method references that are verified to be native. */

  var Map$1 = getNative(root, 'Map');

  /**
   * Removes all key-value entries from the map.
   *
   * @private
   * @name clear
   * @memberOf MapCache
   */

  function mapCacheClear() {
    this.size = 0;
    this.__data__ = {
      'hash': new Hash(),
      'map': new (Map$1 || ListCache)(),
      'string': new Hash()
    };
  }

  /**
   * Checks if `value` is suitable for use as unique object key.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
   */
  function isKeyable(value) {
    var type = _typeof(value);

    return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
  }

  /**
   * Gets the data for `map`.
   *
   * @private
   * @param {Object} map The map to query.
   * @param {string} key The reference key.
   * @returns {*} Returns the map data.
   */

  function getMapData(map, key) {
    var data = map.__data__;
    return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
  }

  /**
   * Removes `key` and its value from the map.
   *
   * @private
   * @name delete
   * @memberOf MapCache
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */

  function mapCacheDelete(key) {
    var result = getMapData(this, key)['delete'](key);
    this.size -= result ? 1 : 0;
    return result;
  }

  /**
   * Gets the map value for `key`.
   *
   * @private
   * @name get
   * @memberOf MapCache
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */

  function mapCacheGet(key) {
    return getMapData(this, key).get(key);
  }

  /**
   * Checks if a map value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf MapCache
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */

  function mapCacheHas(key) {
    return getMapData(this, key).has(key);
  }

  /**
   * Sets the map `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf MapCache
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the map cache instance.
   */

  function mapCacheSet(key, value) {
    var data = getMapData(this, key),
        size = data.size;
    data.set(key, value);
    this.size += data.size == size ? 0 : 1;
    return this;
  }

  /**
   * Creates a map cache object to store key-value pairs.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */

  function MapCache(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;
    this.clear();

    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  } // Add methods to `MapCache`.


  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype['delete'] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;

  /** Error message constants. */

  var FUNC_ERROR_TEXT = 'Expected a function';
  /**
   * Creates a function that memoizes the result of `func`. If `resolver` is
   * provided, it determines the cache key for storing the result based on the
   * arguments provided to the memoized function. By default, the first argument
   * provided to the memoized function is used as the map cache key. The `func`
   * is invoked with the `this` binding of the memoized function.
   *
   * **Note:** The cache is exposed as the `cache` property on the memoized
   * function. Its creation may be customized by replacing the `_.memoize.Cache`
   * constructor with one whose instances implement the
   * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
   * method interface of `clear`, `delete`, `get`, `has`, and `set`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Function
   * @param {Function} func The function to have its output memoized.
   * @param {Function} [resolver] The function to resolve the cache key.
   * @returns {Function} Returns the new memoized function.
   * @example
   *
   * var object = { 'a': 1, 'b': 2 };
   * var other = { 'c': 3, 'd': 4 };
   *
   * var values = _.memoize(_.values);
   * values(object);
   * // => [1, 2]
   *
   * values(other);
   * // => [3, 4]
   *
   * object.a = 2;
   * values(object);
   * // => [1, 2]
   *
   * // Modify the result cache.
   * values.cache.set(object, ['a', 'b']);
   * values(object);
   * // => ['a', 'b']
   *
   * // Replace `_.memoize.Cache`.
   * _.memoize.Cache = WeakMap;
   */

  function memoize(func, resolver) {
    if (typeof func != 'function' || resolver != null && typeof resolver != 'function') {
      throw new TypeError(FUNC_ERROR_TEXT);
    }

    var memoized = function memoized() {
      var args = arguments,
          key = resolver ? resolver.apply(this, args) : args[0],
          cache = memoized.cache;

      if (cache.has(key)) {
        return cache.get(key);
      }

      var result = func.apply(this, args);
      memoized.cache = cache.set(key, result) || cache;
      return result;
    };

    memoized.cache = new (memoize.Cache || MapCache)();
    return memoized;
  } // Expose `MapCache`.


  memoize.Cache = MapCache;

  /** Used as the maximum memoize cache size. */

  var MAX_MEMOIZE_SIZE = 500;
  /**
   * A specialized version of `_.memoize` which clears the memoized function's
   * cache when it exceeds `MAX_MEMOIZE_SIZE`.
   *
   * @private
   * @param {Function} func The function to have its output memoized.
   * @returns {Function} Returns the new memoized function.
   */

  function memoizeCapped(func) {
    var result = memoize(func, function (key) {
      if (cache.size === MAX_MEMOIZE_SIZE) {
        cache.clear();
      }

      return key;
    });
    var cache = result.cache;
    return result;
  }

  /** Used to match property names within property paths. */

  var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
  /** Used to match backslashes in property paths. */

  var reEscapeChar = /\\(\\)?/g;
  /**
   * Converts `string` to a property path array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the property path array.
   */

  var stringToPath = memoizeCapped(function (string) {
    var result = [];

    if (string.charCodeAt(0) === 46
    /* . */
    ) {
        result.push('');
      }

    string.replace(rePropName, function (match, number, quote, subString) {
      result.push(quote ? subString.replace(reEscapeChar, '$1') : number || match);
    });
    return result;
  });

  /**
   * A specialized version of `_.map` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the new mapped array.
   */
  function arrayMap(array, iteratee) {
    var index = -1,
        length = array == null ? 0 : array.length,
        result = Array(length);

    while (++index < length) {
      result[index] = iteratee(array[index], index, array);
    }

    return result;
  }

  /** Used as references for various `Number` constants. */

  var INFINITY$1 = 1 / 0;
  /** Used to convert symbols to primitives and strings. */

  var symbolProto$2 = _Symbol ? _Symbol.prototype : undefined,
      symbolToString$1 = symbolProto$2 ? symbolProto$2.toString : undefined;
  /**
   * The base implementation of `_.toString` which doesn't convert nullish
   * values to empty strings.
   *
   * @private
   * @param {*} value The value to process.
   * @returns {string} Returns the string.
   */

  function baseToString(value) {
    // Exit early for strings to avoid a performance hit in some environments.
    if (typeof value == 'string') {
      return value;
    }

    if (isArray(value)) {
      // Recursively convert values (susceptible to call stack limits).
      return arrayMap(value, baseToString) + '';
    }

    if (isSymbol(value)) {
      return symbolToString$1 ? symbolToString$1.call(value) : '';
    }

    var result = value + '';
    return result == '0' && 1 / value == -INFINITY$1 ? '-0' : result;
  }

  /**
   * Converts `value` to a string. An empty string is returned for `null`
   * and `undefined` values. The sign of `-0` is preserved.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to convert.
   * @returns {string} Returns the converted string.
   * @example
   *
   * _.toString(null);
   * // => ''
   *
   * _.toString(-0);
   * // => '-0'
   *
   * _.toString([1, 2, 3]);
   * // => '1,2,3'
   */

  function toString$1(value) {
    return value == null ? '' : baseToString(value);
  }

  /**
   * Casts `value` to a path array if it's not one.
   *
   * @private
   * @param {*} value The value to inspect.
   * @param {Object} [object] The object to query keys on.
   * @returns {Array} Returns the cast property path array.
   */

  function castPath(value, object) {
    if (isArray(value)) {
      return value;
    }

    return isKey(value, object) ? [value] : stringToPath(toString$1(value));
  }

  /** `Object#toString` result references. */

  var argsTag$3 = '[object Arguments]';
  /**
   * The base implementation of `_.isArguments`.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an `arguments` object,
   */

  function baseIsArguments(value) {
    return isObjectLike(value) && baseGetTag(value) == argsTag$3;
  }

  /** Used for built-in method references. */

  var objectProto$9 = Object.prototype;
  /** Used to check objects for own properties. */

  var hasOwnProperty$7 = objectProto$9.hasOwnProperty;
  /** Built-in value references. */

  var propertyIsEnumerable$1 = objectProto$9.propertyIsEnumerable;
  /**
   * Checks if `value` is likely an `arguments` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an `arguments` object,
   *  else `false`.
   * @example
   *
   * _.isArguments(function() { return arguments; }());
   * // => true
   *
   * _.isArguments([1, 2, 3]);
   * // => false
   */

  var isArguments = baseIsArguments(function () {
    return arguments;
  }()) ? baseIsArguments : function (value) {
    return isObjectLike(value) && hasOwnProperty$7.call(value, 'callee') && !propertyIsEnumerable$1.call(value, 'callee');
  };

  /** Used as references for various `Number` constants. */
  var MAX_SAFE_INTEGER$1 = 9007199254740991;
  /** Used to detect unsigned integer values. */

  var reIsUint = /^(?:0|[1-9]\d*)$/;
  /**
   * Checks if `value` is a valid array-like index.
   *
   * @private
   * @param {*} value The value to check.
   * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
   * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
   */

  function isIndex(value, length) {
    var type = _typeof(value);

    length = length == null ? MAX_SAFE_INTEGER$1 : length;
    return !!length && (type == 'number' || type != 'symbol' && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
  }

  /** Used as references for various `Number` constants. */
  var MAX_SAFE_INTEGER = 9007199254740991;
  /**
   * Checks if `value` is a valid array-like length.
   *
   * **Note:** This method is loosely based on
   * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
   * @example
   *
   * _.isLength(3);
   * // => true
   *
   * _.isLength(Number.MIN_VALUE);
   * // => false
   *
   * _.isLength(Infinity);
   * // => false
   *
   * _.isLength('3');
   * // => false
   */

  function isLength(value) {
    return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }

  /** Used as references for various `Number` constants. */

  var INFINITY = 1 / 0;
  /**
   * Converts `value` to a string key if it's not a string or symbol.
   *
   * @private
   * @param {*} value The value to inspect.
   * @returns {string|symbol} Returns the key.
   */

  function toKey(value) {
    if (typeof value == 'string' || isSymbol(value)) {
      return value;
    }

    var result = value + '';
    return result == '0' && 1 / value == -INFINITY ? '-0' : result;
  }

  /**
   * Checks if `path` exists on `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array|string} path The path to check.
   * @param {Function} hasFunc The function to check properties.
   * @returns {boolean} Returns `true` if `path` exists, else `false`.
   */

  function hasPath(object, path, hasFunc) {
    path = castPath(path, object);
    var index = -1,
        length = path.length,
        result = false;

    while (++index < length) {
      var key = toKey(path[index]);

      if (!(result = object != null && hasFunc(object, key))) {
        break;
      }

      object = object[key];
    }

    if (result || ++index != length) {
      return result;
    }

    length = object == null ? 0 : object.length;
    return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
  }

  /**
   * Checks if `path` is a direct property of `object`.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Object
   * @param {Object} object The object to query.
   * @param {Array|string} path The path to check.
   * @returns {boolean} Returns `true` if `path` exists, else `false`.
   * @example
   *
   * var object = { 'a': { 'b': 2 } };
   * var other = _.create({ 'a': _.create({ 'b': 2 }) });
   *
   * _.has(object, 'a');
   * // => true
   *
   * _.has(object, 'a.b');
   * // => true
   *
   * _.has(object, ['a', 'b']);
   * // => true
   *
   * _.has(other, 'a');
   * // => false
   */

  function has(object, path) {
    return object != null && hasPath(object, path, baseHas);
  }

  /**
   * Removes all key-value entries from the stack.
   *
   * @private
   * @name clear
   * @memberOf Stack
   */

  function stackClear() {
    this.__data__ = new ListCache();
    this.size = 0;
  }

  /**
   * Removes `key` and its value from the stack.
   *
   * @private
   * @name delete
   * @memberOf Stack
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function stackDelete(key) {
    var data = this.__data__,
        result = data['delete'](key);
    this.size = data.size;
    return result;
  }

  /**
   * Gets the stack value for `key`.
   *
   * @private
   * @name get
   * @memberOf Stack
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function stackGet(key) {
    return this.__data__.get(key);
  }

  /**
   * Checks if a stack value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf Stack
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function stackHas(key) {
    return this.__data__.has(key);
  }

  /** Used as the size to enable large array optimizations. */

  var LARGE_ARRAY_SIZE = 200;
  /**
   * Sets the stack `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf Stack
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the stack cache instance.
   */

  function stackSet(key, value) {
    var data = this.__data__;

    if (data instanceof ListCache) {
      var pairs = data.__data__;

      if (!Map$1 || pairs.length < LARGE_ARRAY_SIZE - 1) {
        pairs.push([key, value]);
        this.size = ++data.size;
        return this;
      }

      data = this.__data__ = new MapCache(pairs);
    }

    data.set(key, value);
    this.size = data.size;
    return this;
  }

  /**
   * Creates a stack cache object to store key-value pairs.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */

  function Stack(entries) {
    var data = this.__data__ = new ListCache(entries);
    this.size = data.size;
  } // Add methods to `Stack`.


  Stack.prototype.clear = stackClear;
  Stack.prototype['delete'] = stackDelete;
  Stack.prototype.get = stackGet;
  Stack.prototype.has = stackHas;
  Stack.prototype.set = stackSet;

  /**
   * A specialized version of `_.forEach` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */
  function arrayEach(array, iteratee) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (iteratee(array[index], index, array) === false) {
        break;
      }
    }

    return array;
  }

  var defineProperty = function () {
    try {
      var func = getNative(Object, 'defineProperty');
      func({}, '', {});
      return func;
    } catch (e) {}
  }();

  /**
   * The base implementation of `assignValue` and `assignMergeValue` without
   * value checks.
   *
   * @private
   * @param {Object} object The object to modify.
   * @param {string} key The key of the property to assign.
   * @param {*} value The value to assign.
   */

  function baseAssignValue(object, key, value) {
    if (key == '__proto__' && defineProperty) {
      defineProperty(object, key, {
        'configurable': true,
        'enumerable': true,
        'value': value,
        'writable': true
      });
    } else {
      object[key] = value;
    }
  }

  /** Used for built-in method references. */

  var objectProto$8 = Object.prototype;
  /** Used to check objects for own properties. */

  var hasOwnProperty$6 = objectProto$8.hasOwnProperty;
  /**
   * Assigns `value` to `key` of `object` if the existing value is not equivalent
   * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * for equality comparisons.
   *
   * @private
   * @param {Object} object The object to modify.
   * @param {string} key The key of the property to assign.
   * @param {*} value The value to assign.
   */

  function assignValue(object, key, value) {
    var objValue = object[key];

    if (!(hasOwnProperty$6.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) {
      baseAssignValue(object, key, value);
    }
  }

  /**
   * Copies properties of `source` to `object`.
   *
   * @private
   * @param {Object} source The object to copy properties from.
   * @param {Array} props The property identifiers to copy.
   * @param {Object} [object={}] The object to copy properties to.
   * @param {Function} [customizer] The function to customize copied values.
   * @returns {Object} Returns `object`.
   */

  function copyObject(source, props, object, customizer) {
    var isNew = !object;
    object || (object = {});
    var index = -1,
        length = props.length;

    while (++index < length) {
      var key = props[index];
      var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;

      if (newValue === undefined) {
        newValue = source[key];
      }

      if (isNew) {
        baseAssignValue(object, key, newValue);
      } else {
        assignValue(object, key, newValue);
      }
    }

    return object;
  }

  /**
   * The base implementation of `_.times` without support for iteratee shorthands
   * or max array length checks.
   *
   * @private
   * @param {number} n The number of times to invoke `iteratee`.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the array of results.
   */
  function baseTimes(n, iteratee) {
    var index = -1,
        result = Array(n);

    while (++index < n) {
      result[index] = iteratee(index);
    }

    return result;
  }

  /**
   * This method returns `false`.
   *
   * @static
   * @memberOf _
   * @since 4.13.0
   * @category Util
   * @returns {boolean} Returns `false`.
   * @example
   *
   * _.times(2, _.stubFalse);
   * // => [false, false]
   */
  function stubFalse() {
    return false;
  }

  /** Detect free variable `exports`. */

  var freeExports$2 = (typeof exports === "undefined" ? "undefined" : _typeof(exports)) == 'object' && exports && !exports.nodeType && exports;
  /** Detect free variable `module`. */

  var freeModule$2 = freeExports$2 && (typeof module === "undefined" ? "undefined" : _typeof(module)) == 'object' && module && !module.nodeType && module;
  /** Detect the popular CommonJS extension `module.exports`. */

  var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;
  /** Built-in value references. */

  var Buffer$2 = moduleExports$2 ? root.Buffer : undefined;
  /* Built-in method references for those with the same name as other `lodash` methods. */

  var nativeIsBuffer = Buffer$2 ? Buffer$2.isBuffer : undefined;
  /**
   * Checks if `value` is a buffer.
   *
   * @static
   * @memberOf _
   * @since 4.3.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
   * @example
   *
   * _.isBuffer(new Buffer(2));
   * // => true
   *
   * _.isBuffer(new Uint8Array(2));
   * // => false
   */

  var isBuffer = nativeIsBuffer || stubFalse;

  /** `Object#toString` result references. */

  var argsTag$2 = '[object Arguments]',
      arrayTag$2 = '[object Array]',
      boolTag$3 = '[object Boolean]',
      dateTag$3 = '[object Date]',
      errorTag$2 = '[object Error]',
      funcTag$1 = '[object Function]',
      mapTag$6 = '[object Map]',
      numberTag$3 = '[object Number]',
      objectTag$3 = '[object Object]',
      regexpTag$3 = '[object RegExp]',
      setTag$6 = '[object Set]',
      stringTag$4 = '[object String]',
      weakMapTag$2 = '[object WeakMap]';
  var arrayBufferTag$3 = '[object ArrayBuffer]',
      dataViewTag$4 = '[object DataView]',
      float32Tag$2 = '[object Float32Array]',
      float64Tag$2 = '[object Float64Array]',
      int8Tag$2 = '[object Int8Array]',
      int16Tag$2 = '[object Int16Array]',
      int32Tag$2 = '[object Int32Array]',
      uint8Tag$2 = '[object Uint8Array]',
      uint8ClampedTag$2 = '[object Uint8ClampedArray]',
      uint16Tag$2 = '[object Uint16Array]',
      uint32Tag$2 = '[object Uint32Array]';
  /** Used to identify `toStringTag` values of typed arrays. */

  var typedArrayTags = {};
  typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] = typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] = typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] = typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] = typedArrayTags[uint32Tag$2] = true;
  typedArrayTags[argsTag$2] = typedArrayTags[arrayTag$2] = typedArrayTags[arrayBufferTag$3] = typedArrayTags[boolTag$3] = typedArrayTags[dataViewTag$4] = typedArrayTags[dateTag$3] = typedArrayTags[errorTag$2] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag$6] = typedArrayTags[numberTag$3] = typedArrayTags[objectTag$3] = typedArrayTags[regexpTag$3] = typedArrayTags[setTag$6] = typedArrayTags[stringTag$4] = typedArrayTags[weakMapTag$2] = false;
  /**
   * The base implementation of `_.isTypedArray` without Node.js optimizations.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
   */

  function baseIsTypedArray(value) {
    return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
  }

  /**
   * The base implementation of `_.unary` without support for storing metadata.
   *
   * @private
   * @param {Function} func The function to cap arguments for.
   * @returns {Function} Returns the new capped function.
   */
  function baseUnary(func) {
    return function (value) {
      return func(value);
    };
  }

  /** Detect free variable `exports`. */

  var freeExports$1 = (typeof exports === "undefined" ? "undefined" : _typeof(exports)) == 'object' && exports && !exports.nodeType && exports;
  /** Detect free variable `module`. */

  var freeModule$1 = freeExports$1 && (typeof module === "undefined" ? "undefined" : _typeof(module)) == 'object' && module && !module.nodeType && module;
  /** Detect the popular CommonJS extension `module.exports`. */

  var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
  /** Detect free variable `process` from Node.js. */

  var freeProcess = moduleExports$1 && freeGlobal.process;
  /** Used to access faster Node.js helpers. */

  var nodeUtil = function () {
    try {
      // Use `util.types` for Node.js 10+.
      var types = freeModule$1 && freeModule$1.require && freeModule$1.require('util').types;

      if (types) {
        return types;
      } // Legacy `process.binding('util')` for Node.js < 10.


      return freeProcess && freeProcess.binding && freeProcess.binding('util');
    } catch (e) {}
  }();

  /* Node.js helper references. */

  var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
  /**
   * Checks if `value` is classified as a typed array.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
   * @example
   *
   * _.isTypedArray(new Uint8Array);
   * // => true
   *
   * _.isTypedArray([]);
   * // => false
   */

  var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

  /** Used for built-in method references. */

  var objectProto$7 = Object.prototype;
  /** Used to check objects for own properties. */

  var hasOwnProperty$5 = objectProto$7.hasOwnProperty;
  /**
   * Creates an array of the enumerable property names of the array-like `value`.
   *
   * @private
   * @param {*} value The value to query.
   * @param {boolean} inherited Specify returning inherited property names.
   * @returns {Array} Returns the array of property names.
   */

  function arrayLikeKeys(value, inherited) {
    var isArr = isArray(value),
        isArg = !isArr && isArguments(value),
        isBuff = !isArr && !isArg && isBuffer(value),
        isType = !isArr && !isArg && !isBuff && isTypedArray(value),
        skipIndexes = isArr || isArg || isBuff || isType,
        result = skipIndexes ? baseTimes(value.length, String) : [],
        length = result.length;

    for (var key in value) {
      if ((inherited || hasOwnProperty$5.call(value, key)) && !(skipIndexes && ( // Safari 9 has enumerable `arguments.length` in strict mode.
      key == 'length' || // Node.js 0.10 has enumerable non-index properties on buffers.
      isBuff && (key == 'offset' || key == 'parent') || // PhantomJS 2 has enumerable non-index properties on typed arrays.
      isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') || // Skip index properties.
      isIndex(key, length)))) {
        result.push(key);
      }
    }

    return result;
  }

  /** Used for built-in method references. */
  var objectProto$6 = Object.prototype;
  /**
   * Checks if `value` is likely a prototype object.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
   */

  function isPrototype(value) {
    var Ctor = value && value.constructor,
        proto = typeof Ctor == 'function' && Ctor.prototype || objectProto$6;
    return value === proto;
  }

  /**
   * Creates a unary function that invokes `func` with its argument transformed.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {Function} transform The argument transform.
   * @returns {Function} Returns the new function.
   */
  function overArg(func, transform) {
    return function (arg) {
      return func(transform(arg));
    };
  }

  /* Built-in method references for those with the same name as other `lodash` methods. */

  var nativeKeys = overArg(Object.keys, Object);

  /** Used for built-in method references. */

  var objectProto$5 = Object.prototype;
  /** Used to check objects for own properties. */

  var hasOwnProperty$4 = objectProto$5.hasOwnProperty;
  /**
   * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   */

  function baseKeys(object) {
    if (!isPrototype(object)) {
      return nativeKeys(object);
    }

    var result = [];

    for (var key in Object(object)) {
      if (hasOwnProperty$4.call(object, key) && key != 'constructor') {
        result.push(key);
      }
    }

    return result;
  }

  /**
   * Checks if `value` is array-like. A value is considered array-like if it's
   * not a function and has a `value.length` that's an integer greater than or
   * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
   * @example
   *
   * _.isArrayLike([1, 2, 3]);
   * // => true
   *
   * _.isArrayLike(document.body.children);
   * // => true
   *
   * _.isArrayLike('abc');
   * // => true
   *
   * _.isArrayLike(_.noop);
   * // => false
   */

  function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
  }

  /**
   * Creates an array of the own enumerable property names of `object`.
   *
   * **Note:** Non-object values are coerced to objects. See the
   * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
   * for more details.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Object
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   *   this.b = 2;
   * }
   *
   * Foo.prototype.c = 3;
   *
   * _.keys(new Foo);
   * // => ['a', 'b'] (iteration order is not guaranteed)
   *
   * _.keys('hi');
   * // => ['0', '1']
   */

  function keys(object) {
    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
  }

  /**
   * The base implementation of `_.assign` without support for multiple sources
   * or `customizer` functions.
   *
   * @private
   * @param {Object} object The destination object.
   * @param {Object} source The source object.
   * @returns {Object} Returns `object`.
   */

  function baseAssign(object, source) {
    return object && copyObject(source, keys(source), object);
  }

  /**
   * This function is like
   * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
   * except that it includes inherited enumerable properties.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   */
  function nativeKeysIn(object) {
    var result = [];

    if (object != null) {
      for (var key in Object(object)) {
        result.push(key);
      }
    }

    return result;
  }

  /** Used for built-in method references. */

  var objectProto$4 = Object.prototype;
  /** Used to check objects for own properties. */

  var hasOwnProperty$3 = objectProto$4.hasOwnProperty;
  /**
   * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   */

  function baseKeysIn(object) {
    if (!isObject$2(object)) {
      return nativeKeysIn(object);
    }

    var isProto = isPrototype(object),
        result = [];

    for (var key in object) {
      if (!(key == 'constructor' && (isProto || !hasOwnProperty$3.call(object, key)))) {
        result.push(key);
      }
    }

    return result;
  }

  /**
   * Creates an array of the own and inherited enumerable property names of `object`.
   *
   * **Note:** Non-object values are coerced to objects.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Object
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   *   this.b = 2;
   * }
   *
   * Foo.prototype.c = 3;
   *
   * _.keysIn(new Foo);
   * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
   */

  function keysIn$1(object) {
    return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
  }

  /**
   * The base implementation of `_.assignIn` without support for multiple sources
   * or `customizer` functions.
   *
   * @private
   * @param {Object} object The destination object.
   * @param {Object} source The source object.
   * @returns {Object} Returns `object`.
   */

  function baseAssignIn(object, source) {
    return object && copyObject(source, keysIn$1(source), object);
  }

  /** Detect free variable `exports`. */

  var freeExports = (typeof exports === "undefined" ? "undefined" : _typeof(exports)) == 'object' && exports && !exports.nodeType && exports;
  /** Detect free variable `module`. */

  var freeModule = freeExports && (typeof module === "undefined" ? "undefined" : _typeof(module)) == 'object' && module && !module.nodeType && module;
  /** Detect the popular CommonJS extension `module.exports`. */

  var moduleExports = freeModule && freeModule.exports === freeExports;
  /** Built-in value references. */

  var Buffer$1 = moduleExports ? root.Buffer : undefined,
      allocUnsafe = Buffer$1 ? Buffer$1.allocUnsafe : undefined;
  /**
   * Creates a clone of  `buffer`.
   *
   * @private
   * @param {Buffer} buffer The buffer to clone.
   * @param {boolean} [isDeep] Specify a deep clone.
   * @returns {Buffer} Returns the cloned buffer.
   */

  function cloneBuffer(buffer, isDeep) {
    if (isDeep) {
      return buffer.slice();
    }

    var length = buffer.length,
        result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
    buffer.copy(result);
    return result;
  }

  /**
   * Copies the values of `source` to `array`.
   *
   * @private
   * @param {Array} source The array to copy values from.
   * @param {Array} [array=[]] The array to copy values to.
   * @returns {Array} Returns `array`.
   */
  function copyArray(source, array) {
    var index = -1,
        length = source.length;
    array || (array = Array(length));

    while (++index < length) {
      array[index] = source[index];
    }

    return array;
  }

  /**
   * A specialized version of `_.filter` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {Array} Returns the new filtered array.
   */
  function arrayFilter(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length,
        resIndex = 0,
        result = [];

    while (++index < length) {
      var value = array[index];

      if (predicate(value, index, array)) {
        result[resIndex++] = value;
      }
    }

    return result;
  }

  /**
   * This method returns a new empty array.
   *
   * @static
   * @memberOf _
   * @since 4.13.0
   * @category Util
   * @returns {Array} Returns the new empty array.
   * @example
   *
   * var arrays = _.times(2, _.stubArray);
   *
   * console.log(arrays);
   * // => [[], []]
   *
   * console.log(arrays[0] === arrays[1]);
   * // => false
   */
  function stubArray() {
    return [];
  }

  /** Used for built-in method references. */

  var objectProto$3 = Object.prototype;
  /** Built-in value references. */

  var propertyIsEnumerable = objectProto$3.propertyIsEnumerable;
  /* Built-in method references for those with the same name as other `lodash` methods. */

  var nativeGetSymbols$1 = Object.getOwnPropertySymbols;
  /**
   * Creates an array of the own enumerable symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of symbols.
   */

  var getSymbols = !nativeGetSymbols$1 ? stubArray : function (object) {
    if (object == null) {
      return [];
    }

    object = Object(object);
    return arrayFilter(nativeGetSymbols$1(object), function (symbol) {
      return propertyIsEnumerable.call(object, symbol);
    });
  };

  /**
   * Copies own symbols of `source` to `object`.
   *
   * @private
   * @param {Object} source The object to copy symbols from.
   * @param {Object} [object={}] The object to copy symbols to.
   * @returns {Object} Returns `object`.
   */

  function copySymbols(source, object) {
    return copyObject(source, getSymbols(source), object);
  }

  /**
   * Appends the elements of `values` to `array`.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {Array} values The values to append.
   * @returns {Array} Returns `array`.
   */
  function arrayPush(array, values) {
    var index = -1,
        length = values.length,
        offset = array.length;

    while (++index < length) {
      array[offset + index] = values[index];
    }

    return array;
  }

  /** Built-in value references. */

  var getPrototype = overArg(Object.getPrototypeOf, Object);

  /* Built-in method references for those with the same name as other `lodash` methods. */

  var nativeGetSymbols = Object.getOwnPropertySymbols;
  /**
   * Creates an array of the own and inherited enumerable symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of symbols.
   */

  var getSymbolsIn = !nativeGetSymbols ? stubArray : function (object) {
    var result = [];

    while (object) {
      arrayPush(result, getSymbols(object));
      object = getPrototype(object);
    }

    return result;
  };

  /**
   * Copies own and inherited symbols of `source` to `object`.
   *
   * @private
   * @param {Object} source The object to copy symbols from.
   * @param {Object} [object={}] The object to copy symbols to.
   * @returns {Object} Returns `object`.
   */

  function copySymbolsIn(source, object) {
    return copyObject(source, getSymbolsIn(source), object);
  }

  /**
   * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
   * `keysFunc` and `symbolsFunc` to get the enumerable property names and
   * symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Function} keysFunc The function to get the keys of `object`.
   * @param {Function} symbolsFunc The function to get the symbols of `object`.
   * @returns {Array} Returns the array of property names and symbols.
   */

  function baseGetAllKeys(object, keysFunc, symbolsFunc) {
    var result = keysFunc(object);
    return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
  }

  /**
   * Creates an array of own enumerable property names and symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names and symbols.
   */

  function getAllKeys(object) {
    return baseGetAllKeys(object, keys, getSymbols);
  }

  /**
   * Creates an array of own and inherited enumerable property names and
   * symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names and symbols.
   */

  function getAllKeysIn(object) {
    return baseGetAllKeys(object, keysIn$1, getSymbolsIn);
  }

  /* Built-in method references that are verified to be native. */

  var DataView = getNative(root, 'DataView');

  /* Built-in method references that are verified to be native. */

  var Promise$1 = getNative(root, 'Promise');

  /* Built-in method references that are verified to be native. */

  var Set$1 = getNative(root, 'Set');

  /* Built-in method references that are verified to be native. */

  var WeakMap = getNative(root, 'WeakMap');

  /** `Object#toString` result references. */

  var mapTag$5 = '[object Map]',
      objectTag$2 = '[object Object]',
      promiseTag = '[object Promise]',
      setTag$5 = '[object Set]',
      weakMapTag$1 = '[object WeakMap]';
  var dataViewTag$3 = '[object DataView]';
  /** Used to detect maps, sets, and weakmaps. */

  var dataViewCtorString = toSource(DataView),
      mapCtorString = toSource(Map$1),
      promiseCtorString = toSource(Promise$1),
      setCtorString = toSource(Set$1),
      weakMapCtorString = toSource(WeakMap);
  /**
   * Gets the `toStringTag` of `value`.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the `toStringTag`.
   */

  var getTag = baseGetTag; // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.

  if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag$3 || Map$1 && getTag(new Map$1()) != mapTag$5 || Promise$1 && getTag(Promise$1.resolve()) != promiseTag || Set$1 && getTag(new Set$1()) != setTag$5 || WeakMap && getTag(new WeakMap()) != weakMapTag$1) {
    getTag = function getTag(value) {
      var result = baseGetTag(value),
          Ctor = result == objectTag$2 ? value.constructor : undefined,
          ctorString = Ctor ? toSource(Ctor) : '';

      if (ctorString) {
        switch (ctorString) {
          case dataViewCtorString:
            return dataViewTag$3;

          case mapCtorString:
            return mapTag$5;

          case promiseCtorString:
            return promiseTag;

          case setCtorString:
            return setTag$5;

          case weakMapCtorString:
            return weakMapTag$1;
        }
      }

      return result;
    };
  }

  var getTag$1 = getTag;

  /** Used for built-in method references. */
  var objectProto$2 = Object.prototype;
  /** Used to check objects for own properties. */

  var hasOwnProperty$2 = objectProto$2.hasOwnProperty;
  /**
   * Initializes an array clone.
   *
   * @private
   * @param {Array} array The array to clone.
   * @returns {Array} Returns the initialized clone.
   */

  function initCloneArray(array) {
    var length = array.length,
        result = new array.constructor(length); // Add properties assigned by `RegExp#exec`.

    if (length && typeof array[0] == 'string' && hasOwnProperty$2.call(array, 'index')) {
      result.index = array.index;
      result.input = array.input;
    }

    return result;
  }

  /** Built-in value references. */

  var Uint8Array = root.Uint8Array;

  /**
   * Creates a clone of `arrayBuffer`.
   *
   * @private
   * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
   * @returns {ArrayBuffer} Returns the cloned array buffer.
   */

  function cloneArrayBuffer(arrayBuffer) {
    var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
    new Uint8Array(result).set(new Uint8Array(arrayBuffer));
    return result;
  }

  /**
   * Creates a clone of `dataView`.
   *
   * @private
   * @param {Object} dataView The data view to clone.
   * @param {boolean} [isDeep] Specify a deep clone.
   * @returns {Object} Returns the cloned data view.
   */

  function cloneDataView(dataView, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
    return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
  }

  /** Used to match `RegExp` flags from their coerced string values. */
  var reFlags = /\w*$/;
  /**
   * Creates a clone of `regexp`.
   *
   * @private
   * @param {Object} regexp The regexp to clone.
   * @returns {Object} Returns the cloned regexp.
   */

  function cloneRegExp(regexp) {
    var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
    result.lastIndex = regexp.lastIndex;
    return result;
  }

  /** Used to convert symbols to primitives and strings. */

  var symbolProto$1 = _Symbol ? _Symbol.prototype : undefined,
      symbolValueOf$1 = symbolProto$1 ? symbolProto$1.valueOf : undefined;
  /**
   * Creates a clone of the `symbol` object.
   *
   * @private
   * @param {Object} symbol The symbol object to clone.
   * @returns {Object} Returns the cloned symbol object.
   */

  function cloneSymbol(symbol) {
    return symbolValueOf$1 ? Object(symbolValueOf$1.call(symbol)) : {};
  }

  /**
   * Creates a clone of `typedArray`.
   *
   * @private
   * @param {Object} typedArray The typed array to clone.
   * @param {boolean} [isDeep] Specify a deep clone.
   * @returns {Object} Returns the cloned typed array.
   */

  function cloneTypedArray(typedArray, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
  }

  /** `Object#toString` result references. */

  var boolTag$2 = '[object Boolean]',
      dateTag$2 = '[object Date]',
      mapTag$4 = '[object Map]',
      numberTag$2 = '[object Number]',
      regexpTag$2 = '[object RegExp]',
      setTag$4 = '[object Set]',
      stringTag$3 = '[object String]',
      symbolTag$2 = '[object Symbol]';
  var arrayBufferTag$2 = '[object ArrayBuffer]',
      dataViewTag$2 = '[object DataView]',
      float32Tag$1 = '[object Float32Array]',
      float64Tag$1 = '[object Float64Array]',
      int8Tag$1 = '[object Int8Array]',
      int16Tag$1 = '[object Int16Array]',
      int32Tag$1 = '[object Int32Array]',
      uint8Tag$1 = '[object Uint8Array]',
      uint8ClampedTag$1 = '[object Uint8ClampedArray]',
      uint16Tag$1 = '[object Uint16Array]',
      uint32Tag$1 = '[object Uint32Array]';
  /**
   * Initializes an object clone based on its `toStringTag`.
   *
   * **Note:** This function only supports cloning values with tags of
   * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
   *
   * @private
   * @param {Object} object The object to clone.
   * @param {string} tag The `toStringTag` of the object to clone.
   * @param {boolean} [isDeep] Specify a deep clone.
   * @returns {Object} Returns the initialized clone.
   */

  function initCloneByTag(object, tag, isDeep) {
    var Ctor = object.constructor;

    switch (tag) {
      case arrayBufferTag$2:
        return cloneArrayBuffer(object);

      case boolTag$2:
      case dateTag$2:
        return new Ctor(+object);

      case dataViewTag$2:
        return cloneDataView(object, isDeep);

      case float32Tag$1:
      case float64Tag$1:
      case int8Tag$1:
      case int16Tag$1:
      case int32Tag$1:
      case uint8Tag$1:
      case uint8ClampedTag$1:
      case uint16Tag$1:
      case uint32Tag$1:
        return cloneTypedArray(object, isDeep);

      case mapTag$4:
        return new Ctor();

      case numberTag$2:
      case stringTag$3:
        return new Ctor(object);

      case regexpTag$2:
        return cloneRegExp(object);

      case setTag$4:
        return new Ctor();

      case symbolTag$2:
        return cloneSymbol(object);
    }
  }

  /** Built-in value references. */

  var objectCreate = Object.create;
  /**
   * The base implementation of `_.create` without support for assigning
   * properties to the created object.
   *
   * @private
   * @param {Object} proto The object to inherit from.
   * @returns {Object} Returns the new object.
   */

  var baseCreate = function () {
    function object() {}

    return function (proto) {
      if (!isObject$2(proto)) {
        return {};
      }

      if (objectCreate) {
        return objectCreate(proto);
      }

      object.prototype = proto;
      var result = new object();
      object.prototype = undefined;
      return result;
    };
  }();

  /**
   * Initializes an object clone.
   *
   * @private
   * @param {Object} object The object to clone.
   * @returns {Object} Returns the initialized clone.
   */

  function initCloneObject(object) {
    return typeof object.constructor == 'function' && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
  }

  /** `Object#toString` result references. */

  var mapTag$3 = '[object Map]';
  /**
   * The base implementation of `_.isMap` without Node.js optimizations.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a map, else `false`.
   */

  function baseIsMap(value) {
    return isObjectLike(value) && getTag$1(value) == mapTag$3;
  }

  /* Node.js helper references. */

  var nodeIsMap = nodeUtil && nodeUtil.isMap;
  /**
   * Checks if `value` is classified as a `Map` object.
   *
   * @static
   * @memberOf _
   * @since 4.3.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a map, else `false`.
   * @example
   *
   * _.isMap(new Map);
   * // => true
   *
   * _.isMap(new WeakMap);
   * // => false
   */

  var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

  /** `Object#toString` result references. */

  var setTag$3 = '[object Set]';
  /**
   * The base implementation of `_.isSet` without Node.js optimizations.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a set, else `false`.
   */

  function baseIsSet(value) {
    return isObjectLike(value) && getTag$1(value) == setTag$3;
  }

  /* Node.js helper references. */

  var nodeIsSet = nodeUtil && nodeUtil.isSet;
  /**
   * Checks if `value` is classified as a `Set` object.
   *
   * @static
   * @memberOf _
   * @since 4.3.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a set, else `false`.
   * @example
   *
   * _.isSet(new Set);
   * // => true
   *
   * _.isSet(new WeakSet);
   * // => false
   */

  var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

  /** Used to compose bitmasks for cloning. */

  var CLONE_DEEP_FLAG$1 = 1,
      CLONE_FLAT_FLAG = 2,
      CLONE_SYMBOLS_FLAG$1 = 4;
  /** `Object#toString` result references. */

  var argsTag$1 = '[object Arguments]',
      arrayTag$1 = '[object Array]',
      boolTag$1 = '[object Boolean]',
      dateTag$1 = '[object Date]',
      errorTag$1 = '[object Error]',
      funcTag = '[object Function]',
      genTag = '[object GeneratorFunction]',
      mapTag$2 = '[object Map]',
      numberTag$1 = '[object Number]',
      objectTag$1 = '[object Object]',
      regexpTag$1 = '[object RegExp]',
      setTag$2 = '[object Set]',
      stringTag$2 = '[object String]',
      symbolTag$1 = '[object Symbol]',
      weakMapTag = '[object WeakMap]';
  var arrayBufferTag$1 = '[object ArrayBuffer]',
      dataViewTag$1 = '[object DataView]',
      float32Tag = '[object Float32Array]',
      float64Tag = '[object Float64Array]',
      int8Tag = '[object Int8Array]',
      int16Tag = '[object Int16Array]',
      int32Tag = '[object Int32Array]',
      uint8Tag = '[object Uint8Array]',
      uint8ClampedTag = '[object Uint8ClampedArray]',
      uint16Tag = '[object Uint16Array]',
      uint32Tag = '[object Uint32Array]';
  /** Used to identify `toStringTag` values supported by `_.clone`. */

  var cloneableTags = {};
  cloneableTags[argsTag$1] = cloneableTags[arrayTag$1] = cloneableTags[arrayBufferTag$1] = cloneableTags[dataViewTag$1] = cloneableTags[boolTag$1] = cloneableTags[dateTag$1] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag$2] = cloneableTags[numberTag$1] = cloneableTags[objectTag$1] = cloneableTags[regexpTag$1] = cloneableTags[setTag$2] = cloneableTags[stringTag$2] = cloneableTags[symbolTag$1] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
  cloneableTags[errorTag$1] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
  /**
   * The base implementation of `_.clone` and `_.cloneDeep` which tracks
   * traversed objects.
   *
   * @private
   * @param {*} value The value to clone.
   * @param {boolean} bitmask The bitmask flags.
   *  1 - Deep clone
   *  2 - Flatten inherited properties
   *  4 - Clone symbols
   * @param {Function} [customizer] The function to customize cloning.
   * @param {string} [key] The key of `value`.
   * @param {Object} [object] The parent object of `value`.
   * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
   * @returns {*} Returns the cloned value.
   */

  function baseClone(value, bitmask, customizer, key, object, stack) {
    var result,
        isDeep = bitmask & CLONE_DEEP_FLAG$1,
        isFlat = bitmask & CLONE_FLAT_FLAG,
        isFull = bitmask & CLONE_SYMBOLS_FLAG$1;

    if (customizer) {
      result = object ? customizer(value, key, object, stack) : customizer(value);
    }

    if (result !== undefined) {
      return result;
    }

    if (!isObject$2(value)) {
      return value;
    }

    var isArr = isArray(value);

    if (isArr) {
      result = initCloneArray(value);

      if (!isDeep) {
        return copyArray(value, result);
      }
    } else {
      var tag = getTag$1(value),
          isFunc = tag == funcTag || tag == genTag;

      if (isBuffer(value)) {
        return cloneBuffer(value, isDeep);
      }

      if (tag == objectTag$1 || tag == argsTag$1 || isFunc && !object) {
        result = isFlat || isFunc ? {} : initCloneObject(value);

        if (!isDeep) {
          return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
        }
      } else {
        if (!cloneableTags[tag]) {
          return object ? value : {};
        }

        result = initCloneByTag(value, tag, isDeep);
      }
    } // Check for circular references and return its corresponding clone.


    stack || (stack = new Stack());
    var stacked = stack.get(value);

    if (stacked) {
      return stacked;
    }

    stack.set(value, result);

    if (isSet(value)) {
      value.forEach(function (subValue) {
        result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
      });
    } else if (isMap(value)) {
      value.forEach(function (subValue, key) {
        result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
      });
    }

    var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
    var props = isArr ? undefined : keysFunc(value);
    arrayEach(props || value, function (subValue, key) {
      if (props) {
        key = subValue;
        subValue = value[key];
      } // Recursively populate clone (susceptible to call stack limits).


      assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
    });
    return result;
  }

  /** Used to compose bitmasks for cloning. */

  var CLONE_DEEP_FLAG = 1,
      CLONE_SYMBOLS_FLAG = 4;
  /**
   * This method is like `_.cloneWith` except that it recursively clones `value`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to recursively clone.
   * @param {Function} [customizer] The function to customize cloning.
   * @returns {*} Returns the deep cloned value.
   * @see _.cloneWith
   * @example
   *
   * function customizer(value) {
   *   if (_.isElement(value)) {
   *     return value.cloneNode(true);
   *   }
   * }
   *
   * var el = _.cloneDeepWith(document.body, customizer);
   *
   * console.log(el === document.body);
   * // => false
   * console.log(el.nodeName);
   * // => 'BODY'
   * console.log(el.childNodes.length);
   * // => 20
   */

  function cloneDeepWith(value, customizer) {
    customizer = typeof customizer == 'function' ? customizer : undefined;
    return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
  }

  /** `Object#toString` result references. */

  var stringTag$1 = '[object String]';
  /**
   * Checks if `value` is classified as a `String` primitive or object.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a string, else `false`.
   * @example
   *
   * _.isString('abc');
   * // => true
   *
   * _.isString(1);
   * // => false
   */

  function isString(value) {
    return typeof value == 'string' || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag$1;
  }

  /**
   * Converts `iterator` to an array.
   *
   * @private
   * @param {Object} iterator The iterator to convert.
   * @returns {Array} Returns the converted array.
   */
  function iteratorToArray(iterator) {
    var data,
        result = [];

    while (!(data = iterator.next()).done) {
      result.push(data.value);
    }

    return result;
  }

  /**
   * Converts `map` to its key-value pairs.
   *
   * @private
   * @param {Object} map The map to convert.
   * @returns {Array} Returns the key-value pairs.
   */
  function mapToArray(map) {
    var index = -1,
        result = Array(map.size);
    map.forEach(function (value, key) {
      result[++index] = [key, value];
    });
    return result;
  }

  /**
   * Converts `set` to an array of its values.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the values.
   */
  function setToArray(set) {
    var index = -1,
        result = Array(set.size);
    set.forEach(function (value) {
      result[++index] = value;
    });
    return result;
  }

  /**
   * Converts an ASCII `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function asciiToArray(string) {
    return string.split('');
  }

  /** Used to compose unicode character classes. */
  var rsAstralRange$2 = "\\ud800-\\udfff",
      rsComboMarksRange$3 = "\\u0300-\\u036f",
      reComboHalfMarksRange$3 = "\\ufe20-\\ufe2f",
      rsComboSymbolsRange$3 = "\\u20d0-\\u20ff",
      rsComboRange$3 = rsComboMarksRange$3 + reComboHalfMarksRange$3 + rsComboSymbolsRange$3,
      rsVarRange$2 = "\\ufe0e\\ufe0f";
  /** Used to compose unicode capture groups. */

  var rsZWJ$2 = "\\u200d";
  /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */

  var reHasUnicode = RegExp('[' + rsZWJ$2 + rsAstralRange$2 + rsComboRange$3 + rsVarRange$2 + ']');
  /**
   * Checks if `string` contains Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a symbol is found, else `false`.
   */

  function hasUnicode(string) {
    return reHasUnicode.test(string);
  }

  /** Used to compose unicode character classes. */
  var rsAstralRange$1 = "\\ud800-\\udfff",
      rsComboMarksRange$2 = "\\u0300-\\u036f",
      reComboHalfMarksRange$2 = "\\ufe20-\\ufe2f",
      rsComboSymbolsRange$2 = "\\u20d0-\\u20ff",
      rsComboRange$2 = rsComboMarksRange$2 + reComboHalfMarksRange$2 + rsComboSymbolsRange$2,
      rsVarRange$1 = "\\ufe0e\\ufe0f";
  /** Used to compose unicode capture groups. */

  var rsAstral = '[' + rsAstralRange$1 + ']',
      rsCombo$2 = '[' + rsComboRange$2 + ']',
      rsFitz$1 = "\\ud83c[\\udffb-\\udfff]",
      rsModifier$1 = '(?:' + rsCombo$2 + '|' + rsFitz$1 + ')',
      rsNonAstral$1 = '[^' + rsAstralRange$1 + ']',
      rsRegional$1 = "(?:\\ud83c[\\udde6-\\uddff]){2}",
      rsSurrPair$1 = "[\\ud800-\\udbff][\\udc00-\\udfff]",
      rsZWJ$1 = "\\u200d";
  /** Used to compose unicode regexes. */

  var reOptMod$1 = rsModifier$1 + '?',
      rsOptVar$1 = '[' + rsVarRange$1 + ']?',
      rsOptJoin$1 = '(?:' + rsZWJ$1 + '(?:' + [rsNonAstral$1, rsRegional$1, rsSurrPair$1].join('|') + ')' + rsOptVar$1 + reOptMod$1 + ')*',
      rsSeq$1 = rsOptVar$1 + reOptMod$1 + rsOptJoin$1,
      rsSymbol = '(?:' + [rsNonAstral$1 + rsCombo$2 + '?', rsCombo$2, rsRegional$1, rsSurrPair$1, rsAstral].join('|') + ')';
  /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */

  var reUnicode = RegExp(rsFitz$1 + '(?=' + rsFitz$1 + ')|' + rsSymbol + rsSeq$1, 'g');
  /**
   * Converts a Unicode `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */

  function unicodeToArray(string) {
    return string.match(reUnicode) || [];
  }

  /**
   * Converts `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */

  function stringToArray(string) {
    return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
  }

  /**
   * The base implementation of `_.values` and `_.valuesIn` which creates an
   * array of `object` property values corresponding to the property names
   * of `props`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} props The property names to get values for.
   * @returns {Object} Returns the array of property values.
   */

  function baseValues(object, props) {
    return arrayMap(props, function (key) {
      return object[key];
    });
  }

  /**
   * Creates an array of the own enumerable string keyed property values of `object`.
   *
   * **Note:** Non-object values are coerced to objects.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Object
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property values.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   *   this.b = 2;
   * }
   *
   * Foo.prototype.c = 3;
   *
   * _.values(new Foo);
   * // => [1, 2] (iteration order is not guaranteed)
   *
   * _.values('hi');
   * // => ['h', 'i']
   */

  function values(object) {
    return object == null ? [] : baseValues(object, keys(object));
  }

  /** `Object#toString` result references. */

  var mapTag$1 = '[object Map]',
      setTag$1 = '[object Set]';
  /** Built-in value references. */

  var symIterator = _Symbol ? _Symbol.iterator : undefined;
  /**
   * Converts `value` to an array.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Lang
   * @param {*} value The value to convert.
   * @returns {Array} Returns the converted array.
   * @example
   *
   * _.toArray({ 'a': 1, 'b': 2 });
   * // => [1, 2]
   *
   * _.toArray('abc');
   * // => ['a', 'b', 'c']
   *
   * _.toArray(1);
   * // => []
   *
   * _.toArray(null);
   * // => []
   */

  function toArray(value) {
    if (!value) {
      return [];
    }

    if (isArrayLike(value)) {
      return isString(value) ? stringToArray(value) : copyArray(value);
    }

    if (symIterator && value[symIterator]) {
      return iteratorToArray(value[symIterator]());
    }

    var tag = getTag$1(value),
        func = tag == mapTag$1 ? mapToArray : tag == setTag$1 ? setToArray : values;
    return func(value);
  }

  var toString = Object.prototype.toString;
  var errorToString = Error.prototype.toString;
  var regExpToString = RegExp.prototype.toString;
  var symbolToString = typeof Symbol !== 'undefined' ? Symbol.prototype.toString : function () {
    return '';
  };
  var SYMBOL_REGEXP = /^Symbol\((.*)\)(.*)$/;

  function printNumber(val) {
    if (val != +val) return 'NaN';
    var isNegativeZero = val === 0 && 1 / val < 0;
    return isNegativeZero ? '-0' : '' + val;
  }

  function printSimpleValue(val, quoteStrings) {
    if (quoteStrings === void 0) {
      quoteStrings = false;
    }

    if (val == null || val === true || val === false) return '' + val;

    var typeOf = _typeof(val);

    if (typeOf === 'number') return printNumber(val);
    if (typeOf === 'string') return quoteStrings ? "\"" + val + "\"" : val;
    if (typeOf === 'function') return '[Function ' + (val.name || 'anonymous') + ']';
    if (typeOf === 'symbol') return symbolToString.call(val).replace(SYMBOL_REGEXP, 'Symbol($1)');
    var tag = toString.call(val).slice(8, -1);
    if (tag === 'Date') return isNaN(val.getTime()) ? '' + val : val.toISOString(val);
    if (tag === 'Error' || val instanceof Error) return '[' + errorToString.call(val) + ']';
    if (tag === 'RegExp') return regExpToString.call(val);
    return null;
  }

  function printValue(value, quoteStrings) {
    var result = printSimpleValue(value, quoteStrings);
    if (result !== null) return result;
    return JSON.stringify(value, function (key, value) {
      var result = printSimpleValue(this[key], quoteStrings);
      if (result !== null) return result;
      return value;
    }, 2);
  }

  var mixed = {
    "default": '${path} is invalid',
    required: '${path} is a required field',
    oneOf: '${path} must be one of the following values: ${values}',
    notOneOf: '${path} must not be one of the following values: ${values}',
    notType: function notType(_ref) {
      var path = _ref.path,
          type = _ref.type,
          value = _ref.value,
          originalValue = _ref.originalValue;
      var isCast = originalValue != null && originalValue !== value;
      var msg = path + " must be a `" + type + "` type, " + ("but the final value was: `" + printValue(value, true) + "`") + (isCast ? " (cast from the value `" + printValue(originalValue, true) + "`)." : '.');

      if (value === null) {
        msg += "\n If \"null\" is intended as an empty value be sure to mark the schema as `.nullable()`";
      }

      return msg;
    },
    defined: '${path} must be defined'
  };
  var string = {
    length: '${path} must be exactly ${length} characters',
    min: '${path} must be at least ${min} characters',
    max: '${path} must be at most ${max} characters',
    matches: '${path} must match the following: "${regex}"',
    email: '${path} must be a valid email',
    url: '${path} must be a valid URL',
    trim: '${path} must be a trimmed string',
    lowercase: '${path} must be a lowercase string',
    uppercase: '${path} must be a upper case string'
  };
  var number = {
    min: '${path} must be greater than or equal to ${min}',
    max: '${path} must be less than or equal to ${max}',
    lessThan: '${path} must be less than ${less}',
    moreThan: '${path} must be greater than ${more}',
    notEqual: '${path} must be not equal to ${notEqual}',
    positive: '${path} must be a positive number',
    negative: '${path} must be a negative number',
    integer: '${path} must be an integer'
  };
  var date = {
    min: '${path} field must be later than ${min}',
    max: '${path} field must be at earlier than ${max}'
  };
  var object = {
    noUnknown: '${path} field has unspecified keys: ${unknown}'
  };
  var array$1 = {
    min: '${path} field must have at least ${min} items',
    max: '${path} field must have less than or equal to ${max} items'
  };

  var isSchema = (function (obj) {
    return obj && obj.__isYupSchema__;
  });

  var Condition = /*#__PURE__*/function () {
    function Condition(refs, options) {
      this.refs = refs;

      if (typeof options === 'function') {
        this.fn = options;
        return;
      }

      if (!has(options, 'is')) throw new TypeError('`is:` is required for `when()` conditions');
      if (!options.then && !options.otherwise) throw new TypeError('either `then:` or `otherwise:` is required for `when()` conditions');
      var is = options.is,
          then = options.then,
          otherwise = options.otherwise;
      var check = typeof is === 'function' ? is : function () {
        for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {
          values[_key] = arguments[_key];
        }

        return values.every(function (value) {
          return value === is;
        });
      };

      this.fn = function () {
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        var options = args.pop();
        var schema = args.pop();
        var branch = check.apply(void 0, args) ? then : otherwise;
        if (!branch) return undefined;
        if (typeof branch === 'function') return branch(schema);
        return schema.concat(branch.resolve(options));
      };
    }

    var _proto = Condition.prototype;

    _proto.resolve = function resolve(base, options) {
      var values = this.refs.map(function (ref) {
        return ref.getValue(options);
      });
      var schema = this.fn.apply(base, values.concat(base, options));
      if (schema === undefined || schema === base) return base;
      if (!isSchema(schema)) throw new TypeError('conditions must return a schema object');
      return schema.resolve(options);
    };

    return Condition;
  }();

  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;

    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }

    return target;
  }

  /* jshint node: true */

  function makeArrayFrom(obj) {
    return Array.prototype.slice.apply(obj);
  }

  var PENDING = "pending",
      RESOLVED = "resolved",
      REJECTED = "rejected";

  function SynchronousPromise(handler) {
    this.status = PENDING;
    this._continuations = [];
    this._parent = null;
    this._paused = false;

    if (handler) {
      handler.call(this, this._continueWith.bind(this), this._failWith.bind(this));
    }
  }

  function looksLikeAPromise(obj) {
    return obj && typeof obj.then === "function";
  }

  function passThrough(value) {
    return value;
  }

  SynchronousPromise.prototype = {
    then: function then(nextFn, catchFn) {
      var next = SynchronousPromise.unresolved()._setParent(this);

      if (this._isRejected()) {
        if (this._paused) {
          this._continuations.push({
            promise: next,
            nextFn: nextFn,
            catchFn: catchFn
          });

          return next;
        }

        if (catchFn) {
          try {
            var catchResult = catchFn(this._error);

            if (looksLikeAPromise(catchResult)) {
              this._chainPromiseData(catchResult, next);

              return next;
            } else {
              return SynchronousPromise.resolve(catchResult)._setParent(this);
            }
          } catch (e) {
            return SynchronousPromise.reject(e)._setParent(this);
          }
        }

        return SynchronousPromise.reject(this._error)._setParent(this);
      }

      this._continuations.push({
        promise: next,
        nextFn: nextFn,
        catchFn: catchFn
      });

      this._runResolutions();

      return next;
    },
    "catch": function _catch(handler) {
      if (this._isResolved()) {
        return SynchronousPromise.resolve(this._data)._setParent(this);
      }

      var next = SynchronousPromise.unresolved()._setParent(this);

      this._continuations.push({
        promise: next,
        catchFn: handler
      });

      this._runRejections();

      return next;
    },
    "finally": function _finally(callback) {
      var ran = false;

      function runFinally(result, err) {
        if (!ran) {
          ran = true;

          if (!callback) {
            callback = passThrough;
          }

          var callbackResult = callback(result);

          if (looksLikeAPromise(callbackResult)) {
            return callbackResult.then(function () {
              if (err) {
                throw err;
              }

              return result;
            });
          } else {
            return result;
          }
        }
      }

      return this.then(function (result) {
        return runFinally(result);
      })["catch"](function (err) {
        return runFinally(null, err);
      });
    },
    pause: function pause() {
      this._paused = true;
      return this;
    },
    resume: function resume() {
      var firstPaused = this._findFirstPaused();

      if (firstPaused) {
        firstPaused._paused = false;

        firstPaused._runResolutions();

        firstPaused._runRejections();
      }

      return this;
    },
    _findAncestry: function _findAncestry() {
      return this._continuations.reduce(function (acc, cur) {
        if (cur.promise) {
          var node = {
            promise: cur.promise,
            children: cur.promise._findAncestry()
          };
          acc.push(node);
        }

        return acc;
      }, []);
    },
    _setParent: function _setParent(parent) {
      if (this._parent) {
        throw new Error("parent already set");
      }

      this._parent = parent;
      return this;
    },
    _continueWith: function _continueWith(data) {
      var firstPending = this._findFirstPending();

      if (firstPending) {
        firstPending._data = data;

        firstPending._setResolved();
      }
    },
    _findFirstPending: function _findFirstPending() {
      return this._findFirstAncestor(function (test) {
        return test._isPending && test._isPending();
      });
    },
    _findFirstPaused: function _findFirstPaused() {
      return this._findFirstAncestor(function (test) {
        return test._paused;
      });
    },
    _findFirstAncestor: function _findFirstAncestor(matching) {
      var test = this;
      var result;

      while (test) {
        if (matching(test)) {
          result = test;
        }

        test = test._parent;
      }

      return result;
    },
    _failWith: function _failWith(error) {
      var firstRejected = this._findFirstPending();

      if (firstRejected) {
        firstRejected._error = error;

        firstRejected._setRejected();
      }
    },
    _takeContinuations: function _takeContinuations() {
      return this._continuations.splice(0, this._continuations.length);
    },
    _runRejections: function _runRejections() {
      if (this._paused || !this._isRejected()) {
        return;
      }

      var error = this._error,
          continuations = this._takeContinuations(),
          self = this;

      continuations.forEach(function (cont) {
        if (cont.catchFn) {
          try {
            var catchResult = cont.catchFn(error);

            self._handleUserFunctionResult(catchResult, cont.promise);
          } catch (e) {
            cont.promise.reject(e);
          }
        } else {
          cont.promise.reject(error);
        }
      });
    },
    _runResolutions: function _runResolutions() {
      if (this._paused || !this._isResolved() || this._isPending()) {
        return;
      }

      var continuations = this._takeContinuations();

      if (looksLikeAPromise(this._data)) {
        return this._handleWhenResolvedDataIsPromise(this._data);
      }

      var data = this._data;
      var self = this;
      continuations.forEach(function (cont) {
        if (cont.nextFn) {
          try {
            var result = cont.nextFn(data);

            self._handleUserFunctionResult(result, cont.promise);
          } catch (e) {
            self._handleResolutionError(e, cont);
          }
        } else if (cont.promise) {
          cont.promise.resolve(data);
        }
      });
    },
    _handleResolutionError: function _handleResolutionError(e, continuation) {
      this._setRejected();

      if (continuation.catchFn) {
        try {
          continuation.catchFn(e);
          return;
        } catch (e2) {
          e = e2;
        }
      }

      if (continuation.promise) {
        continuation.promise.reject(e);
      }
    },
    _handleWhenResolvedDataIsPromise: function _handleWhenResolvedDataIsPromise(data) {
      var self = this;
      return data.then(function (result) {
        self._data = result;

        self._runResolutions();
      })["catch"](function (error) {
        self._error = error;

        self._setRejected();

        self._runRejections();
      });
    },
    _handleUserFunctionResult: function _handleUserFunctionResult(data, nextSynchronousPromise) {
      if (looksLikeAPromise(data)) {
        this._chainPromiseData(data, nextSynchronousPromise);
      } else {
        nextSynchronousPromise.resolve(data);
      }
    },
    _chainPromiseData: function _chainPromiseData(promiseData, nextSynchronousPromise) {
      promiseData.then(function (newData) {
        nextSynchronousPromise.resolve(newData);
      })["catch"](function (newError) {
        nextSynchronousPromise.reject(newError);
      });
    },
    _setResolved: function _setResolved() {
      this.status = RESOLVED;

      if (!this._paused) {
        this._runResolutions();
      }
    },
    _setRejected: function _setRejected() {
      this.status = REJECTED;

      if (!this._paused) {
        this._runRejections();
      }
    },
    _isPending: function _isPending() {
      return this.status === PENDING;
    },
    _isResolved: function _isResolved() {
      return this.status === RESOLVED;
    },
    _isRejected: function _isRejected() {
      return this.status === REJECTED;
    }
  };

  SynchronousPromise.resolve = function (result) {
    return new SynchronousPromise(function (resolve, reject) {
      if (looksLikeAPromise(result)) {
        result.then(function (newResult) {
          resolve(newResult);
        })["catch"](function (error) {
          reject(error);
        });
      } else {
        resolve(result);
      }
    });
  };

  SynchronousPromise.reject = function (result) {
    return new SynchronousPromise(function (resolve, reject) {
      reject(result);
    });
  };

  SynchronousPromise.unresolved = function () {
    return new SynchronousPromise(function (resolve, reject) {
      this.resolve = resolve;
      this.reject = reject;
    });
  };

  SynchronousPromise.all = function () {
    var args = makeArrayFrom(arguments);

    if (Array.isArray(args[0])) {
      args = args[0];
    }

    if (!args.length) {
      return SynchronousPromise.resolve([]);
    }

    return new SynchronousPromise(function (resolve, reject) {
      var allData = [],
          numResolved = 0,
          doResolve = function doResolve() {
        if (numResolved === args.length) {
          resolve(allData);
        }
      },
          rejected = false,
          doReject = function doReject(err) {
        if (rejected) {
          return;
        }

        rejected = true;
        reject(err);
      };

      args.forEach(function (arg, idx) {
        SynchronousPromise.resolve(arg).then(function (thisResult) {
          allData[idx] = thisResult;
          numResolved += 1;
          doResolve();
        })["catch"](function (err) {
          doReject(err);
        });
      });
    });
  };

  SynchronousPromise.any = function () {
    var args = makeArrayFrom(arguments);

    if (Array.isArray(args[0])) {
      args = args[0];
    }

    if (!args.length) {
      return SynchronousPromise.reject({
        errors: []
      });
    }

    return new SynchronousPromise(function (resolve, reject) {
      var allErrors = [],
          numRejected = 0,
          doReject = function doReject() {
        if (numRejected === args.length) {
          reject({
            errors: allErrors
          });
        }
      },
          resolved = false,
          doResolve = function doResolve(result) {
        if (resolved) {
          return;
        }

        resolved = true;
        resolve(result);
      };

      args.forEach(function (arg, idx) {
        SynchronousPromise.resolve(arg).then(function (thisResult) {
          doResolve(thisResult);
        })["catch"](function (err) {
          allErrors[idx] = err;
          numRejected += 1;
          doReject();
        });
      });
    });
  };

  SynchronousPromise.allSettled = function () {
    var args = makeArrayFrom(arguments);

    if (Array.isArray(args[0])) {
      args = args[0];
    }

    if (!args.length) {
      return SynchronousPromise.resolve([]);
    }

    return new SynchronousPromise(function (resolve) {
      var allData = [],
          numSettled = 0,
          doSettled = function doSettled() {
        numSettled += 1;

        if (numSettled === args.length) {
          resolve(allData);
        }
      };

      args.forEach(function (arg, idx) {
        SynchronousPromise.resolve(arg).then(function (thisResult) {
          allData[idx] = {
            status: "fulfilled",
            value: thisResult
          };
          doSettled();
        })["catch"](function (err) {
          allData[idx] = {
            status: "rejected",
            reason: err
          };
          doSettled();
        });
      });
    });
  };
  /* jshint ignore:start */


  if (Promise === SynchronousPromise) {
    throw new Error("Please use SynchronousPromise.installGlobally() to install globally");
  }

  var RealPromise = Promise;

  SynchronousPromise.installGlobally = function (__awaiter) {
    if (Promise === SynchronousPromise) {
      return __awaiter;
    }

    var result = patchAwaiterIfRequired(__awaiter);
    Promise = SynchronousPromise;
    return result;
  };

  SynchronousPromise.uninstallGlobally = function () {
    if (Promise === SynchronousPromise) {
      Promise = RealPromise;
    }
  };

  function patchAwaiterIfRequired(__awaiter) {
    if (typeof __awaiter === "undefined" || __awaiter.__patched) {
      return __awaiter;
    }

    var originalAwaiter = __awaiter;

    __awaiter = function __awaiter() {
      originalAwaiter.apply(this, makeArrayFrom(arguments));
    };

    __awaiter.__patched = true;
    return __awaiter;
  }
  /* jshint ignore:end */


  var synchronousPromise = {
    SynchronousPromise: SynchronousPromise
  };

  var strReg = /\$\{\s*(\w+)\s*\}/g;

  var replace = function replace(str) {
    return function (params) {
      return str.replace(strReg, function (_, key) {
        return printValue(params[key]);
      });
    };
  };

  function ValidationError(errors, value, field, type) {
    var _this = this;

    this.name = 'ValidationError';
    this.value = value;
    this.path = field;
    this.type = type;
    this.errors = [];
    this.inner = [];
    if (errors) [].concat(errors).forEach(function (err) {
      _this.errors = _this.errors.concat(err.errors || err);
      if (err.inner) _this.inner = _this.inner.concat(err.inner.length ? err.inner : err);
    });
    this.message = this.errors.length > 1 ? this.errors.length + " errors occurred" : this.errors[0];
    if (Error.captureStackTrace) Error.captureStackTrace(this, ValidationError);
  }
  ValidationError.prototype = Object.create(Error.prototype);
  ValidationError.prototype.constructor = ValidationError;

  ValidationError.isError = function (err) {
    return err && err.name === 'ValidationError';
  };

  ValidationError.formatError = function (message, params) {
    if (typeof message === 'string') message = replace(message);

    var fn = function fn(params) {
      params.path = params.label || params.path || 'this';
      return typeof message === 'function' ? message(params) : message;
    };

    return arguments.length === 1 ? fn : fn(params);
  };

  var promise$1 = function promise(sync) {
    return sync ? synchronousPromise.SynchronousPromise : Promise;
  };

  var unwrapError = function unwrapError(errors) {
    if (errors === void 0) {
      errors = [];
    }

    return errors.inner && errors.inner.length ? errors.inner : [].concat(errors);
  };

  function scopeToValue(promises, value, sync) {
    //console.log('scopeToValue', promises, value)
    var p = promise$1(sync).all(promises); //console.log('scopeToValue B', p)

    var b = p["catch"](function (err) {
      if (err.name === 'ValidationError') err.value = value;
      throw err;
    }); //console.log('scopeToValue c', b)

    var c = b.then(function () {
      return value;
    }); //console.log('scopeToValue d', c)

    return c;
  }
  /**
   * If not failing on the first error, catch the errors
   * and collect them in an array
   */


  function propagateErrors(endEarly, errors) {
    return endEarly ? null : function (err) {
      errors.push(err);
      return err.value;
    };
  }
  function settled(promises, sync) {
    var Promise = promise$1(sync);
    return Promise.all(promises.map(function (p) {
      return Promise.resolve(p).then(function (value) {
        return {
          fulfilled: true,
          value: value
        };
      }, function (value) {
        return {
          fulfilled: false,
          value: value
        };
      });
    }));
  }
  function collectErrors(_ref) {
    var validations = _ref.validations,
        value = _ref.value,
        path = _ref.path,
        sync = _ref.sync,
        errors = _ref.errors,
        sort = _ref.sort;
    errors = unwrapError(errors);
    return settled(validations, sync).then(function (results) {
      var nestedErrors = results.filter(function (r) {
        return !r.fulfilled;
      }).reduce(function (arr, _ref2) {
        var error = _ref2.value; // we are only collecting validation errors

        if (!ValidationError.isError(error)) {
          throw error;
        }

        return arr.concat(error);
      }, []);
      if (sort) nestedErrors.sort(sort); //show parent errors after the nested ones: name.first, name

      errors = nestedErrors.concat(errors);
      if (errors.length) throw new ValidationError(errors, value, path);
      return value;
    });
  }
  function runValidations(_ref3) {
    var endEarly = _ref3.endEarly,
        options = _objectWithoutPropertiesLoose(_ref3, ["endEarly"]);

    if (endEarly) return scopeToValue(options.validations, options.value, options.sync);
    return collectErrors(options);
  }

  var isObject$1 = function isObject(obj) {
    return Object.prototype.toString.call(obj) === '[object Object]';
  };

  function prependDeep(target, source) {
    for (var key in source) {
      if (has(source, key)) {
        var sourceVal = source[key],
            targetVal = target[key];

        if (targetVal === undefined) {
          target[key] = sourceVal;
        } else if (targetVal === sourceVal) {
          continue;
        } else if (isSchema(targetVal)) {
          if (isSchema(sourceVal)) target[key] = sourceVal.concat(targetVal);
        } else if (isObject$1(targetVal)) {
          if (isObject$1(sourceVal)) target[key] = prependDeep(targetVal, sourceVal);
        } else if (Array.isArray(targetVal)) {
          if (Array.isArray(sourceVal)) target[key] = sourceVal.concat(targetVal);
        }
      }
    }

    return target;
  }

  /**
   * Creates a base function for methods like `_.forIn` and `_.forOwn`.
   *
   * @private
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {Function} Returns the new base function.
   */
  function createBaseFor(fromRight) {
    return function (object, iteratee, keysFunc) {
      var index = -1,
          iterable = Object(object),
          props = keysFunc(object),
          length = props.length;

      while (length--) {
        var key = props[fromRight ? length : ++index];

        if (iteratee(iterable[key], key, iterable) === false) {
          break;
        }
      }

      return object;
    };
  }

  /**
   * The base implementation of `baseForOwn` which iterates over `object`
   * properties returned by `keysFunc` and invokes `iteratee` for each property.
   * Iteratee functions may exit iteration early by explicitly returning `false`.
   *
   * @private
   * @param {Object} object The object to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {Function} keysFunc The function to get the keys of `object`.
   * @returns {Object} Returns `object`.
   */

  var baseFor = createBaseFor();

  /**
   * The base implementation of `_.forOwn` without support for iteratee shorthands.
   *
   * @private
   * @param {Object} object The object to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Object} Returns `object`.
   */

  function baseForOwn(object, iteratee) {
    return object && baseFor(object, iteratee, keys);
  }

  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED = '__lodash_hash_undefined__';
  /**
   * Adds `value` to the array cache.
   *
   * @private
   * @name add
   * @memberOf SetCache
   * @alias push
   * @param {*} value The value to cache.
   * @returns {Object} Returns the cache instance.
   */

  function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED);

    return this;
  }

  /**
   * Checks if `value` is in the array cache.
   *
   * @private
   * @name has
   * @memberOf SetCache
   * @param {*} value The value to search for.
   * @returns {number} Returns `true` if `value` is found, else `false`.
   */
  function setCacheHas(value) {
    return this.__data__.has(value);
  }

  /**
   *
   * Creates an array cache object to store unique values.
   *
   * @private
   * @constructor
   * @param {Array} [values] The values to cache.
   */

  function SetCache(values) {
    var index = -1,
        length = values == null ? 0 : values.length;
    this.__data__ = new MapCache();

    while (++index < length) {
      this.add(values[index]);
    }
  } // Add methods to `SetCache`.


  SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
  SetCache.prototype.has = setCacheHas;

  /**
   * A specialized version of `_.some` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if any element passes the predicate check,
   *  else `false`.
   */
  function arraySome(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (predicate(array[index], index, array)) {
        return true;
      }
    }

    return false;
  }

  /**
   * Checks if a `cache` value for `key` exists.
   *
   * @private
   * @param {Object} cache The cache to query.
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function cacheHas(cache, key) {
    return cache.has(key);
  }

  /** Used to compose bitmasks for value comparisons. */

  var COMPARE_PARTIAL_FLAG$5 = 1,
      COMPARE_UNORDERED_FLAG$3 = 2;
  /**
   * A specialized version of `baseIsEqualDeep` for arrays with support for
   * partial deep comparisons.
   *
   * @private
   * @param {Array} array The array to compare.
   * @param {Array} other The other array to compare.
   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
   * @param {Function} customizer The function to customize comparisons.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Object} stack Tracks traversed `array` and `other` objects.
   * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
   */

  function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5,
        arrLength = array.length,
        othLength = other.length;

    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
      return false;
    } // Assume cyclic values are equal.


    var stacked = stack.get(array);

    if (stacked && stack.get(other)) {
      return stacked == other;
    }

    var index = -1,
        result = true,
        seen = bitmask & COMPARE_UNORDERED_FLAG$3 ? new SetCache() : undefined;
    stack.set(array, other);
    stack.set(other, array); // Ignore non-index properties.

    while (++index < arrLength) {
      var arrValue = array[index],
          othValue = other[index];

      if (customizer) {
        var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
      }

      if (compared !== undefined) {
        if (compared) {
          continue;
        }

        result = false;
        break;
      } // Recursively compare arrays (susceptible to call stack limits).


      if (seen) {
        if (!arraySome(other, function (othValue, othIndex) {
          if (!cacheHas(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
            return seen.push(othIndex);
          }
        })) {
          result = false;
          break;
        }
      } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
        result = false;
        break;
      }
    }

    stack['delete'](array);
    stack['delete'](other);
    return result;
  }

  /** Used to compose bitmasks for value comparisons. */

  var COMPARE_PARTIAL_FLAG$4 = 1,
      COMPARE_UNORDERED_FLAG$2 = 2;
  /** `Object#toString` result references. */

  var boolTag = '[object Boolean]',
      dateTag = '[object Date]',
      errorTag = '[object Error]',
      mapTag = '[object Map]',
      numberTag = '[object Number]',
      regexpTag = '[object RegExp]',
      setTag = '[object Set]',
      stringTag = '[object String]',
      symbolTag = '[object Symbol]';
  var arrayBufferTag = '[object ArrayBuffer]',
      dataViewTag = '[object DataView]';
  /** Used to convert symbols to primitives and strings. */

  var symbolProto = _Symbol ? _Symbol.prototype : undefined,
      symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;
  /**
   * A specialized version of `baseIsEqualDeep` for comparing objects of
   * the same `toStringTag`.
   *
   * **Note:** This function only supports comparing values with tags of
   * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @param {string} tag The `toStringTag` of the objects to compare.
   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
   * @param {Function} customizer The function to customize comparisons.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Object} stack Tracks traversed `object` and `other` objects.
   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
   */

  function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
    switch (tag) {
      case dataViewTag:
        if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
          return false;
        }

        object = object.buffer;
        other = other.buffer;

      case arrayBufferTag:
        if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
          return false;
        }

        return true;

      case boolTag:
      case dateTag:
      case numberTag:
        // Coerce booleans to `1` or `0` and dates to milliseconds.
        // Invalid dates are coerced to `NaN`.
        return eq(+object, +other);

      case errorTag:
        return object.name == other.name && object.message == other.message;

      case regexpTag:
      case stringTag:
        // Coerce regexes to strings and treat strings, primitives and objects,
        // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
        // for more details.
        return object == other + '';

      case mapTag:
        var convert = mapToArray;

      case setTag:
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4;
        convert || (convert = setToArray);

        if (object.size != other.size && !isPartial) {
          return false;
        } // Assume cyclic values are equal.


        var stacked = stack.get(object);

        if (stacked) {
          return stacked == other;
        }

        bitmask |= COMPARE_UNORDERED_FLAG$2; // Recursively compare objects (susceptible to call stack limits).

        stack.set(object, other);
        var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
        stack['delete'](object);
        return result;

      case symbolTag:
        if (symbolValueOf) {
          return symbolValueOf.call(object) == symbolValueOf.call(other);
        }

    }

    return false;
  }

  /** Used to compose bitmasks for value comparisons. */

  var COMPARE_PARTIAL_FLAG$3 = 1;
  /** Used for built-in method references. */

  var objectProto$1 = Object.prototype;
  /** Used to check objects for own properties. */

  var hasOwnProperty$1 = objectProto$1.hasOwnProperty;
  /**
   * A specialized version of `baseIsEqualDeep` for objects with support for
   * partial deep comparisons.
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
   * @param {Function} customizer The function to customize comparisons.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Object} stack Tracks traversed `object` and `other` objects.
   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
   */

  function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3,
        objProps = getAllKeys(object),
        objLength = objProps.length,
        othProps = getAllKeys(other),
        othLength = othProps.length;

    if (objLength != othLength && !isPartial) {
      return false;
    }

    var index = objLength;

    while (index--) {
      var key = objProps[index];

      if (!(isPartial ? key in other : hasOwnProperty$1.call(other, key))) {
        return false;
      }
    } // Assume cyclic values are equal.


    var stacked = stack.get(object);

    if (stacked && stack.get(other)) {
      return stacked == other;
    }

    var result = true;
    stack.set(object, other);
    stack.set(other, object);
    var skipCtor = isPartial;

    while (++index < objLength) {
      key = objProps[index];
      var objValue = object[key],
          othValue = other[key];

      if (customizer) {
        var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
      } // Recursively compare objects (susceptible to call stack limits).


      if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
        result = false;
        break;
      }

      skipCtor || (skipCtor = key == 'constructor');
    }

    if (result && !skipCtor) {
      var objCtor = object.constructor,
          othCtor = other.constructor; // Non `Object` object instances with different constructors are not equal.

      if (objCtor != othCtor && 'constructor' in object && 'constructor' in other && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
        result = false;
      }
    }

    stack['delete'](object);
    stack['delete'](other);
    return result;
  }

  /** Used to compose bitmasks for value comparisons. */

  var COMPARE_PARTIAL_FLAG$2 = 1;
  /** `Object#toString` result references. */

  var argsTag = '[object Arguments]',
      arrayTag = '[object Array]',
      objectTag = '[object Object]';
  /** Used for built-in method references. */

  var objectProto = Object.prototype;
  /** Used to check objects for own properties. */

  var hasOwnProperty = objectProto.hasOwnProperty;
  /**
   * A specialized version of `baseIsEqual` for arrays and objects which performs
   * deep comparisons and tracks traversed objects enabling objects with circular
   * references to be compared.
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
   * @param {Function} customizer The function to customize comparisons.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Object} [stack] Tracks traversed `object` and `other` objects.
   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
   */

  function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
    var objIsArr = isArray(object),
        othIsArr = isArray(other),
        objTag = objIsArr ? arrayTag : getTag$1(object),
        othTag = othIsArr ? arrayTag : getTag$1(other);
    objTag = objTag == argsTag ? objectTag : objTag;
    othTag = othTag == argsTag ? objectTag : othTag;
    var objIsObj = objTag == objectTag,
        othIsObj = othTag == objectTag,
        isSameTag = objTag == othTag;

    if (isSameTag && isBuffer(object)) {
      if (!isBuffer(other)) {
        return false;
      }

      objIsArr = true;
      objIsObj = false;
    }

    if (isSameTag && !objIsObj) {
      stack || (stack = new Stack());
      return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
    }

    if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {
      var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
          othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

      if (objIsWrapped || othIsWrapped) {
        var objUnwrapped = objIsWrapped ? object.value() : object,
            othUnwrapped = othIsWrapped ? other.value() : other;
        stack || (stack = new Stack());
        return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
      }
    }

    if (!isSameTag) {
      return false;
    }

    stack || (stack = new Stack());
    return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
  }

  /**
   * The base implementation of `_.isEqual` which supports partial comparisons
   * and tracks traversed objects.
   *
   * @private
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @param {boolean} bitmask The bitmask flags.
   *  1 - Unordered comparison
   *  2 - Partial comparison
   * @param {Function} [customizer] The function to customize comparisons.
   * @param {Object} [stack] Tracks traversed `value` and `other` objects.
   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
   */

  function baseIsEqual(value, other, bitmask, customizer, stack) {
    if (value === other) {
      return true;
    }

    if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
      return value !== value && other !== other;
    }

    return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
  }

  /** Used to compose bitmasks for value comparisons. */

  var COMPARE_PARTIAL_FLAG$1 = 1,
      COMPARE_UNORDERED_FLAG$1 = 2;
  /**
   * The base implementation of `_.isMatch` without support for iteratee shorthands.
   *
   * @private
   * @param {Object} object The object to inspect.
   * @param {Object} source The object of property values to match.
   * @param {Array} matchData The property names, values, and compare flags to match.
   * @param {Function} [customizer] The function to customize comparisons.
   * @returns {boolean} Returns `true` if `object` is a match, else `false`.
   */

  function baseIsMatch(object, source, matchData, customizer) {
    var index = matchData.length,
        length = index,
        noCustomizer = !customizer;

    if (object == null) {
      return !length;
    }

    object = Object(object);

    while (index--) {
      var data = matchData[index];

      if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
        return false;
      }
    }

    while (++index < length) {
      data = matchData[index];
      var key = data[0],
          objValue = object[key],
          srcValue = data[1];

      if (noCustomizer && data[2]) {
        if (objValue === undefined && !(key in object)) {
          return false;
        }
      } else {
        var stack = new Stack();

        if (customizer) {
          var result = customizer(objValue, srcValue, key, object, source, stack);
        }

        if (!(result === undefined ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack) : result)) {
          return false;
        }
      }
    }

    return true;
  }

  /**
   * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` if suitable for strict
   *  equality comparisons, else `false`.
   */

  function isStrictComparable(value) {
    return value === value && !isObject$2(value);
  }

  /**
   * Gets the property names, values, and compare flags of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the match data of `object`.
   */

  function getMatchData(object) {
    var result = keys(object),
        length = result.length;

    while (length--) {
      var key = result[length],
          value = object[key];
      result[length] = [key, value, isStrictComparable(value)];
    }

    return result;
  }

  /**
   * A specialized version of `matchesProperty` for source values suitable
   * for strict equality comparisons, i.e. `===`.
   *
   * @private
   * @param {string} key The key of the property to get.
   * @param {*} srcValue The value to match.
   * @returns {Function} Returns the new spec function.
   */
  function matchesStrictComparable(key, srcValue) {
    return function (object) {
      if (object == null) {
        return false;
      }

      return object[key] === srcValue && (srcValue !== undefined || key in Object(object));
    };
  }

  /**
   * The base implementation of `_.matches` which doesn't clone `source`.
   *
   * @private
   * @param {Object} source The object of property values to match.
   * @returns {Function} Returns the new spec function.
   */

  function baseMatches(source) {
    var matchData = getMatchData(source);

    if (matchData.length == 1 && matchData[0][2]) {
      return matchesStrictComparable(matchData[0][0], matchData[0][1]);
    }

    return function (object) {
      return object === source || baseIsMatch(object, source, matchData);
    };
  }

  /**
   * The base implementation of `_.get` without support for default values.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array|string} path The path of the property to get.
   * @returns {*} Returns the resolved value.
   */

  function baseGet(object, path) {
    path = castPath(path, object);
    var index = 0,
        length = path.length;

    while (object != null && index < length) {
      object = object[toKey(path[index++])];
    }

    return index && index == length ? object : undefined;
  }

  /**
   * Gets the value at `path` of `object`. If the resolved value is
   * `undefined`, the `defaultValue` is returned in its place.
   *
   * @static
   * @memberOf _
   * @since 3.7.0
   * @category Object
   * @param {Object} object The object to query.
   * @param {Array|string} path The path of the property to get.
   * @param {*} [defaultValue] The value returned for `undefined` resolved values.
   * @returns {*} Returns the resolved value.
   * @example
   *
   * var object = { 'a': [{ 'b': { 'c': 3 } }] };
   *
   * _.get(object, 'a[0].b.c');
   * // => 3
   *
   * _.get(object, ['a', '0', 'b', 'c']);
   * // => 3
   *
   * _.get(object, 'a.b.c', 'default');
   * // => 'default'
   */

  function get(object, path, defaultValue) {
    var result = object == null ? undefined : baseGet(object, path);
    return result === undefined ? defaultValue : result;
  }

  /**
   * The base implementation of `_.hasIn` without support for deep paths.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {Array|string} key The key to check.
   * @returns {boolean} Returns `true` if `key` exists, else `false`.
   */
  function baseHasIn(object, key) {
    return object != null && key in Object(object);
  }

  /**
   * Checks if `path` is a direct or inherited property of `object`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Object
   * @param {Object} object The object to query.
   * @param {Array|string} path The path to check.
   * @returns {boolean} Returns `true` if `path` exists, else `false`.
   * @example
   *
   * var object = _.create({ 'a': _.create({ 'b': 2 }) });
   *
   * _.hasIn(object, 'a');
   * // => true
   *
   * _.hasIn(object, 'a.b');
   * // => true
   *
   * _.hasIn(object, ['a', 'b']);
   * // => true
   *
   * _.hasIn(object, 'b');
   * // => false
   */

  function hasIn(object, path) {
    return object != null && hasPath(object, path, baseHasIn);
  }

  /** Used to compose bitmasks for value comparisons. */

  var COMPARE_PARTIAL_FLAG = 1,
      COMPARE_UNORDERED_FLAG = 2;
  /**
   * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
   *
   * @private
   * @param {string} path The path of the property to get.
   * @param {*} srcValue The value to match.
   * @returns {Function} Returns the new spec function.
   */

  function baseMatchesProperty(path, srcValue) {
    if (isKey(path) && isStrictComparable(srcValue)) {
      return matchesStrictComparable(toKey(path), srcValue);
    }

    return function (object) {
      var objValue = get(object, path);
      return objValue === undefined && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
    };
  }

  /**
   * This method returns the first argument it receives.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Util
   * @param {*} value Any value.
   * @returns {*} Returns `value`.
   * @example
   *
   * var object = { 'a': 1 };
   *
   * console.log(_.identity(object) === object);
   * // => true
   */
  function identity(value) {
    return value;
  }

  /**
   * The base implementation of `_.property` without support for deep paths.
   *
   * @private
   * @param {string} key The key of the property to get.
   * @returns {Function} Returns the new accessor function.
   */
  function baseProperty(key) {
    return function (object) {
      return object == null ? undefined : object[key];
    };
  }

  /**
   * A specialized version of `baseProperty` which supports deep paths.
   *
   * @private
   * @param {Array|string} path The path of the property to get.
   * @returns {Function} Returns the new accessor function.
   */

  function basePropertyDeep(path) {
    return function (object) {
      return baseGet(object, path);
    };
  }

  /**
   * Creates a function that returns the value at `path` of a given object.
   *
   * @static
   * @memberOf _
   * @since 2.4.0
   * @category Util
   * @param {Array|string} path The path of the property to get.
   * @returns {Function} Returns the new accessor function.
   * @example
   *
   * var objects = [
   *   { 'a': { 'b': 2 } },
   *   { 'a': { 'b': 1 } }
   * ];
   *
   * _.map(objects, _.property('a.b'));
   * // => [2, 1]
   *
   * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
   * // => [1, 2]
   */

  function property(path) {
    return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
  }

  /**
   * The base implementation of `_.iteratee`.
   *
   * @private
   * @param {*} [value=_.identity] The value to convert to an iteratee.
   * @returns {Function} Returns the iteratee.
   */

  function baseIteratee(value) {
    // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
    // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
    if (typeof value == 'function') {
      return value;
    }

    if (value == null) {
      return identity;
    }

    if (_typeof(value) == 'object') {
      return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
    }

    return property(value);
  }

  /**
   * Creates an object with the same keys as `object` and values generated
   * by running each own enumerable string keyed property of `object` thru
   * `iteratee`. The iteratee is invoked with three arguments:
   * (value, key, object).
   *
   * @static
   * @memberOf _
   * @since 2.4.0
   * @category Object
   * @param {Object} object The object to iterate over.
   * @param {Function} [iteratee=_.identity] The function invoked per iteration.
   * @returns {Object} Returns the new mapped object.
   * @see _.mapKeys
   * @example
   *
   * var users = {
   *   'fred':    { 'user': 'fred',    'age': 40 },
   *   'pebbles': { 'user': 'pebbles', 'age': 1 }
   * };
   *
   * _.mapValues(users, function(o) { return o.age; });
   * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
   *
   * // The `_.property` iteratee shorthand.
   * _.mapValues(users, 'age');
   * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
   */

  function mapValues(object, iteratee) {
    var result = {};
    iteratee = baseIteratee(iteratee);
    baseForOwn(object, function (value, key, object) {
      baseAssignValue(result, key, iteratee(value, key, object));
    });
    return result;
  }

  /**
   * Based on Kendo UI Core expression code <https://github.com/telerik/kendo-ui-core#license-information>
   */

  function Cache(maxSize) {
    this._maxSize = maxSize;
    this.clear();
  }

  Cache.prototype.clear = function () {
    this._size = 0;
    this._values = Object.create(null);
  };

  Cache.prototype.get = function (key) {
    return this._values[key];
  };

  Cache.prototype.set = function (key, value) {
    this._size >= this._maxSize && this.clear();
    if (!(key in this._values)) this._size++;
    return this._values[key] = value;
  };

  var SPLIT_REGEX = /[^.^\]^[]+|(?=\[\]|\.\.)/g,
      DIGIT_REGEX = /^\d+$/,
      LEAD_DIGIT_REGEX = /^\d/,
      SPEC_CHAR_REGEX = /[~`!#$%\^&*+=\-\[\]\\';,/{}|\\":<>\?]/g,
      CLEAN_QUOTES_REGEX = /^\s*(['"]?)(.*?)(\1)\s*$/,
      MAX_CACHE_SIZE = 512;
  var pathCache = new Cache(MAX_CACHE_SIZE),
      setCache = new Cache(MAX_CACHE_SIZE),
      getCache = new Cache(MAX_CACHE_SIZE);
  var propertyExpr = {
    Cache: Cache,
    split: split,
    normalizePath: normalizePath,
    setter: function setter(path) {
      var parts = normalizePath(path);
      return setCache.get(path) || setCache.set(path, function setter(obj, value) {
        var index = 0;
        var len = parts.length;
        var data = obj;

        while (index < len - 1) {
          var part = parts[index];

          if (part === '__proto__' || part === 'constructor' || part === 'prototype') {
            return obj;
          }

          data = data[parts[index++]];
        }

        data[parts[index]] = value;
      });
    },
    getter: function getter(path, safe) {
      var parts = normalizePath(path);
      return getCache.get(path) || getCache.set(path, function getter(data) {
        var index = 0,
            len = parts.length;

        while (index < len) {
          if (data != null || !safe) data = data[parts[index++]];else return;
        }

        return data;
      });
    },
    join: function join(segments) {
      return segments.reduce(function (path, part) {
        return path + (isQuoted(part) || DIGIT_REGEX.test(part) ? '[' + part + ']' : (path ? '.' : '') + part);
      }, '');
    },
    forEach: function forEach(path, cb, thisArg) {
      _forEach(Array.isArray(path) ? path : split(path), cb, thisArg);
    }
  };

  function normalizePath(path) {
    return pathCache.get(path) || pathCache.set(path, split(path).map(function (part) {
      return part.replace(CLEAN_QUOTES_REGEX, '$2');
    }));
  }

  function split(path) {
    return path.match(SPLIT_REGEX);
  }

  function _forEach(parts, iter, thisArg) {
    var len = parts.length,
        part,
        idx,
        isArray,
        isBracket;

    for (idx = 0; idx < len; idx++) {
      part = parts[idx];

      if (part) {
        if (shouldBeQuoted(part)) {
          part = '"' + part + '"';
        }

        isBracket = isQuoted(part);
        isArray = !isBracket && /^\d+$/.test(part);
        iter.call(thisArg, part, isBracket, isArray, idx, parts);
      }
    }
  }

  function isQuoted(str) {
    return typeof str === 'string' && str && ["'", '"'].indexOf(str.charAt(0)) !== -1;
  }

  function hasLeadingNumber(part) {
    return part.match(LEAD_DIGIT_REGEX) && !part.match(DIGIT_REGEX);
  }

  function hasSpecialChars(part) {
    return SPEC_CHAR_REGEX.test(part);
  }

  function shouldBeQuoted(part) {
    return !isQuoted(part) && (hasLeadingNumber(part) || hasSpecialChars(part));
  }

  var prefixes = {
    context: '$',
    value: '.'
  };

  var Reference = /*#__PURE__*/function () {
    function Reference(key, options) {
      if (options === void 0) {
        options = {};
      }

      if (typeof key !== 'string') throw new TypeError('ref must be a string, got: ' + key);
      this.key = key.trim();
      if (key === '') throw new TypeError('ref must be a non-empty string');
      this.isContext = this.key[0] === prefixes.context;
      this.isValue = this.key[0] === prefixes.value;
      this.isSibling = !this.isContext && !this.isValue;
      var prefix = this.isContext ? prefixes.context : this.isValue ? prefixes.value : '';
      this.path = this.key.slice(prefix.length);
      this.getter = this.path && propertyExpr.getter(this.path, true);
      this.map = options.map;
    }

    var _proto = Reference.prototype;

    _proto.getValue = function getValue(options) {
      var result = this.isContext ? options.context : this.isValue ? options.value : options.parent;
      if (this.getter) result = this.getter(result || {});
      if (this.map) result = this.map(result);
      return result;
    };

    _proto.cast = function cast(value, options) {
      return this.getValue(_extends({}, options, {
        value: value
      }));
    };

    _proto.resolve = function resolve() {
      return this;
    };

    _proto.describe = function describe() {
      return {
        type: 'ref',
        key: this.key
      };
    };

    _proto.toString = function toString() {
      return "Ref(" + this.key + ")";
    };

    Reference.isRef = function isRef(value) {
      return value && value.__isYupRef;
    };

    return Reference;
  }();
  Reference.prototype.__isYupRef = true;

  var formatError = ValidationError.formatError;

  var thenable = function thenable(p) {
    return p && typeof p.then === 'function' && typeof p["catch"] === 'function';
  };

  function runTest(testFn, ctx, value, sync) {
    var result = testFn.call(ctx, value);
    if (!sync) return Promise.resolve(result);

    if (thenable(result)) {
      throw new Error("Validation test of type: \"" + ctx.type + "\" returned a Promise during a synchronous validate. " + "This test will finish after the validate call has returned");
    }

    return synchronousPromise.SynchronousPromise.resolve(result);
  }

  function resolveParams(oldParams, newParams, resolve) {
    return mapValues(_extends({}, oldParams, {}, newParams), resolve);
  }

  function createErrorFactory(_ref) {
    var value = _ref.value,
        label = _ref.label,
        resolve = _ref.resolve,
        originalValue = _ref.originalValue,
        opts = _objectWithoutPropertiesLoose(_ref, ["value", "label", "resolve", "originalValue"]);

    return function createError(_temp) {
      var _ref2 = _temp === void 0 ? {} : _temp,
          _ref2$path = _ref2.path,
          path = _ref2$path === void 0 ? opts.path : _ref2$path,
          _ref2$message = _ref2.message,
          message = _ref2$message === void 0 ? opts.message : _ref2$message,
          _ref2$type = _ref2.type,
          type = _ref2$type === void 0 ? opts.name : _ref2$type,
          params = _ref2.params;

      params = _extends({
        path: path,
        value: value,
        originalValue: originalValue,
        label: label
      }, resolveParams(opts.params, params, resolve));
      return _extends(new ValidationError(formatError(message, params), value, path, type), {
        params: params
      });
    };
  }
  function createValidation(options) {
    var name = options.name,
        message = options.message,
        test = options.test,
        params = options.params;

    function validate(_ref3) {
      var value = _ref3.value,
          path = _ref3.path,
          label = _ref3.label,
          options = _ref3.options,
          originalValue = _ref3.originalValue,
          sync = _ref3.sync,
          rest = _objectWithoutPropertiesLoose(_ref3, ["value", "path", "label", "options", "originalValue", "sync"]);

      var parent = options.parent;

      var resolve = function resolve(item) {
        return Reference.isRef(item) ? item.getValue({
          value: value,
          parent: parent,
          context: options.context
        }) : item;
      };

      var createError = createErrorFactory({
        message: message,
        path: path,
        value: value,
        originalValue: originalValue,
        params: params,
        label: label,
        resolve: resolve,
        name: name
      });

      var ctx = _extends({
        path: path,
        parent: parent,
        type: name,
        createError: createError,
        resolve: resolve,
        options: options
      }, rest);

      return runTest(test, ctx, value, sync).then(function (validOrError) {
        if (ValidationError.isError(validOrError)) throw validOrError;else if (!validOrError) throw createError();
      });
    }

    validate.OPTIONS = options;
    return validate;
  }

  var trim = function trim(part) {
    return part.substr(0, part.length - 1).substr(1);
  };

  function getIn(schema, path, value, context) {
    if (context === void 0) {
      context = value;
    }

    var parent, lastPart, lastPartDebug; // root path: ''

    if (!path) return {
      parent: parent,
      parentPath: path,
      schema: schema
    };
    propertyExpr.forEach(path, function (_part, isBracket, isArray) {
      var part = isBracket ? trim(_part) : _part;
      schema = schema.resolve({
        context: context,
        parent: parent,
        value: value
      });

      if (schema.innerType) {
        var idx = isArray ? parseInt(part, 10) : 0;

        if (value && idx >= value.length) {
          throw new Error("Yup.reach cannot resolve an array item at index: " + _part + ", in the path: " + path + ". " + "because there is no value at that index. ");
        }

        parent = value;
        value = value && value[idx];
        schema = schema.innerType;
      } // sometimes the array index part of a path doesn't exist: "nested.arr.child"
      // in these cases the current part is the next schema and should be processed
      // in this iteration. For cases where the index signature is included this
      // check will fail and we'll handle the `child` part on the next iteration like normal


      if (!isArray) {
        if (!schema.fields || !schema.fields[part]) throw new Error("The schema does not contain the path: " + path + ". " + ("(failed at: " + lastPartDebug + " which is a type: \"" + schema._type + "\")"));
        parent = value;
        value = value && value[part];
        schema = schema.fields[part];
      }

      lastPart = part;
      lastPartDebug = isBracket ? '[' + _part + ']' : '.' + _part;
    });
    return {
      schema: schema,
      parent: parent,
      parentPath: lastPart
    };
  }

  var RefSet = /*#__PURE__*/function () {
    function RefSet() {
      this.list = new Set();
      this.refs = new Map();
    }

    var _proto = RefSet.prototype;

    _proto.toArray = function toArray$1() {
      return toArray(this.list).concat(toArray(this.refs.values()));
    };

    _proto.add = function add(value) {
      Reference.isRef(value) ? this.refs.set(value.key, value) : this.list.add(value);
    };

    _proto["delete"] = function _delete(value) {
      Reference.isRef(value) ? this.refs["delete"](value.key) : this.list["delete"](value);
    };

    _proto.has = function has(value, resolve) {
      if (this.list.has(value)) return true;
      var item,
          values = this.refs.values();

      while (item = values.next(), !item.done) {
        if (resolve(item.value) === value) return true;
      }

      return false;
    };

    _proto.clone = function clone() {
      var next = new RefSet();
      next.list = new Set(this.list);
      next.refs = new Map(this.refs);
      return next;
    };

    _proto.merge = function merge(newItems, removeItems) {
      var next = this.clone();
      newItems.list.forEach(function (value) {
        return next.add(value);
      });
      newItems.refs.forEach(function (value) {
        return next.add(value);
      });
      removeItems.list.forEach(function (value) {
        return next["delete"](value);
      });
      removeItems.refs.forEach(function (value) {
        return next["delete"](value);
      });
      return next;
    };

    return RefSet;
  }();

  function SchemaType(options) {
    var _this = this;

    if (options === void 0) {
      options = {};
    }

    if (!(this instanceof SchemaType)) return new SchemaType();
    this._deps = [];
    this._conditions = [];
    this._options = {
      abortEarly: true,
      recursive: true
    };
    this._exclusive = Object.create(null);
    this._whitelist = new RefSet();
    this._blacklist = new RefSet();
    this.tests = [];
    this.transforms = [];
    this.withMutation(function () {
      _this.typeError(mixed.notType);
    });
    if (has(options, 'default')) this._defaultDefault = options["default"];
    this.type = options.type || 'mixed'; // TODO: remove

    this._type = options.type || 'mixed';
  }
  var proto = SchemaType.prototype = {
    __isYupSchema__: true,
    constructor: SchemaType,
    clone: function clone() {
      var _this2 = this;

      if (this._mutate) return this; // if the nested value is a schema we can skip cloning, since
      // they are already immutable

      return cloneDeepWith(this, function (value) {
        if (isSchema(value) && value !== _this2) return value;
      });
    },
    label: function label(_label) {
      var next = this.clone();
      next._label = _label;
      return next;
    },
    meta: function meta(obj) {
      if (arguments.length === 0) return this._meta;
      var next = this.clone();
      next._meta = _extends(next._meta || {}, obj);
      return next;
    },
    withMutation: function withMutation(fn) {
      var before = this._mutate;
      this._mutate = true;
      var result = fn(this);
      this._mutate = before;
      return result;
    },
    concat: function concat(schema) {
      if (!schema || schema === this) return this;
      if (schema._type !== this._type && this._type !== 'mixed') throw new TypeError("You cannot `concat()` schema's of different types: " + this._type + " and " + schema._type);
      var next = prependDeep(schema.clone(), this); // new undefined default is overridden by old non-undefined one, revert

      if (has(schema, '_default')) next._default = schema._default;
      next.tests = this.tests;
      next._exclusive = this._exclusive; // manually merge the blacklist/whitelist (the other `schema` takes
      // precedence in case of conflicts)

      next._whitelist = this._whitelist.merge(schema._whitelist, schema._blacklist);
      next._blacklist = this._blacklist.merge(schema._blacklist, schema._whitelist); // manually add the new tests to ensure
      // the deduping logic is consistent

      next.withMutation(function (next) {
        schema.tests.forEach(function (fn) {
          next.test(fn.OPTIONS);
        });
      });
      return next;
    },
    isType: function isType(v) {
      if (this._nullable && v === null) return true;
      return !this._typeCheck || this._typeCheck(v);
    },
    resolve: function resolve(options) {
      var schema = this;

      if (schema._conditions.length) {
        var conditions = schema._conditions;
        schema = schema.clone();
        schema._conditions = [];
        schema = conditions.reduce(function (schema, condition) {
          return condition.resolve(schema, options);
        }, schema);
        schema = schema.resolve(options);
      }

      return schema;
    },
    cast: function cast(value, options) {
      if (options === void 0) {
        options = {};
      }

      var resolvedSchema = this.resolve(_extends({}, options, {
        value: value
      }));

      var result = resolvedSchema._cast(value, options);

      if (value !== undefined && options.assert !== false && resolvedSchema.isType(result) !== true) {
        var formattedValue = printValue(value);
        var formattedResult = printValue(result);
        throw new TypeError("The value of " + (options.path || 'field') + " could not be cast to a value " + ("that satisfies the schema type: \"" + resolvedSchema._type + "\". \n\n") + ("attempted value: " + formattedValue + " \n") + (formattedResult !== formattedValue ? "result of cast: " + formattedResult : ''));
      }

      return result;
    },
    _cast: function _cast(rawValue) {
      var _this3 = this;

      var value = rawValue === undefined ? rawValue : this.transforms.reduce(function (value, fn) {
        return fn.call(_this3, value, rawValue);
      }, rawValue);

      if (value === undefined && has(this, '_default')) {
        value = this["default"]();
      }

      return value;
    },
    _validate: function _validate(_value, options) {
      var _this4 = this;

      if (options === void 0) {
        options = {};
      }

      var value = _value;
      var originalValue = options.originalValue != null ? options.originalValue : _value;

      var isStrict = this._option('strict', options);

      var endEarly = this._option('abortEarly', options);

      var sync = options.sync;
      var path = options.path;
      var label = this._label;

      if (!isStrict) {
        value = this._cast(value, _extends({
          assert: false
        }, options));
      } // value is cast, we can check if it meets type requirements


      var validationParams = {
        value: value,
        path: path,
        schema: this,
        options: options,
        label: label,
        originalValue: originalValue,
        sync: sync
      };
      var initialTests = [];
      if (this._typeError) initialTests.push(this._typeError(validationParams));
      if (this._whitelistError) initialTests.push(this._whitelistError(validationParams));
      if (this._blacklistError) initialTests.push(this._blacklistError(validationParams));
      return runValidations({
        validations: initialTests,
        endEarly: endEarly,
        value: value,
        path: path,
        sync: sync
      }).then(function (value) {
        return runValidations({
          path: path,
          sync: sync,
          value: value,
          endEarly: endEarly,
          validations: _this4.tests.map(function (fn) {
            return fn(validationParams);
          })
        });
      });
    },
    validate: function validate(value, options) {
      if (options === void 0) {
        options = {};
      }

      var schema = this.resolve(_extends({}, options, {
        value: value
      }));
      return schema._validate(value, options);
    },
    validateSync: function validateSync(value, options) {
      if (options === void 0) {
        options = {};
      }

      var schema = this.resolve(_extends({}, options, {
        value: value
      }));
      var result, err;

      schema._validate(value, _extends({}, options, {
        sync: true
      })).then(function (r) {
        return result = r;
      })["catch"](function (e) {
        return err = e;
      });

      if (err) throw err;
      return result;
    },
    isValid: function isValid(value, options) {
      return this.validate(value, options).then(function () {
        return true;
      })["catch"](function (err) {
        if (err.name === 'ValidationError') return false;
        throw err;
      });
    },
    isValidSync: function isValidSync(value, options) {
      try {
        this.validateSync(value, options);
        return true;
      } catch (err) {
        if (err.name === 'ValidationError') return false;
        throw err;
      }
    },
    getDefault: function getDefault(options) {
      if (options === void 0) {
        options = {};
      }

      var schema = this.resolve(options);
      return schema["default"]();
    },
    "default": function _default(def) {
      if (arguments.length === 0) {
        var defaultValue = has(this, '_default') ? this._default : this._defaultDefault;
        return typeof defaultValue === 'function' ? defaultValue.call(this) : cloneDeepWith(defaultValue);
      }

      var next = this.clone();
      next._default = def;
      return next;
    },
    strict: function strict(isStrict) {
      if (isStrict === void 0) {
        isStrict = true;
      }

      var next = this.clone();
      next._options.strict = isStrict;
      return next;
    },
    _isPresent: function _isPresent(value) {
      return value != null;
    },
    required: function required(message) {
      if (message === void 0) {
        message = mixed.required;
      }

      return this.test({
        message: message,
        name: 'required',
        exclusive: true,
        test: function test(value) {
          return this.schema._isPresent(value);
        }
      });
    },
    notRequired: function notRequired() {
      var next = this.clone();
      next.tests = next.tests.filter(function (test) {
        return test.OPTIONS.name !== 'required';
      });
      return next;
    },
    nullable: function nullable(isNullable) {
      if (isNullable === void 0) {
        isNullable = true;
      }

      var next = this.clone();
      next._nullable = isNullable;
      return next;
    },
    transform: function transform(fn) {
      var next = this.clone();
      next.transforms.push(fn);
      return next;
    },

    /**
     * Adds a test function to the schema's queue of tests.
     * tests can be exclusive or non-exclusive.
     *
     * - exclusive tests, will replace any existing tests of the same name.
     * - non-exclusive: can be stacked
     *
     * If a non-exclusive test is added to a schema with an exclusive test of the same name
     * the exclusive test is removed and further tests of the same name will be stacked.
     *
     * If an exclusive test is added to a schema with non-exclusive tests of the same name
     * the previous tests are removed and further tests of the same name will replace each other.
     */
    test: function test() {
      var opts;

      if (arguments.length === 1) {
        if (typeof (arguments.length <= 0 ? undefined : arguments[0]) === 'function') {
          opts = {
            test: arguments.length <= 0 ? undefined : arguments[0]
          };
        } else {
          opts = arguments.length <= 0 ? undefined : arguments[0];
        }
      } else if (arguments.length === 2) {
        opts = {
          name: arguments.length <= 0 ? undefined : arguments[0],
          test: arguments.length <= 1 ? undefined : arguments[1]
        };
      } else {
        opts = {
          name: arguments.length <= 0 ? undefined : arguments[0],
          message: arguments.length <= 1 ? undefined : arguments[1],
          test: arguments.length <= 2 ? undefined : arguments[2]
        };
      }

      if (opts.message === undefined) opts.message = mixed["default"];
      if (typeof opts.test !== 'function') throw new TypeError('`test` is a required parameters');
      var next = this.clone();
      var validate = createValidation(opts);
      var isExclusive = opts.exclusive || opts.name && next._exclusive[opts.name] === true;

      if (opts.exclusive && !opts.name) {
        throw new TypeError('Exclusive tests must provide a unique `name` identifying the test');
      }

      next._exclusive[opts.name] = !!opts.exclusive;
      next.tests = next.tests.filter(function (fn) {
        if (fn.OPTIONS.name === opts.name) {
          if (isExclusive) return false;
          if (fn.OPTIONS.test === validate.OPTIONS.test) return false;
        }

        return true;
      });
      next.tests.push(validate);
      return next;
    },
    when: function when(keys, options) {
      if (arguments.length === 1) {
        options = keys;
        keys = '.';
      }

      var next = this.clone(),
          deps = [].concat(keys).map(function (key) {
        return new Reference(key);
      });
      deps.forEach(function (dep) {
        if (dep.isSibling) next._deps.push(dep.key);
      });

      next._conditions.push(new Condition(deps, options));

      return next;
    },
    typeError: function typeError(message) {
      var next = this.clone();
      next._typeError = createValidation({
        message: message,
        name: 'typeError',
        test: function test(value) {
          if (value !== undefined && !this.schema.isType(value)) return this.createError({
            params: {
              type: this.schema._type
            }
          });
          return true;
        }
      });
      return next;
    },
    oneOf: function oneOf(enums, message) {
      if (message === void 0) {
        message = mixed.oneOf;
      }

      var next = this.clone();
      enums.forEach(function (val) {
        next._whitelist.add(val);

        next._blacklist["delete"](val);
      });
      next._whitelistError = createValidation({
        message: message,
        name: 'oneOf',
        test: function test(value) {
          if (value === undefined) return true;
          var valids = this.schema._whitelist;
          return valids.has(value, this.resolve) ? true : this.createError({
            params: {
              values: valids.toArray().join(', ')
            }
          });
        }
      });
      return next;
    },
    notOneOf: function notOneOf(enums, message) {
      if (message === void 0) {
        message = mixed.notOneOf;
      }

      var next = this.clone();
      enums.forEach(function (val) {
        next._blacklist.add(val);

        next._whitelist["delete"](val);
      });
      next._blacklistError = createValidation({
        message: message,
        name: 'notOneOf',
        test: function test(value) {
          var invalids = this.schema._blacklist;
          if (invalids.has(value, this.resolve)) return this.createError({
            params: {
              values: invalids.toArray().join(', ')
            }
          });
          return true;
        }
      });
      return next;
    },
    strip: function strip(_strip) {
      if (_strip === void 0) {
        _strip = true;
      }

      var next = this.clone();
      next._strip = _strip;
      return next;
    },
    _option: function _option(key, overrides) {
      return has(overrides, key) ? overrides[key] : this._options[key];
    },
    describe: function describe() {
      var next = this.clone();
      return {
        type: next._type,
        meta: next._meta,
        label: next._label,
        tests: next.tests.map(function (fn) {
          return {
            name: fn.OPTIONS.name,
            params: fn.OPTIONS.params
          };
        }).filter(function (n, idx, list) {
          return list.findIndex(function (c) {
            return c.name === n.name;
          }) === idx;
        })
      };
    },
    defined: function defined(message) {
      if (message === void 0) {
        message = mixed.defined;
      }

      return this.nullable().test({
        message: message,
        name: 'defined',
        exclusive: true,
        test: function test(value) {
          return value !== undefined;
        }
      });
    }
  };

  var _loop = function _loop() {
    var method = _arr[_i];

    proto[method + "At"] = function (path, value, options) {
      if (options === void 0) {
        options = {};
      }

      var _getIn = getIn(this, path, value, options.context),
          parent = _getIn.parent,
          parentPath = _getIn.parentPath,
          schema = _getIn.schema;

      return schema[method](parent && parent[parentPath], _extends({}, options, {
        parent: parent,
        path: path
      }));
    };
  };

  for (var _i = 0, _arr = ['validate', 'validateSync']; _i < _arr.length; _i++) {
    _loop();
  }

  for (var _i2 = 0, _arr2 = ['equals', 'is']; _i2 < _arr2.length; _i2++) {
    var alias = _arr2[_i2];
    proto[alias] = proto.oneOf;
  }

  for (var _i3 = 0, _arr3 = ['not', 'nope']; _i3 < _arr3.length; _i3++) {
    var _alias = _arr3[_i3];
    proto[_alias] = proto.notOneOf;
  }

  proto.optional = proto.notRequired;

  function inherits(ctor, superCtor, spec) {
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });

    _extends(ctor.prototype, spec);
  }

  function BooleanSchema() {
    var _this = this;

    if (!(this instanceof BooleanSchema)) return new BooleanSchema();
    SchemaType.call(this, {
      type: 'boolean'
    });
    this.withMutation(function () {
      _this.transform(function (value) {
        if (!this.isType(value)) {
          if (/^(true|1)$/i.test(value)) return true;
          if (/^(false|0)$/i.test(value)) return false;
        }

        return value;
      });
    });
  }

  inherits(BooleanSchema, SchemaType, {
    _typeCheck: function _typeCheck(v) {
      if (v instanceof Boolean) v = v.valueOf();
      return typeof v === 'boolean';
    }
  });

  var isAbsent = (function (value) {
    return value == null;
  });

  var rEmail = /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))$/i; // eslint-disable-next-line

  var rUrl = /^((https?|ftp):)?\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(\#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i;

  var isTrimmed = function isTrimmed(value) {
    return isAbsent(value) || value === value.trim();
  };

  function StringSchema() {
    var _this = this;

    if (!(this instanceof StringSchema)) return new StringSchema();
    SchemaType.call(this, {
      type: 'string'
    });
    this.withMutation(function () {
      _this.transform(function (value) {
        if (this.isType(value)) return value;
        return value != null && value.toString ? value.toString() : value;
      });
    });
  }
  inherits(StringSchema, SchemaType, {
    _typeCheck: function _typeCheck(value) {
      if (value instanceof String) value = value.valueOf();
      return typeof value === 'string';
    },
    _isPresent: function _isPresent(value) {
      return SchemaType.prototype._cast.call(this, value) && value.length > 0;
    },
    length: function length(_length, message) {
      if (message === void 0) {
        message = string.length;
      }

      return this.test({
        message: message,
        name: 'length',
        exclusive: true,
        params: {
          length: _length
        },
        test: function test(value) {
          return isAbsent(value) || value.length === this.resolve(_length);
        }
      });
    },
    min: function min(_min, message) {
      if (message === void 0) {
        message = string.min;
      }

      return this.test({
        message: message,
        name: 'min',
        exclusive: true,
        params: {
          min: _min
        },
        test: function test(value) {
          return isAbsent(value) || value.length >= this.resolve(_min);
        }
      });
    },
    max: function max(_max, message) {
      if (message === void 0) {
        message = string.max;
      }

      return this.test({
        name: 'max',
        exclusive: true,
        message: message,
        params: {
          max: _max
        },
        test: function test(value) {
          return isAbsent(value) || value.length <= this.resolve(_max);
        }
      });
    },
    matches: function matches(regex, options) {
      var excludeEmptyString = false;
      var message;
      var name;

      if (options) {
        if (_typeof(options) === 'object') {
          excludeEmptyString = options.excludeEmptyString;
          message = options.message;
          name = options.name;
        } else {
          message = options;
        }
      }

      return this.test({
        name: name || 'matches',
        message: message || string.matches,
        params: {
          regex: regex
        },
        test: function test(value) {
          return isAbsent(value) || value === '' && excludeEmptyString || value.search(regex) !== -1;
        }
      });
    },
    email: function email(message) {
      if (message === void 0) {
        message = string.email;
      }

      return this.matches(rEmail, {
        name: 'email',
        message: message,
        excludeEmptyString: true
      });
    },
    url: function url(message) {
      if (message === void 0) {
        message = string.url;
      }

      return this.matches(rUrl, {
        name: 'url',
        message: message,
        excludeEmptyString: true
      });
    },
    //-- transforms --
    ensure: function ensure() {
      return this["default"]('').transform(function (val) {
        return val === null ? '' : val;
      });
    },
    trim: function trim(message) {
      if (message === void 0) {
        message = string.trim;
      }

      return this.transform(function (val) {
        return val != null ? val.trim() : val;
      }).test({
        message: message,
        name: 'trim',
        test: isTrimmed
      });
    },
    lowercase: function lowercase(message) {
      if (message === void 0) {
        message = string.lowercase;
      }

      return this.transform(function (value) {
        return !isAbsent(value) ? value.toLowerCase() : value;
      }).test({
        message: message,
        name: 'string_case',
        exclusive: true,
        test: function test(value) {
          return isAbsent(value) || value === value.toLowerCase();
        }
      });
    },
    uppercase: function uppercase(message) {
      if (message === void 0) {
        message = string.uppercase;
      }

      return this.transform(function (value) {
        return !isAbsent(value) ? value.toUpperCase() : value;
      }).test({
        message: message,
        name: 'string_case',
        exclusive: true,
        test: function test(value) {
          return isAbsent(value) || value === value.toUpperCase();
        }
      });
    }
  });

  var isNaN$1 = function isNaN(value) {
    return value != +value;
  };

  function NumberSchema() {
    var _this = this;

    if (!(this instanceof NumberSchema)) return new NumberSchema();
    SchemaType.call(this, {
      type: 'number'
    });
    this.withMutation(function () {
      _this.transform(function (value) {
        var parsed = value;

        if (typeof parsed === 'string') {
          parsed = parsed.replace(/\s/g, '');
          if (parsed === '') return NaN; // don't use parseFloat to avoid positives on alpha-numeric strings

          parsed = +parsed;
        }

        if (this.isType(parsed)) return parsed;
        return parseFloat(parsed);
      });
    });
  }
  inherits(NumberSchema, SchemaType, {
    _typeCheck: function _typeCheck(value) {
      if (value instanceof Number) value = value.valueOf();
      return typeof value === 'number' && !isNaN$1(value);
    },
    min: function min(_min, message) {
      if (message === void 0) {
        message = number.min;
      }

      return this.test({
        message: message,
        name: 'min',
        exclusive: true,
        params: {
          min: _min
        },
        test: function test(value) {
          return isAbsent(value) || value >= this.resolve(_min);
        }
      });
    },
    max: function max(_max, message) {
      if (message === void 0) {
        message = number.max;
      }

      return this.test({
        message: message,
        name: 'max',
        exclusive: true,
        params: {
          max: _max
        },
        test: function test(value) {
          return isAbsent(value) || value <= this.resolve(_max);
        }
      });
    },
    lessThan: function lessThan(less, message) {
      if (message === void 0) {
        message = number.lessThan;
      }

      return this.test({
        message: message,
        name: 'max',
        exclusive: true,
        params: {
          less: less
        },
        test: function test(value) {
          return isAbsent(value) || value < this.resolve(less);
        }
      });
    },
    moreThan: function moreThan(more, message) {
      if (message === void 0) {
        message = number.moreThan;
      }

      return this.test({
        message: message,
        name: 'min',
        exclusive: true,
        params: {
          more: more
        },
        test: function test(value) {
          return isAbsent(value) || value > this.resolve(more);
        }
      });
    },
    positive: function positive(msg) {
      if (msg === void 0) {
        msg = number.positive;
      }

      return this.moreThan(0, msg);
    },
    negative: function negative(msg) {
      if (msg === void 0) {
        msg = number.negative;
      }

      return this.lessThan(0, msg);
    },
    integer: function integer(message) {
      if (message === void 0) {
        message = number.integer;
      }

      return this.test({
        name: 'integer',
        message: message,
        test: function test(val) {
          return isAbsent(val) || Number.isInteger(val);
        }
      });
    },
    truncate: function truncate() {
      return this.transform(function (value) {
        return !isAbsent(value) ? value | 0 : value;
      });
    },
    round: function round(method) {
      var avail = ['ceil', 'floor', 'round', 'trunc'];
      method = method && method.toLowerCase() || 'round'; // this exists for symemtry with the new Math.trunc

      if (method === 'trunc') return this.truncate();
      if (avail.indexOf(method.toLowerCase()) === -1) throw new TypeError('Only valid options for round() are: ' + avail.join(', '));
      return this.transform(function (value) {
        return !isAbsent(value) ? Math[method](value) : value;
      });
    }
  });

  /* eslint-disable */

  /**
   *
   * Date.parse with progressive enhancement for ISO 8601 <https://github.com/csnover/js-iso8601>
   * NON-CONFORMANT EDITION.
   * © 2011 Colin Snover <http://zetafleet.com>
   * Released under MIT license.
   */
  //              1 YYYY                 2 MM        3 DD              4 HH     5 mm        6 ss            7 msec         8 Z 9 ±    10 tzHH    11 tzmm
  var isoReg = /^(\d{4}|[+\-]\d{6})(?:-?(\d{2})(?:-?(\d{2}))?)?(?:[ T]?(\d{2}):?(\d{2})(?::?(\d{2})(?:[,\.](\d{1,}))?)?(?:(Z)|([+\-])(\d{2})(?::?(\d{2}))?)?)?$/;
  function parseIsoDate(date) {
    var numericKeys = [1, 4, 5, 6, 7, 10, 11],
        minutesOffset = 0,
        timestamp,
        struct;

    if (struct = isoReg.exec(date)) {
      // avoid NaN timestamps caused by “undefined” values being passed to Date.UTC
      for (var i = 0, k; k = numericKeys[i]; ++i) {
        struct[k] = +struct[k] || 0;
      } // allow undefined days and months


      struct[2] = (+struct[2] || 1) - 1;
      struct[3] = +struct[3] || 1; // allow arbitrary sub-second precision beyond milliseconds

      struct[7] = struct[7] ? String(struct[7]).substr(0, 3) : 0; // timestamps without timezone identifiers should be considered local time

      if ((struct[8] === undefined || struct[8] === '') && (struct[9] === undefined || struct[9] === '')) timestamp = +new Date(struct[1], struct[2], struct[3], struct[4], struct[5], struct[6], struct[7]);else {
        if (struct[8] !== 'Z' && struct[9] !== undefined) {
          minutesOffset = struct[10] * 60 + struct[11];
          if (struct[9] === '+') minutesOffset = 0 - minutesOffset;
        }

        timestamp = Date.UTC(struct[1], struct[2], struct[3], struct[4], struct[5] + minutesOffset, struct[6], struct[7]);
      }
    } else timestamp = Date.parse ? Date.parse(date) : NaN;

    return timestamp;
  }

  var invalidDate = new Date('');

  var isDate = function isDate(obj) {
    return Object.prototype.toString.call(obj) === '[object Date]';
  };

  function DateSchema() {
    var _this = this;

    if (!(this instanceof DateSchema)) return new DateSchema();
    SchemaType.call(this, {
      type: 'date'
    });
    this.withMutation(function () {
      _this.transform(function (value) {
        if (this.isType(value)) return value;
        value = parseIsoDate(value); // 0 is a valid timestamp equivalent to 1970-01-01T00:00:00Z(unix epoch) or before.

        return !isNaN(value) ? new Date(value) : invalidDate;
      });
    });
  }

  inherits(DateSchema, SchemaType, {
    _typeCheck: function _typeCheck(v) {
      return isDate(v) && !isNaN(v.getTime());
    },
    min: function min(_min, message) {
      if (message === void 0) {
        message = date.min;
      }

      var limit = _min;

      if (!Reference.isRef(limit)) {
        limit = this.cast(_min);
        if (!this._typeCheck(limit)) throw new TypeError('`min` must be a Date or a value that can be `cast()` to a Date');
      }

      return this.test({
        message: message,
        name: 'min',
        exclusive: true,
        params: {
          min: _min
        },
        test: function test(value) {
          return isAbsent(value) || value >= this.resolve(limit);
        }
      });
    },
    max: function max(_max, message) {
      if (message === void 0) {
        message = date.max;
      }

      var limit = _max;

      if (!Reference.isRef(limit)) {
        limit = this.cast(_max);
        if (!this._typeCheck(limit)) throw new TypeError('`max` must be a Date or a value that can be `cast()` to a Date');
      }

      return this.test({
        message: message,
        name: 'max',
        exclusive: true,
        params: {
          max: _max
        },
        test: function test(value) {
          return isAbsent(value) || value <= this.resolve(limit);
        }
      });
    }
  });

  function _taggedTemplateLiteralLoose(strings, raw) {
    if (!raw) {
      raw = strings.slice(0);
    }

    strings.raw = raw;
    return strings;
  }

  /**
   * A specialized version of `_.reduce` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the first element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */
  function arrayReduce(array, iteratee, accumulator, initAccum) {
    var index = -1,
        length = array == null ? 0 : array.length;

    if (initAccum && length) {
      accumulator = array[++index];
    }

    while (++index < length) {
      accumulator = iteratee(accumulator, array[index], index, array);
    }

    return accumulator;
  }

  /**
   * The base implementation of `_.propertyOf` without support for deep paths.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Function} Returns the new accessor function.
   */
  function basePropertyOf(object) {
    return function (key) {
      return object == null ? undefined : object[key];
    };
  }

  /** Used to map Latin Unicode letters to basic Latin letters. */

  var deburredLetters = {
    // Latin-1 Supplement block.
    '\xc0': 'A',
    '\xc1': 'A',
    '\xc2': 'A',
    '\xc3': 'A',
    '\xc4': 'A',
    '\xc5': 'A',
    '\xe0': 'a',
    '\xe1': 'a',
    '\xe2': 'a',
    '\xe3': 'a',
    '\xe4': 'a',
    '\xe5': 'a',
    '\xc7': 'C',
    '\xe7': 'c',
    '\xd0': 'D',
    '\xf0': 'd',
    '\xc8': 'E',
    '\xc9': 'E',
    '\xca': 'E',
    '\xcb': 'E',
    '\xe8': 'e',
    '\xe9': 'e',
    '\xea': 'e',
    '\xeb': 'e',
    '\xcc': 'I',
    '\xcd': 'I',
    '\xce': 'I',
    '\xcf': 'I',
    '\xec': 'i',
    '\xed': 'i',
    '\xee': 'i',
    '\xef': 'i',
    '\xd1': 'N',
    '\xf1': 'n',
    '\xd2': 'O',
    '\xd3': 'O',
    '\xd4': 'O',
    '\xd5': 'O',
    '\xd6': 'O',
    '\xd8': 'O',
    '\xf2': 'o',
    '\xf3': 'o',
    '\xf4': 'o',
    '\xf5': 'o',
    '\xf6': 'o',
    '\xf8': 'o',
    '\xd9': 'U',
    '\xda': 'U',
    '\xdb': 'U',
    '\xdc': 'U',
    '\xf9': 'u',
    '\xfa': 'u',
    '\xfb': 'u',
    '\xfc': 'u',
    '\xdd': 'Y',
    '\xfd': 'y',
    '\xff': 'y',
    '\xc6': 'Ae',
    '\xe6': 'ae',
    '\xde': 'Th',
    '\xfe': 'th',
    '\xdf': 'ss',
    // Latin Extended-A block.
    "\u0100": 'A',
    "\u0102": 'A',
    "\u0104": 'A',
    "\u0101": 'a',
    "\u0103": 'a',
    "\u0105": 'a',
    "\u0106": 'C',
    "\u0108": 'C',
    "\u010A": 'C',
    "\u010C": 'C',
    "\u0107": 'c',
    "\u0109": 'c',
    "\u010B": 'c',
    "\u010D": 'c',
    "\u010E": 'D',
    "\u0110": 'D',
    "\u010F": 'd',
    "\u0111": 'd',
    "\u0112": 'E',
    "\u0114": 'E',
    "\u0116": 'E',
    "\u0118": 'E',
    "\u011A": 'E',
    "\u0113": 'e',
    "\u0115": 'e',
    "\u0117": 'e',
    "\u0119": 'e',
    "\u011B": 'e',
    "\u011C": 'G',
    "\u011E": 'G',
    "\u0120": 'G',
    "\u0122": 'G',
    "\u011D": 'g',
    "\u011F": 'g',
    "\u0121": 'g',
    "\u0123": 'g',
    "\u0124": 'H',
    "\u0126": 'H',
    "\u0125": 'h',
    "\u0127": 'h',
    "\u0128": 'I',
    "\u012A": 'I',
    "\u012C": 'I',
    "\u012E": 'I',
    "\u0130": 'I',
    "\u0129": 'i',
    "\u012B": 'i',
    "\u012D": 'i',
    "\u012F": 'i',
    "\u0131": 'i',
    "\u0134": 'J',
    "\u0135": 'j',
    "\u0136": 'K',
    "\u0137": 'k',
    "\u0138": 'k',
    "\u0139": 'L',
    "\u013B": 'L',
    "\u013D": 'L',
    "\u013F": 'L',
    "\u0141": 'L',
    "\u013A": 'l',
    "\u013C": 'l',
    "\u013E": 'l',
    "\u0140": 'l',
    "\u0142": 'l',
    "\u0143": 'N',
    "\u0145": 'N',
    "\u0147": 'N',
    "\u014A": 'N',
    "\u0144": 'n',
    "\u0146": 'n',
    "\u0148": 'n',
    "\u014B": 'n',
    "\u014C": 'O',
    "\u014E": 'O',
    "\u0150": 'O',
    "\u014D": 'o',
    "\u014F": 'o',
    "\u0151": 'o',
    "\u0154": 'R',
    "\u0156": 'R',
    "\u0158": 'R',
    "\u0155": 'r',
    "\u0157": 'r',
    "\u0159": 'r',
    "\u015A": 'S',
    "\u015C": 'S',
    "\u015E": 'S',
    "\u0160": 'S',
    "\u015B": 's',
    "\u015D": 's',
    "\u015F": 's',
    "\u0161": 's',
    "\u0162": 'T',
    "\u0164": 'T',
    "\u0166": 'T',
    "\u0163": 't',
    "\u0165": 't',
    "\u0167": 't',
    "\u0168": 'U',
    "\u016A": 'U',
    "\u016C": 'U',
    "\u016E": 'U',
    "\u0170": 'U',
    "\u0172": 'U',
    "\u0169": 'u',
    "\u016B": 'u',
    "\u016D": 'u',
    "\u016F": 'u',
    "\u0171": 'u',
    "\u0173": 'u',
    "\u0174": 'W',
    "\u0175": 'w',
    "\u0176": 'Y',
    "\u0177": 'y',
    "\u0178": 'Y',
    "\u0179": 'Z',
    "\u017B": 'Z',
    "\u017D": 'Z',
    "\u017A": 'z',
    "\u017C": 'z',
    "\u017E": 'z',
    "\u0132": 'IJ',
    "\u0133": 'ij',
    "\u0152": 'Oe',
    "\u0153": 'oe',
    "\u0149": "'n",
    "\u017F": 's'
  };
  /**
   * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
   * letters to basic Latin letters.
   *
   * @private
   * @param {string} letter The matched letter to deburr.
   * @returns {string} Returns the deburred letter.
   */

  var deburrLetter = basePropertyOf(deburredLetters);

  /** Used to match Latin Unicode letters (excluding mathematical operators). */

  var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
  /** Used to compose unicode character classes. */

  var rsComboMarksRange$1 = "\\u0300-\\u036f",
      reComboHalfMarksRange$1 = "\\ufe20-\\ufe2f",
      rsComboSymbolsRange$1 = "\\u20d0-\\u20ff",
      rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1;
  /** Used to compose unicode capture groups. */

  var rsCombo$1 = '[' + rsComboRange$1 + ']';
  /**
   * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
   * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
   */

  var reComboMark = RegExp(rsCombo$1, 'g');
  /**
   * Deburrs `string` by converting
   * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
   * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
   * letters to basic Latin letters and removing
   * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category String
   * @param {string} [string=''] The string to deburr.
   * @returns {string} Returns the deburred string.
   * @example
   *
   * _.deburr('déjà vu');
   * // => 'deja vu'
   */

  function deburr(string) {
    string = toString$1(string);
    return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');
  }

  /** Used to match words composed of alphanumeric characters. */
  var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
  /**
   * Splits an ASCII `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */

  function asciiWords(string) {
    return string.match(reAsciiWord) || [];
  }

  /** Used to detect strings that need a more robust regexp to match words. */
  var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
  /**
   * Checks if `string` contains a word composed of Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a word is found, else `false`.
   */

  function hasUnicodeWord(string) {
    return reHasUnicodeWord.test(string);
  }

  /** Used to compose unicode character classes. */
  var rsAstralRange = "\\ud800-\\udfff",
      rsComboMarksRange = "\\u0300-\\u036f",
      reComboHalfMarksRange = "\\ufe20-\\ufe2f",
      rsComboSymbolsRange = "\\u20d0-\\u20ff",
      rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
      rsDingbatRange = "\\u2700-\\u27bf",
      rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
      rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
      rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
      rsPunctuationRange = "\\u2000-\\u206f",
      rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000",
      rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
      rsVarRange = "\\ufe0e\\ufe0f",
      rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
  /** Used to compose unicode capture groups. */

  var rsApos$1 = "['\u2019]",
      rsBreak = '[' + rsBreakRange + ']',
      rsCombo = '[' + rsComboRange + ']',
      rsDigits = '\\d+',
      rsDingbat = '[' + rsDingbatRange + ']',
      rsLower = '[' + rsLowerRange + ']',
      rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
      rsFitz = "\\ud83c[\\udffb-\\udfff]",
      rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
      rsNonAstral = '[^' + rsAstralRange + ']',
      rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}",
      rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]",
      rsUpper = '[' + rsUpperRange + ']',
      rsZWJ = "\\u200d";
  /** Used to compose unicode regexes. */

  var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',
      rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',
      rsOptContrLower = '(?:' + rsApos$1 + '(?:d|ll|m|re|s|t|ve))?',
      rsOptContrUpper = '(?:' + rsApos$1 + '(?:D|LL|M|RE|S|T|VE))?',
      reOptMod = rsModifier + '?',
      rsOptVar = '[' + rsVarRange + ']?',
      rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
      rsOrdLower = '\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',
      rsOrdUpper = '\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',
      rsSeq = rsOptVar + reOptMod + rsOptJoin,
      rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq;
  /** Used to match complex or compound words. */

  var reUnicodeWord = RegExp([rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')', rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')', rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower, rsUpper + '+' + rsOptContrUpper, rsOrdUpper, rsOrdLower, rsDigits, rsEmoji].join('|'), 'g');
  /**
   * Splits a Unicode `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */

  function unicodeWords(string) {
    return string.match(reUnicodeWord) || [];
  }

  /**
   * Splits `string` into an array of its words.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category String
   * @param {string} [string=''] The string to inspect.
   * @param {RegExp|string} [pattern] The pattern to match words.
   * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
   * @returns {Array} Returns the words of `string`.
   * @example
   *
   * _.words('fred, barney, & pebbles');
   * // => ['fred', 'barney', 'pebbles']
   *
   * _.words('fred, barney, & pebbles', /[^, ]+/g);
   * // => ['fred', 'barney', '&', 'pebbles']
   */

  function words(string, pattern, guard) {
    string = toString$1(string);
    pattern = guard ? undefined : pattern;

    if (pattern === undefined) {
      return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
    }

    return string.match(pattern) || [];
  }

  /** Used to compose unicode capture groups. */

  var rsApos = "['\u2019]";
  /** Used to match apostrophes. */

  var reApos = RegExp(rsApos, 'g');
  /**
   * Creates a function like `_.camelCase`.
   *
   * @private
   * @param {Function} callback The function to combine each word.
   * @returns {Function} Returns the new compounder function.
   */

  function createCompounder(callback) {
    return function (string) {
      return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
    };
  }

  /**
   * Converts `string` to
   * [snake case](https://en.wikipedia.org/wiki/Snake_case).
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category String
   * @param {string} [string=''] The string to convert.
   * @returns {string} Returns the snake cased string.
   * @example
   *
   * _.snakeCase('Foo Bar');
   * // => 'foo_bar'
   *
   * _.snakeCase('fooBar');
   * // => 'foo_bar'
   *
   * _.snakeCase('--FOO-BAR--');
   * // => 'foo_bar'
   */

  var snakeCase = createCompounder(function (result, word, index) {
    return result + (index ? '_' : '') + word.toLowerCase();
  });

  /**
   * The base implementation of `_.slice` without an iteratee call guard.
   *
   * @private
   * @param {Array} array The array to slice.
   * @param {number} [start=0] The start position.
   * @param {number} [end=array.length] The end position.
   * @returns {Array} Returns the slice of `array`.
   */
  function baseSlice(array, start, end) {
    var index = -1,
        length = array.length;

    if (start < 0) {
      start = -start > length ? 0 : length + start;
    }

    end = end > length ? length : end;

    if (end < 0) {
      end += length;
    }

    length = start > end ? 0 : end - start >>> 0;
    start >>>= 0;
    var result = Array(length);

    while (++index < length) {
      result[index] = array[index + start];
    }

    return result;
  }

  /**
   * Casts `array` to a slice if it's needed.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {number} start The start position.
   * @param {number} [end=array.length] The end position.
   * @returns {Array} Returns the cast slice.
   */

  function castSlice(array, start, end) {
    var length = array.length;
    end = end === undefined ? length : end;
    return !start && end >= length ? array : baseSlice(array, start, end);
  }

  /**
   * Creates a function like `_.lowerFirst`.
   *
   * @private
   * @param {string} methodName The name of the `String` case method to use.
   * @returns {Function} Returns the new case function.
   */

  function createCaseFirst(methodName) {
    return function (string) {
      string = toString$1(string);
      var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined;
      var chr = strSymbols ? strSymbols[0] : string.charAt(0);
      var trailing = strSymbols ? castSlice(strSymbols, 1).join('') : string.slice(1);
      return chr[methodName]() + trailing;
    };
  }

  /**
   * Converts the first character of `string` to upper case.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category String
   * @param {string} [string=''] The string to convert.
   * @returns {string} Returns the converted string.
   * @example
   *
   * _.upperFirst('fred');
   * // => 'Fred'
   *
   * _.upperFirst('FRED');
   * // => 'FRED'
   */

  var upperFirst = createCaseFirst('toUpperCase');

  /**
   * Converts the first character of `string` to upper case and the remaining
   * to lower case.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category String
   * @param {string} [string=''] The string to capitalize.
   * @returns {string} Returns the capitalized string.
   * @example
   *
   * _.capitalize('FRED');
   * // => 'Fred'
   */

  function capitalize(string) {
    return upperFirst(toString$1(string).toLowerCase());
  }

  /**
   * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category String
   * @param {string} [string=''] The string to convert.
   * @returns {string} Returns the camel cased string.
   * @example
   *
   * _.camelCase('Foo Bar');
   * // => 'fooBar'
   *
   * _.camelCase('--foo-bar--');
   * // => 'fooBar'
   *
   * _.camelCase('__FOO_BAR__');
   * // => 'fooBar'
   */

  var camelCase = createCompounder(function (result, word, index) {
    word = word.toLowerCase();
    return result + (index ? capitalize(word) : word);
  });

  /**
   * The opposite of `_.mapValues`; this method creates an object with the
   * same values as `object` and keys generated by running each own enumerable
   * string keyed property of `object` thru `iteratee`. The iteratee is invoked
   * with three arguments: (value, key, object).
   *
   * @static
   * @memberOf _
   * @since 3.8.0
   * @category Object
   * @param {Object} object The object to iterate over.
   * @param {Function} [iteratee=_.identity] The function invoked per iteration.
   * @returns {Object} Returns the new mapped object.
   * @see _.mapValues
   * @example
   *
   * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
   *   return key + value;
   * });
   * // => { 'a1': 1, 'b2': 2 }
   */

  function mapKeys(object, iteratee) {
    var result = {};
    iteratee = baseIteratee(iteratee);
    baseForOwn(object, function (value, key, object) {
      baseAssignValue(result, iteratee(value, key, object), value);
    });
    return result;
  }

  /**
   * Topological sorting function
   *
   * @param {Array} edges
   * @returns {Array}
   */
  var toposort_1 = function (edges) {
    return toposort(uniqueNodes(edges), edges);
  };

  var array = toposort;

  function toposort(nodes, edges) {
    var cursor = nodes.length,
        sorted = new Array(cursor),
        visited = {},
        i = cursor // Better data structures make algorithm much faster.
    ,
        outgoingEdges = makeOutgoingEdges(edges),
        nodesHash = makeNodesHash(nodes); // check for unknown nodes

    edges.forEach(function (edge) {
      if (!nodesHash.has(edge[0]) || !nodesHash.has(edge[1])) {
        throw new Error('Unknown node. There is an unknown node in the supplied edges.');
      }
    });

    while (i--) {
      if (!visited[i]) visit(nodes[i], i, new Set());
    }

    return sorted;

    function visit(node, i, predecessors) {
      if (predecessors.has(node)) {
        var nodeRep;

        try {
          nodeRep = ", node was:" + JSON.stringify(node);
        } catch (e) {
          nodeRep = "";
        }

        throw new Error('Cyclic dependency' + nodeRep);
      }

      if (!nodesHash.has(node)) {
        throw new Error('Found unknown node. Make sure to provided all involved nodes. Unknown node: ' + JSON.stringify(node));
      }

      if (visited[i]) return;
      visited[i] = true;
      var outgoing = outgoingEdges.get(node) || new Set();
      outgoing = Array.from(outgoing);

      if (i = outgoing.length) {
        predecessors.add(node);

        do {
          var child = outgoing[--i];
          visit(child, nodesHash.get(child), predecessors);
        } while (i);

        predecessors["delete"](node);
      }

      sorted[--cursor] = node;
    }
  }

  function uniqueNodes(arr) {
    var res = new Set();

    for (var i = 0, len = arr.length; i < len; i++) {
      var edge = arr[i];
      res.add(edge[0]);
      res.add(edge[1]);
    }

    return Array.from(res);
  }

  function makeOutgoingEdges(arr) {
    var edges = new Map();

    for (var i = 0, len = arr.length; i < len; i++) {
      var edge = arr[i];
      if (!edges.has(edge[0])) edges.set(edge[0], new Set());
      if (!edges.has(edge[1])) edges.set(edge[1], new Set());
      edges.get(edge[0]).add(edge[1]);
    }

    return edges;
  }

  function makeNodesHash(arr) {
    var res = new Map();

    for (var i = 0, len = arr.length; i < len; i++) {
      res.set(arr[i], i);
    }

    return res;
  }
  toposort_1.array = array;

  function sortFields(fields, excludes) {
    if (excludes === void 0) {
      excludes = [];
    }

    var edges = [],
        nodes = [];

    function addNode(depPath, key) {
      var node = propertyExpr.split(depPath)[0];
      if (!~nodes.indexOf(node)) nodes.push(node);
      if (!~excludes.indexOf(key + "-" + node)) edges.push([key, node]);
    }

    for (var key in fields) {
      if (has(fields, key)) {
        var value = fields[key];
        if (!~nodes.indexOf(key)) nodes.push(key);
        if (Reference.isRef(value) && value.isSibling) addNode(value.path, key);else if (isSchema(value) && value._deps) value._deps.forEach(function (path) {
          return addNode(path, key);
        });
      }
    }

    return toposort_1.array(nodes, edges).reverse();
  }

  function findIndex(arr, err) {
    var idx = Infinity;
    arr.some(function (key, ii) {
      if (err.path.indexOf(key) !== -1) {
        idx = ii;
        return true;
      }
    });
    return idx;
  }

  function sortByKeyOrder(fields) {
    var keys = Object.keys(fields);
    return function (a, b) {
      return findIndex(keys, a) - findIndex(keys, b);
    };
  }

  function makePath(strings) {
    for (var _len = arguments.length, values = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      values[_key - 1] = arguments[_key];
    }

    var path = strings.reduce(function (str, next) {
      var value = values.shift();
      return str + (value == null ? '' : value) + next;
    });
    return path.replace(/^\./, '');
  }

  function _templateObject3() {
    var data = _taggedTemplateLiteralLoose(["", "[\"", "\"]"]);

    _templateObject3 = function _templateObject3() {
      return data;
    };

    return data;
  }

  function _templateObject2$1() {
    var data = _taggedTemplateLiteralLoose(["", ".", ""]);

    _templateObject2$1 = function _templateObject2() {
      return data;
    };

    return data;
  }

  function _templateObject$1() {
    var data = _taggedTemplateLiteralLoose(["", ".", ""]);

    _templateObject$1 = function _templateObject() {
      return data;
    };

    return data;
  }

  var isObject = function isObject(obj) {
    return Object.prototype.toString.call(obj) === '[object Object]';
  };

  var promise = function promise(sync) {
    return sync ? synchronousPromise.SynchronousPromise : Promise;
  };

  function unknown(ctx, value) {
    var known = Object.keys(ctx.fields);
    return Object.keys(value).filter(function (key) {
      return known.indexOf(key) === -1;
    });
  }

  function ObjectSchema(spec) {
    var _this2 = this;

    if (!(this instanceof ObjectSchema)) return new ObjectSchema(spec);
    SchemaType.call(this, {
      type: 'object',
      "default": function _default() {
        var _this = this;

        if (!this._nodes.length) return undefined;
        var dft = {};

        this._nodes.forEach(function (key) {
          dft[key] = _this.fields[key]["default"] ? _this.fields[key]["default"]() : undefined;
        });

        return dft;
      }
    });
    this.fields = Object.create(null);
    this._nodes = [];
    this._excludedEdges = [];
    this.withMutation(function () {
      _this2.transform(function coerce(value) {
        if (typeof value === 'string') {
          try {
            value = JSON.parse(value);
          } catch (err) {
            value = null;
          }
        }

        if (this.isType(value)) return value;
        return null;
      });

      if (spec) {
        _this2.shape(spec);
      }
    });
  }
  inherits(ObjectSchema, SchemaType, {
    _typeCheck: function _typeCheck(value) {
      return isObject(value) || typeof value === 'function';
    },
    _cast: function _cast(_value, options) {
      var _this3 = this;

      if (options === void 0) {
        options = {};
      }

      var value = SchemaType.prototype._cast.call(this, _value, options); //should ignore nulls here


      if (value === undefined) return this["default"]();
      if (!this._typeCheck(value)) return value;
      var fields = this.fields;
      var strip = this._option('stripUnknown', options) === true;

      var props = this._nodes.concat(Object.keys(value).filter(function (v) {
        return _this3._nodes.indexOf(v) === -1;
      }));

      var intermediateValue = {}; // is filled during the transform below

      var innerOptions = _extends({}, options, {
        parent: intermediateValue,
        __validating: false
      });

      var isChanged = false;
      props.forEach(function (prop) {
        var field = fields[prop];
        var exists = has(value, prop);

        if (field) {
          var fieldValue;
          var strict = field._options && field._options.strict; // safe to mutate since this is fired in sequence

          innerOptions.path = makePath(_templateObject$1(), options.path, prop);
          innerOptions.value = value[prop];
          field = field.resolve(innerOptions);

          if (field._strip === true) {
            isChanged = isChanged || prop in value;
            return;
          }

          fieldValue = !options.__validating || !strict ? field.cast(value[prop], innerOptions) : value[prop];
          if (fieldValue !== undefined) intermediateValue[prop] = fieldValue;
        } else if (exists && !strip) intermediateValue[prop] = value[prop];

        if (intermediateValue[prop] !== value[prop]) isChanged = true;
      });
      return isChanged ? intermediateValue : value;
    },
    _validate: function _validate(_value, opts) {
      var _this4 = this;

      if (opts === void 0) {
        opts = {};
      }

      var endEarly, recursive;
      var sync = opts.sync;
      var errors = [];
      var originalValue = opts.originalValue != null ? opts.originalValue : _value;
      endEarly = this._option('abortEarly', opts);
      recursive = this._option('recursive', opts);
      opts = _extends({}, opts, {
        __validating: true,
        originalValue: originalValue
      });
      return SchemaType.prototype._validate.call(this, _value, opts)["catch"](propagateErrors(endEarly, errors)).then(function (value) {
        if (!recursive || !isObject(value)) {
          // only iterate though actual objects
          if (errors.length) throw errors[0];
          return value;
        }

        originalValue = originalValue || value;

        var validations = _this4._nodes.map(function (key) {
          var path = key.indexOf('.') === -1 ? makePath(_templateObject2$1(), opts.path, key) : makePath(_templateObject3(), opts.path, key);
          var field = _this4.fields[key];

          var innerOptions = _extends({}, opts, {
            path: path,
            parent: value,
            originalValue: originalValue[key]
          });

          if (field && field.validate) {
            // inner fields are always strict:
            // 1. this isn't strict so the casting will also have cast inner values
            // 2. this is strict in which case the nested values weren't cast either
            innerOptions.strict = true;
            return field.validate(value[key], innerOptions);
          }

          return promise(sync).resolve(true);
        });

        return runValidations({
          sync: sync,
          validations: validations,
          value: value,
          errors: errors,
          endEarly: endEarly,
          path: opts.path,
          sort: sortByKeyOrder(_this4.fields)
        });
      });
    },
    concat: function concat(schema) {
      var next = SchemaType.prototype.concat.call(this, schema);
      next._nodes = sortFields(next.fields, next._excludedEdges);
      return next;
    },
    shape: function shape(schema, excludes) {
      if (excludes === void 0) {
        excludes = [];
      }

      var next = this.clone();

      var fields = _extends(next.fields, schema);

      next.fields = fields;

      if (excludes.length) {
        if (!Array.isArray(excludes[0])) excludes = [excludes];
        var keys = excludes.map(function (_ref) {
          var first = _ref[0],
              second = _ref[1];
          return first + "-" + second;
        });
        next._excludedEdges = next._excludedEdges.concat(keys);
      }

      next._nodes = sortFields(fields, next._excludedEdges);
      return next;
    },
    from: function from(_from, to, alias) {
      var fromGetter = propertyExpr.getter(_from, true);
      return this.transform(function (obj) {
        if (obj == null) return obj;
        var newObj = obj;

        if (has(obj, _from)) {
          newObj = _extends({}, obj);
          if (!alias) delete newObj[_from];
          newObj[to] = fromGetter(obj);
        }

        return newObj;
      });
    },
    noUnknown: function noUnknown(noAllow, message) {
      if (noAllow === void 0) {
        noAllow = true;
      }

      if (message === void 0) {
        message = object.noUnknown;
      }

      if (typeof noAllow === 'string') {
        message = noAllow;
        noAllow = true;
      }

      var next = this.test({
        name: 'noUnknown',
        exclusive: true,
        message: message,
        test: function test(value) {
          if (value == null) return true;
          var unknownKeys = unknown(this.schema, value);
          return !noAllow || unknownKeys.length === 0 || this.createError({
            params: {
              unknown: unknownKeys.join(', ')
            }
          });
        }
      });
      next._options.stripUnknown = noAllow;
      return next;
    },
    unknown: function unknown(allow, message) {
      if (allow === void 0) {
        allow = true;
      }

      if (message === void 0) {
        message = object.noUnknown;
      }

      return this.noUnknown(!allow, message);
    },
    transformKeys: function transformKeys(fn) {
      return this.transform(function (obj) {
        return obj && mapKeys(obj, function (_, key) {
          return fn(key);
        });
      });
    },
    camelCase: function camelCase$1() {
      return this.transformKeys(camelCase);
    },
    snakeCase: function snakeCase$1() {
      return this.transformKeys(snakeCase);
    },
    constantCase: function constantCase() {
      return this.transformKeys(function (key) {
        return snakeCase(key).toUpperCase();
      });
    },
    describe: function describe() {
      var base = SchemaType.prototype.describe.call(this);
      base.fields = mapValues(this.fields, function (value) {
        return value.describe();
      });
      return base;
    }
  });

  function _templateObject2() {
    var data = _taggedTemplateLiteralLoose(["", "[", "]"]);

    _templateObject2 = function _templateObject2() {
      return data;
    };

    return data;
  }

  function _templateObject() {
    var data = _taggedTemplateLiteralLoose(["", "[", "]"]);

    _templateObject = function _templateObject() {
      return data;
    };

    return data;
  }

  function ArraySchema(type) {
    var _this = this;

    if (!(this instanceof ArraySchema)) return new ArraySchema(type);
    SchemaType.call(this, {
      type: 'array'
    }); // `undefined` specifically means uninitialized, as opposed to
    // "no subtype"

    this._subType = undefined;
    this.innerType = undefined;
    this.withMutation(function () {
      _this.transform(function (values) {
        if (typeof values === 'string') try {
          values = JSON.parse(values);
        } catch (err) {
          values = null;
        }
        return this.isType(values) ? values : null;
      });

      if (type) _this.of(type);
    });
  }

  inherits(ArraySchema, SchemaType, {
    _typeCheck: function _typeCheck(v) {
      return Array.isArray(v);
    },
    _cast: function _cast(_value, _opts) {
      var _this2 = this;

      var value = SchemaType.prototype._cast.call(this, _value, _opts); //should ignore nulls here


      if (!this._typeCheck(value) || !this.innerType) return value;
      var isChanged = false;
      var castArray = value.map(function (v, idx) {
        var castElement = _this2.innerType.cast(v, _extends({}, _opts, {
          path: makePath(_templateObject(), _opts.path, idx)
        }));

        if (castElement !== v) {
          isChanged = true;
        }

        return castElement;
      });
      return isChanged ? castArray : value;
    },
    _validate: function _validate(_value, options) {
      var _this3 = this;

      if (options === void 0) {
        options = {};
      }

      var errors = [];
      var sync = options.sync;
      var path = options.path;
      var innerType = this.innerType;

      var endEarly = this._option('abortEarly', options);

      var recursive = this._option('recursive', options);

      var originalValue = options.originalValue != null ? options.originalValue : _value;
      return SchemaType.prototype._validate.call(this, _value, options)["catch"](propagateErrors(endEarly, errors)).then(function (value) {
        if (!recursive || !innerType || !_this3._typeCheck(value)) {
          if (errors.length) throw errors[0];
          return value;
        }

        originalValue = originalValue || value;
        var validations = value.map(function (item, idx) {
          var path = makePath(_templateObject2(), options.path, idx); // object._validate note for isStrict explanation

          var innerOptions = _extends({}, options, {
            path: path,
            strict: true,
            parent: value,
            originalValue: originalValue[idx]
          });

          if (innerType.validate) return innerType.validate(item, innerOptions);
          return true;
        });
        return runValidations({
          sync: sync,
          path: path,
          value: value,
          errors: errors,
          endEarly: endEarly,
          validations: validations
        });
      });
    },
    _isPresent: function _isPresent(value) {
      return SchemaType.prototype._cast.call(this, value) && value.length > 0;
    },
    of: function of(schema) {
      var next = this.clone();
      if (schema !== false && !isSchema(schema)) throw new TypeError('`array.of()` sub-schema must be a valid yup schema, or `false` to negate a current sub-schema. ' + 'not: ' + printValue(schema));
      next._subType = schema;
      next.innerType = schema;
      return next;
    },
    min: function min(_min, message) {
      message = message || array$1.min;
      return this.test({
        message: message,
        name: 'min',
        exclusive: true,
        params: {
          min: _min
        },
        test: function test(value) {
          return isAbsent(value) || value.length >= this.resolve(_min);
        }
      });
    },
    max: function max(_max, message) {
      message = message || array$1.max;
      return this.test({
        message: message,
        name: 'max',
        exclusive: true,
        params: {
          max: _max
        },
        test: function test(value) {
          return isAbsent(value) || value.length <= this.resolve(_max);
        }
      });
    },
    ensure: function ensure() {
      var _this4 = this;

      return this["default"](function () {
        return [];
      }).transform(function (val, original) {
        // We don't want to return `null` for nullable schema
        if (_this4._typeCheck(val)) return val;
        return original == null ? [] : [].concat(original);
      });
    },
    compact: function compact(rejector) {
      var reject = !rejector ? function (v) {
        return !!v;
      } : function (v, i, a) {
        return !rejector(v, i, a);
      };
      return this.transform(function (values) {
        return values != null ? values.filter(reject) : values;
      });
    },
    describe: function describe() {
      var base = SchemaType.prototype.describe.call(this);
      if (this.innerType) base.innerType = this.innerType.describe();
      return base;
    }
  });

  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  var script$P = {
    name: 'question-controls',
    props: {
      isEditing: {
        type: Boolean,
        "default": false
      }
    },
    methods: {
      save: function save() {
        var _this = this;

        // Make sure all other handlers are executed prior to save
        setTimeout(function () {
          return _this.$emit('save');
        }, 0);
      }
    }
  };

  /* script */
  var __vue_script__$P = script$P;
  /* template */

  var __vue_render__$P = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      staticClass: "d-flex pb-4"
    }, [_c('v-spacer'), _vm._v(" "), _vm.isEditing ? _c('div', [_c('v-btn', {
      attrs: {
        "text": "",
        "large": ""
      },
      on: {
        "click": function click($event) {
          return _vm.$emit('cancel');
        }
      }
    }, [_vm._v("Cancel")]), _vm._v(" "), _c('v-btn', {
      attrs: {
        "color": "green darken-3",
        "text": "",
        "large": ""
      },
      on: {
        "click": _vm.save
      }
    }, [_c('v-icon', {
      staticClass: "pr-1"
    }, [_vm._v("mdi-check")]), _vm._v("\n      Save\n    ")], 1)], 1) : _c('v-btn', {
      attrs: {
        "color": "primary darken-4",
        "text": "",
        "large": ""
      },
      on: {
        "click": function click($event) {
          return _vm.$emit('edit');
        }
      }
    }, [_vm._v("\n    Edit\n  ")])], 1);
  };

  var __vue_staticRenderFns__$P = [];
  /* style */

  var __vue_inject_styles__$P = undefined;
  /* scoped */

  var __vue_scope_id__$P = undefined;
  /* functional template */

  var __vue_is_functional_template__$P = false;
  /* component normalizer */

  function __vue_normalize__$P(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "Controls.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */

  /* style inject SSR */


  var Controls$1 = __vue_normalize__$P({
    render: __vue_render__$P,
    staticRenderFns: __vue_staticRenderFns__$P
  }, __vue_inject_styles__$P, __vue_script__$P, __vue_scope_id__$P, __vue_is_functional_template__$P);

  /*!
   * Quill Editor v1.3.7
   * https://quilljs.com/
   * Copyright (c) 2014, Jason Chen
   * Copyright (c) 2013, salesforce.com
   */
  (function webpackUniversalModuleDefinition(root, factory) {
    if ((typeof exports === "undefined" ? "undefined" : _typeof(exports)) === 'object' && (typeof module === "undefined" ? "undefined" : _typeof(module)) === 'object') module.exports = factory();else if (typeof define === 'function' && define.amd) define([], factory);else if ((typeof exports === "undefined" ? "undefined" : _typeof(exports)) === 'object') exports["Quill"] = factory();else root["Quill"] = factory();
  })(typeof self !== 'undefined' ? self : undefined, function () {
    return (
      /******/
      function (modules) {
        // webpackBootstrap

        /******/
        // The module cache

        /******/
        var installedModules = {};
        /******/

        /******/
        // The require function

        /******/

        function __webpack_require__(moduleId) {
          /******/

          /******/
          // Check if module is in cache

          /******/
          if (installedModules[moduleId]) {
            /******/
            return installedModules[moduleId].exports;
            /******/
          }
          /******/
          // Create a new module (and put it into the cache)

          /******/


          var module = installedModules[moduleId] = {
            /******/
            i: moduleId,

            /******/
            l: false,

            /******/
            exports: {}
            /******/

          };
          /******/

          /******/
          // Execute the module function

          /******/

          modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
          /******/

          /******/
          // Flag the module as loaded

          /******/

          module.l = true;
          /******/

          /******/
          // Return the exports of the module

          /******/

          return module.exports;
          /******/
        }
        /******/

        /******/

        /******/
        // expose the modules object (__webpack_modules__)

        /******/


        __webpack_require__.m = modules;
        /******/

        /******/
        // expose the module cache

        /******/

        __webpack_require__.c = installedModules;
        /******/

        /******/
        // define getter function for harmony exports

        /******/

        __webpack_require__.d = function (exports, name, getter) {
          /******/
          if (!__webpack_require__.o(exports, name)) {
            /******/
            Object.defineProperty(exports, name, {
              /******/
              configurable: false,

              /******/
              enumerable: true,

              /******/
              get: getter
              /******/

            });
            /******/
          }
          /******/

        };
        /******/

        /******/
        // getDefaultExport function for compatibility with non-harmony modules

        /******/


        __webpack_require__.n = function (module) {
          /******/
          var getter = module && module.__esModule ?
          /******/
          function getDefault() {
            return module['default'];
          } :
          /******/
          function getModuleExports() {
            return module;
          };
          /******/

          __webpack_require__.d(getter, 'a', getter);
          /******/


          return getter;
          /******/
        };
        /******/

        /******/
        // Object.prototype.hasOwnProperty.call

        /******/


        __webpack_require__.o = function (object, property) {
          return Object.prototype.hasOwnProperty.call(object, property);
        };
        /******/

        /******/
        // __webpack_public_path__

        /******/


        __webpack_require__.p = "";
        /******/

        /******/
        // Load entry module and return exports

        /******/

        return __webpack_require__(__webpack_require__.s = 109);
        /******/
      }(
      /************************************************************************/

      /******/
      [
      /* 0 */

      /***/
      function (module, exports, __webpack_require__) {

        Object.defineProperty(exports, "__esModule", {
          value: true
        });

        var container_1 = __webpack_require__(17);

        var format_1 = __webpack_require__(18);

        var leaf_1 = __webpack_require__(19);

        var scroll_1 = __webpack_require__(45);

        var inline_1 = __webpack_require__(46);

        var block_1 = __webpack_require__(47);

        var embed_1 = __webpack_require__(48);

        var text_1 = __webpack_require__(49);

        var attributor_1 = __webpack_require__(12);

        var class_1 = __webpack_require__(32);

        var style_1 = __webpack_require__(33);

        var store_1 = __webpack_require__(31);

        var Registry = __webpack_require__(1);

        var Parchment = {
          Scope: Registry.Scope,
          create: Registry.create,
          find: Registry.find,
          query: Registry.query,
          register: Registry.register,
          Container: container_1["default"],
          Format: format_1["default"],
          Leaf: leaf_1["default"],
          Embed: embed_1["default"],
          Scroll: scroll_1["default"],
          Block: block_1["default"],
          Inline: inline_1["default"],
          Text: text_1["default"],
          Attributor: {
            Attribute: attributor_1["default"],
            Class: class_1["default"],
            Style: style_1["default"],
            Store: store_1["default"]
          }
        };
        exports["default"] = Parchment;
        /***/
      },
      /* 1 */

      /***/
      function (module, exports, __webpack_require__) {

        var __extends = this && this.__extends || function () {
          var extendStatics = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function (d, b) {
            d.__proto__ = b;
          } || function (d, b) {
            for (var p in b) {
              if (b.hasOwnProperty(p)) d[p] = b[p];
            }
          };

          return function (d, b) {
            extendStatics(d, b);

            function __() {
              this.constructor = d;
            }

            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();

        Object.defineProperty(exports, "__esModule", {
          value: true
        });

        var ParchmentError =
        /** @class */
        function (_super) {
          __extends(ParchmentError, _super);

          function ParchmentError(message) {
            var _this = this;

            message = '[Parchment] ' + message;
            _this = _super.call(this, message) || this;
            _this.message = message;
            _this.name = _this.constructor.name;
            return _this;
          }

          return ParchmentError;
        }(Error);

        exports.ParchmentError = ParchmentError;
        var attributes = {};
        var classes = {};
        var tags = {};
        var types = {};
        exports.DATA_KEY = '__blot';
        var Scope;

        (function (Scope) {
          Scope[Scope["TYPE"] = 3] = "TYPE";
          Scope[Scope["LEVEL"] = 12] = "LEVEL";
          Scope[Scope["ATTRIBUTE"] = 13] = "ATTRIBUTE";
          Scope[Scope["BLOT"] = 14] = "BLOT";
          Scope[Scope["INLINE"] = 7] = "INLINE";
          Scope[Scope["BLOCK"] = 11] = "BLOCK";
          Scope[Scope["BLOCK_BLOT"] = 10] = "BLOCK_BLOT";
          Scope[Scope["INLINE_BLOT"] = 6] = "INLINE_BLOT";
          Scope[Scope["BLOCK_ATTRIBUTE"] = 9] = "BLOCK_ATTRIBUTE";
          Scope[Scope["INLINE_ATTRIBUTE"] = 5] = "INLINE_ATTRIBUTE";
          Scope[Scope["ANY"] = 15] = "ANY";
        })(Scope = exports.Scope || (exports.Scope = {}));

        function create(input, value) {
          var match = query(input);

          if (match == null) {
            throw new ParchmentError("Unable to create " + input + " blot");
          }

          var BlotClass = match;
          var node = // @ts-ignore
          input instanceof Node || input['nodeType'] === Node.TEXT_NODE ? input : BlotClass.create(value);
          return new BlotClass(node, value);
        }

        exports.create = create;

        function find(node, bubble) {
          if (bubble === void 0) {
            bubble = false;
          }

          if (node == null) return null; // @ts-ignore

          if (node[exports.DATA_KEY] != null) return node[exports.DATA_KEY].blot;
          if (bubble) return find(node.parentNode, bubble);
          return null;
        }

        exports.find = find;

        function query(query, scope) {
          if (scope === void 0) {
            scope = Scope.ANY;
          }

          var match;

          if (typeof query === 'string') {
            match = types[query] || attributes[query]; // @ts-ignore
          } else if (query instanceof Text || query['nodeType'] === Node.TEXT_NODE) {
            match = types['text'];
          } else if (typeof query === 'number') {
            if (query & Scope.LEVEL & Scope.BLOCK) {
              match = types['block'];
            } else if (query & Scope.LEVEL & Scope.INLINE) {
              match = types['inline'];
            }
          } else if (query instanceof HTMLElement) {
            var names = (query.getAttribute('class') || '').split(/\s+/);

            for (var i in names) {
              match = classes[names[i]];
              if (match) break;
            }

            match = match || tags[query.tagName];
          }

          if (match == null) return null; // @ts-ignore

          if (scope & Scope.LEVEL & match.scope && scope & Scope.TYPE & match.scope) return match;
          return null;
        }

        exports.query = query;

        function register() {
          var Definitions = [];

          for (var _i = 0; _i < arguments.length; _i++) {
            Definitions[_i] = arguments[_i];
          }

          if (Definitions.length > 1) {
            return Definitions.map(function (d) {
              return register(d);
            });
          }

          var Definition = Definitions[0];

          if (typeof Definition.blotName !== 'string' && typeof Definition.attrName !== 'string') {
            throw new ParchmentError('Invalid definition');
          } else if (Definition.blotName === 'abstract') {
            throw new ParchmentError('Cannot register abstract class');
          }

          types[Definition.blotName || Definition.attrName] = Definition;

          if (typeof Definition.keyName === 'string') {
            attributes[Definition.keyName] = Definition;
          } else {
            if (Definition.className != null) {
              classes[Definition.className] = Definition;
            }

            if (Definition.tagName != null) {
              if (Array.isArray(Definition.tagName)) {
                Definition.tagName = Definition.tagName.map(function (tagName) {
                  return tagName.toUpperCase();
                });
              } else {
                Definition.tagName = Definition.tagName.toUpperCase();
              }

              var tagNames = Array.isArray(Definition.tagName) ? Definition.tagName : [Definition.tagName];
              tagNames.forEach(function (tag) {
                if (tags[tag] == null || Definition.className == null) {
                  tags[tag] = Definition;
                }
              });
            }
          }

          return Definition;
        }

        exports.register = register;
        /***/
      },
      /* 2 */

      /***/
      function (module, exports, __webpack_require__) {
        var diff = __webpack_require__(51);

        var equal = __webpack_require__(11);

        var extend = __webpack_require__(3);

        var op = __webpack_require__(20);

        var NULL_CHARACTER = String.fromCharCode(0); // Placeholder char for embed in diff()

        var Delta = function Delta(ops) {
          // Assume we are given a well formed ops
          if (Array.isArray(ops)) {
            this.ops = ops;
          } else if (ops != null && Array.isArray(ops.ops)) {
            this.ops = ops.ops;
          } else {
            this.ops = [];
          }
        };

        Delta.prototype.insert = function (text, attributes) {
          var newOp = {};
          if (text.length === 0) return this;
          newOp.insert = text;

          if (attributes != null && _typeof(attributes) === 'object' && Object.keys(attributes).length > 0) {
            newOp.attributes = attributes;
          }

          return this.push(newOp);
        };

        Delta.prototype['delete'] = function (length) {
          if (length <= 0) return this;
          return this.push({
            'delete': length
          });
        };

        Delta.prototype.retain = function (length, attributes) {
          if (length <= 0) return this;
          var newOp = {
            retain: length
          };

          if (attributes != null && _typeof(attributes) === 'object' && Object.keys(attributes).length > 0) {
            newOp.attributes = attributes;
          }

          return this.push(newOp);
        };

        Delta.prototype.push = function (newOp) {
          var index = this.ops.length;
          var lastOp = this.ops[index - 1];
          newOp = extend(true, {}, newOp);

          if (_typeof(lastOp) === 'object') {
            if (typeof newOp['delete'] === 'number' && typeof lastOp['delete'] === 'number') {
              this.ops[index - 1] = {
                'delete': lastOp['delete'] + newOp['delete']
              };
              return this;
            } // Since it does not matter if we insert before or after deleting at the same index,
            // always prefer to insert first


            if (typeof lastOp['delete'] === 'number' && newOp.insert != null) {
              index -= 1;
              lastOp = this.ops[index - 1];

              if (_typeof(lastOp) !== 'object') {
                this.ops.unshift(newOp);
                return this;
              }
            }

            if (equal(newOp.attributes, lastOp.attributes)) {
              if (typeof newOp.insert === 'string' && typeof lastOp.insert === 'string') {
                this.ops[index - 1] = {
                  insert: lastOp.insert + newOp.insert
                };
                if (_typeof(newOp.attributes) === 'object') this.ops[index - 1].attributes = newOp.attributes;
                return this;
              } else if (typeof newOp.retain === 'number' && typeof lastOp.retain === 'number') {
                this.ops[index - 1] = {
                  retain: lastOp.retain + newOp.retain
                };
                if (_typeof(newOp.attributes) === 'object') this.ops[index - 1].attributes = newOp.attributes;
                return this;
              }
            }
          }

          if (index === this.ops.length) {
            this.ops.push(newOp);
          } else {
            this.ops.splice(index, 0, newOp);
          }

          return this;
        };

        Delta.prototype.chop = function () {
          var lastOp = this.ops[this.ops.length - 1];

          if (lastOp && lastOp.retain && !lastOp.attributes) {
            this.ops.pop();
          }

          return this;
        };

        Delta.prototype.filter = function (predicate) {
          return this.ops.filter(predicate);
        };

        Delta.prototype.forEach = function (predicate) {
          this.ops.forEach(predicate);
        };

        Delta.prototype.map = function (predicate) {
          return this.ops.map(predicate);
        };

        Delta.prototype.partition = function (predicate) {
          var passed = [],
              failed = [];
          this.forEach(function (op) {
            var target = predicate(op) ? passed : failed;
            target.push(op);
          });
          return [passed, failed];
        };

        Delta.prototype.reduce = function (predicate, initial) {
          return this.ops.reduce(predicate, initial);
        };

        Delta.prototype.changeLength = function () {
          return this.reduce(function (length, elem) {
            if (elem.insert) {
              return length + op.length(elem);
            } else if (elem["delete"]) {
              return length - elem["delete"];
            }

            return length;
          }, 0);
        };

        Delta.prototype.length = function () {
          return this.reduce(function (length, elem) {
            return length + op.length(elem);
          }, 0);
        };

        Delta.prototype.slice = function (start, end) {
          start = start || 0;
          if (typeof end !== 'number') end = Infinity;
          var ops = [];
          var iter = op.iterator(this.ops);
          var index = 0;

          while (index < end && iter.hasNext()) {
            var nextOp;

            if (index < start) {
              nextOp = iter.next(start - index);
            } else {
              nextOp = iter.next(end - index);
              ops.push(nextOp);
            }

            index += op.length(nextOp);
          }

          return new Delta(ops);
        };

        Delta.prototype.compose = function (other) {
          var thisIter = op.iterator(this.ops);
          var otherIter = op.iterator(other.ops);
          var ops = [];
          var firstOther = otherIter.peek();

          if (firstOther != null && typeof firstOther.retain === 'number' && firstOther.attributes == null) {
            var firstLeft = firstOther.retain;

            while (thisIter.peekType() === 'insert' && thisIter.peekLength() <= firstLeft) {
              firstLeft -= thisIter.peekLength();
              ops.push(thisIter.next());
            }

            if (firstOther.retain - firstLeft > 0) {
              otherIter.next(firstOther.retain - firstLeft);
            }
          }

          var delta = new Delta(ops);

          while (thisIter.hasNext() || otherIter.hasNext()) {
            if (otherIter.peekType() === 'insert') {
              delta.push(otherIter.next());
            } else if (thisIter.peekType() === 'delete') {
              delta.push(thisIter.next());
            } else {
              var length = Math.min(thisIter.peekLength(), otherIter.peekLength());
              var thisOp = thisIter.next(length);
              var otherOp = otherIter.next(length);

              if (typeof otherOp.retain === 'number') {
                var newOp = {};

                if (typeof thisOp.retain === 'number') {
                  newOp.retain = length;
                } else {
                  newOp.insert = thisOp.insert;
                } // Preserve null when composing with a retain, otherwise remove it for inserts


                var attributes = op.attributes.compose(thisOp.attributes, otherOp.attributes, typeof thisOp.retain === 'number');
                if (attributes) newOp.attributes = attributes;
                delta.push(newOp); // Optimization if rest of other is just retain

                if (!otherIter.hasNext() && equal(delta.ops[delta.ops.length - 1], newOp)) {
                  var rest = new Delta(thisIter.rest());
                  return delta.concat(rest).chop();
                } // Other op should be delete, we could be an insert or retain
                // Insert + delete cancels out

              } else if (typeof otherOp['delete'] === 'number' && typeof thisOp.retain === 'number') {
                delta.push(otherOp);
              }
            }
          }

          return delta.chop();
        };

        Delta.prototype.concat = function (other) {
          var delta = new Delta(this.ops.slice());

          if (other.ops.length > 0) {
            delta.push(other.ops[0]);
            delta.ops = delta.ops.concat(other.ops.slice(1));
          }

          return delta;
        };

        Delta.prototype.diff = function (other, index) {
          if (this.ops === other.ops) {
            return new Delta();
          }

          var strings = [this, other].map(function (delta) {
            return delta.map(function (op) {
              if (op.insert != null) {
                return typeof op.insert === 'string' ? op.insert : NULL_CHARACTER;
              }

              var prep = delta === other ? 'on' : 'with';
              throw new Error('diff() called ' + prep + ' non-document');
            }).join('');
          });
          var delta = new Delta();
          var diffResult = diff(strings[0], strings[1], index);
          var thisIter = op.iterator(this.ops);
          var otherIter = op.iterator(other.ops);
          diffResult.forEach(function (component) {
            var length = component[1].length;

            while (length > 0) {
              var opLength = 0;

              switch (component[0]) {
                case diff.INSERT:
                  opLength = Math.min(otherIter.peekLength(), length);
                  delta.push(otherIter.next(opLength));
                  break;

                case diff.DELETE:
                  opLength = Math.min(length, thisIter.peekLength());
                  thisIter.next(opLength);
                  delta['delete'](opLength);
                  break;

                case diff.EQUAL:
                  opLength = Math.min(thisIter.peekLength(), otherIter.peekLength(), length);
                  var thisOp = thisIter.next(opLength);
                  var otherOp = otherIter.next(opLength);

                  if (equal(thisOp.insert, otherOp.insert)) {
                    delta.retain(opLength, op.attributes.diff(thisOp.attributes, otherOp.attributes));
                  } else {
                    delta.push(otherOp)['delete'](opLength);
                  }

                  break;
              }

              length -= opLength;
            }
          });
          return delta.chop();
        };

        Delta.prototype.eachLine = function (predicate, newline) {
          newline = newline || '\n';
          var iter = op.iterator(this.ops);
          var line = new Delta();
          var i = 0;

          while (iter.hasNext()) {
            if (iter.peekType() !== 'insert') return;
            var thisOp = iter.peek();
            var start = op.length(thisOp) - iter.peekLength();
            var index = typeof thisOp.insert === 'string' ? thisOp.insert.indexOf(newline, start) - start : -1;

            if (index < 0) {
              line.push(iter.next());
            } else if (index > 0) {
              line.push(iter.next(index));
            } else {
              if (predicate(line, iter.next(1).attributes || {}, i) === false) {
                return;
              }

              i += 1;
              line = new Delta();
            }
          }

          if (line.length() > 0) {
            predicate(line, {}, i);
          }
        };

        Delta.prototype.transform = function (other, priority) {
          priority = !!priority;

          if (typeof other === 'number') {
            return this.transformPosition(other, priority);
          }

          var thisIter = op.iterator(this.ops);
          var otherIter = op.iterator(other.ops);
          var delta = new Delta();

          while (thisIter.hasNext() || otherIter.hasNext()) {
            if (thisIter.peekType() === 'insert' && (priority || otherIter.peekType() !== 'insert')) {
              delta.retain(op.length(thisIter.next()));
            } else if (otherIter.peekType() === 'insert') {
              delta.push(otherIter.next());
            } else {
              var length = Math.min(thisIter.peekLength(), otherIter.peekLength());
              var thisOp = thisIter.next(length);
              var otherOp = otherIter.next(length);

              if (thisOp['delete']) {
                // Our delete either makes their delete redundant or removes their retain
                continue;
              } else if (otherOp['delete']) {
                delta.push(otherOp);
              } else {
                // We retain either their retain or insert
                delta.retain(length, op.attributes.transform(thisOp.attributes, otherOp.attributes, priority));
              }
            }
          }

          return delta.chop();
        };

        Delta.prototype.transformPosition = function (index, priority) {
          priority = !!priority;
          var thisIter = op.iterator(this.ops);
          var offset = 0;

          while (thisIter.hasNext() && offset <= index) {
            var length = thisIter.peekLength();
            var nextType = thisIter.peekType();
            thisIter.next();

            if (nextType === 'delete') {
              index -= Math.min(length, index - offset);
              continue;
            } else if (nextType === 'insert' && (offset < index || !priority)) {
              index += length;
            }

            offset += length;
          }

          return index;
        };

        module.exports = Delta;
        /***/
      },
      /* 3 */

      /***/
      function (module, exports) {

        var hasOwn = Object.prototype.hasOwnProperty;
        var toStr = Object.prototype.toString;
        var defineProperty = Object.defineProperty;
        var gOPD = Object.getOwnPropertyDescriptor;

        var isArray = function isArray(arr) {
          if (typeof Array.isArray === 'function') {
            return Array.isArray(arr);
          }

          return toStr.call(arr) === '[object Array]';
        };

        var isPlainObject = function isPlainObject(obj) {
          if (!obj || toStr.call(obj) !== '[object Object]') {
            return false;
          }

          var hasOwnConstructor = hasOwn.call(obj, 'constructor');
          var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf'); // Not own constructor property must be Object

          if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
            return false;
          } // Own properties are enumerated firstly, so to speed up,
          // if last one is own, then all properties are own.


          var key;

          for (key in obj) {
            /**/
          }

          return typeof key === 'undefined' || hasOwn.call(obj, key);
        }; // If name is '__proto__', and Object.defineProperty is available, define __proto__ as an own property on target


        var setProperty = function setProperty(target, options) {
          if (defineProperty && options.name === '__proto__') {
            defineProperty(target, options.name, {
              enumerable: true,
              configurable: true,
              value: options.newValue,
              writable: true
            });
          } else {
            target[options.name] = options.newValue;
          }
        }; // Return undefined instead of __proto__ if '__proto__' is not an own property


        var getProperty = function getProperty(obj, name) {
          if (name === '__proto__') {
            if (!hasOwn.call(obj, name)) {
              return void 0;
            } else if (gOPD) {
              // In early versions of node, obj['__proto__'] is buggy when obj has
              // __proto__ as an own property. Object.getOwnPropertyDescriptor() works.
              return gOPD(obj, name).value;
            }
          }

          return obj[name];
        };

        module.exports = function extend() {
          var options, name, src, copy, copyIsArray, clone;
          var target = arguments[0];
          var i = 1;
          var length = arguments.length;
          var deep = false; // Handle a deep copy situation

          if (typeof target === 'boolean') {
            deep = target;
            target = arguments[1] || {}; // skip the boolean and the target

            i = 2;
          }

          if (target == null || _typeof(target) !== 'object' && typeof target !== 'function') {
            target = {};
          }

          for (; i < length; ++i) {
            options = arguments[i]; // Only deal with non-null/undefined values

            if (options != null) {
              // Extend the base object
              for (name in options) {
                src = getProperty(target, name);
                copy = getProperty(options, name); // Prevent never-ending loop

                if (target !== copy) {
                  // Recurse if we're merging plain objects or arrays
                  if (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {
                    if (copyIsArray) {
                      copyIsArray = false;
                      clone = src && isArray(src) ? src : [];
                    } else {
                      clone = src && isPlainObject(src) ? src : {};
                    } // Never move original objects, clone them


                    setProperty(target, {
                      name: name,
                      newValue: extend(deep, clone, copy)
                    }); // Don't bring in undefined values
                  } else if (typeof copy !== 'undefined') {
                    setProperty(target, {
                      name: name,
                      newValue: copy
                    });
                  }
                }
              }
            }
          } // Return the modified object


          return target;
        };
        /***/

      },
      /* 4 */

      /***/
      function (module, exports, __webpack_require__) {

        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports["default"] = exports.BlockEmbed = exports.bubbleFormats = undefined;

        var _createClass = function () {
          function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor) descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
          };
        }();

        var _get = function get(object, property, receiver) {
          if (object === null) object = Function.prototype;
          var desc = Object.getOwnPropertyDescriptor(object, property);

          if (desc === undefined) {
            var parent = Object.getPrototypeOf(object);

            if (parent === null) {
              return undefined;
            } else {
              return get(parent, property, receiver);
            }
          } else if ("value" in desc) {
            return desc.value;
          } else {
            var getter = desc.get;

            if (getter === undefined) {
              return undefined;
            }

            return getter.call(receiver);
          }
        };

        var _extend = __webpack_require__(3);

        var _extend2 = _interopRequireDefault(_extend);

        var _quillDelta = __webpack_require__(2);

        var _quillDelta2 = _interopRequireDefault(_quillDelta);

        var _parchment = __webpack_require__(0);

        var _parchment2 = _interopRequireDefault(_parchment);

        var _break = __webpack_require__(16);

        var _break2 = _interopRequireDefault(_break);

        var _inline = __webpack_require__(6);

        var _inline2 = _interopRequireDefault(_inline);

        var _text = __webpack_require__(7);

        var _text2 = _interopRequireDefault(_text);

        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : {
            "default": obj
          };
        }

        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }

        function _possibleConstructorReturn(self, call) {
          if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }

          return call && (_typeof(call) === "object" || typeof call === "function") ? call : self;
        }

        function _inherits(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + _typeof(superClass));
          }

          subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
              value: subClass,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }

        var NEWLINE_LENGTH = 1;

        var BlockEmbed = function (_Parchment$Embed) {
          _inherits(BlockEmbed, _Parchment$Embed);

          function BlockEmbed() {
            _classCallCheck(this, BlockEmbed);

            return _possibleConstructorReturn(this, (BlockEmbed.__proto__ || Object.getPrototypeOf(BlockEmbed)).apply(this, arguments));
          }

          _createClass(BlockEmbed, [{
            key: 'attach',
            value: function attach() {
              _get(BlockEmbed.prototype.__proto__ || Object.getPrototypeOf(BlockEmbed.prototype), 'attach', this).call(this);

              this.attributes = new _parchment2["default"].Attributor.Store(this.domNode);
            }
          }, {
            key: 'delta',
            value: function delta() {
              return new _quillDelta2["default"]().insert(this.value(), (0, _extend2["default"])(this.formats(), this.attributes.values()));
            }
          }, {
            key: 'format',
            value: function format(name, value) {
              var attribute = _parchment2["default"].query(name, _parchment2["default"].Scope.BLOCK_ATTRIBUTE);

              if (attribute != null) {
                this.attributes.attribute(attribute, value);
              }
            }
          }, {
            key: 'formatAt',
            value: function formatAt(index, length, name, value) {
              this.format(name, value);
            }
          }, {
            key: 'insertAt',
            value: function insertAt(index, value, def) {
              if (typeof value === 'string' && value.endsWith('\n')) {
                var block = _parchment2["default"].create(Block.blotName);

                this.parent.insertBefore(block, index === 0 ? this : this.next);
                block.insertAt(0, value.slice(0, -1));
              } else {
                _get(BlockEmbed.prototype.__proto__ || Object.getPrototypeOf(BlockEmbed.prototype), 'insertAt', this).call(this, index, value, def);
              }
            }
          }]);

          return BlockEmbed;
        }(_parchment2["default"].Embed);

        BlockEmbed.scope = _parchment2["default"].Scope.BLOCK_BLOT; // It is important for cursor behavior BlockEmbeds use tags that are block level elements

        var Block = function (_Parchment$Block) {
          _inherits(Block, _Parchment$Block);

          function Block(domNode) {
            _classCallCheck(this, Block);

            var _this2 = _possibleConstructorReturn(this, (Block.__proto__ || Object.getPrototypeOf(Block)).call(this, domNode));

            _this2.cache = {};
            return _this2;
          }

          _createClass(Block, [{
            key: 'delta',
            value: function delta() {
              if (this.cache.delta == null) {
                this.cache.delta = this.descendants(_parchment2["default"].Leaf).reduce(function (delta, leaf) {
                  if (leaf.length() === 0) {
                    return delta;
                  } else {
                    return delta.insert(leaf.value(), bubbleFormats(leaf));
                  }
                }, new _quillDelta2["default"]()).insert('\n', bubbleFormats(this));
              }

              return this.cache.delta;
            }
          }, {
            key: 'deleteAt',
            value: function deleteAt(index, length) {
              _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), 'deleteAt', this).call(this, index, length);

              this.cache = {};
            }
          }, {
            key: 'formatAt',
            value: function formatAt(index, length, name, value) {
              if (length <= 0) return;

              if (_parchment2["default"].query(name, _parchment2["default"].Scope.BLOCK)) {
                if (index + length === this.length()) {
                  this.format(name, value);
                }
              } else {
                _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), 'formatAt', this).call(this, index, Math.min(length, this.length() - index - 1), name, value);
              }

              this.cache = {};
            }
          }, {
            key: 'insertAt',
            value: function insertAt(index, value, def) {
              if (def != null) return _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), 'insertAt', this).call(this, index, value, def);
              if (value.length === 0) return;
              var lines = value.split('\n');
              var text = lines.shift();

              if (text.length > 0) {
                if (index < this.length() - 1 || this.children.tail == null) {
                  _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), 'insertAt', this).call(this, Math.min(index, this.length() - 1), text);
                } else {
                  this.children.tail.insertAt(this.children.tail.length(), text);
                }

                this.cache = {};
              }

              var block = this;
              lines.reduce(function (index, line) {
                block = block.split(index, true);
                block.insertAt(0, line);
                return line.length;
              }, index + text.length);
            }
          }, {
            key: 'insertBefore',
            value: function insertBefore(blot, ref) {
              var head = this.children.head;

              _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), 'insertBefore', this).call(this, blot, ref);

              if (head instanceof _break2["default"]) {
                head.remove();
              }

              this.cache = {};
            }
          }, {
            key: 'length',
            value: function length() {
              if (this.cache.length == null) {
                this.cache.length = _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), 'length', this).call(this) + NEWLINE_LENGTH;
              }

              return this.cache.length;
            }
          }, {
            key: 'moveChildren',
            value: function moveChildren(target, ref) {
              _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), 'moveChildren', this).call(this, target, ref);

              this.cache = {};
            }
          }, {
            key: 'optimize',
            value: function optimize(context) {
              _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), 'optimize', this).call(this, context);

              this.cache = {};
            }
          }, {
            key: 'path',
            value: function path(index) {
              return _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), 'path', this).call(this, index, true);
            }
          }, {
            key: 'removeChild',
            value: function removeChild(child) {
              _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), 'removeChild', this).call(this, child);

              this.cache = {};
            }
          }, {
            key: 'split',
            value: function split(index) {
              var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

              if (force && (index === 0 || index >= this.length() - NEWLINE_LENGTH)) {
                var clone = this.clone();

                if (index === 0) {
                  this.parent.insertBefore(clone, this);
                  return this;
                } else {
                  this.parent.insertBefore(clone, this.next);
                  return clone;
                }
              } else {
                var next = _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), 'split', this).call(this, index, force);

                this.cache = {};
                return next;
              }
            }
          }]);

          return Block;
        }(_parchment2["default"].Block);

        Block.blotName = 'block';
        Block.tagName = 'P';
        Block.defaultChild = 'break';
        Block.allowedChildren = [_inline2["default"], _parchment2["default"].Embed, _text2["default"]];

        function bubbleFormats(blot) {
          var formats = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          if (blot == null) return formats;

          if (typeof blot.formats === 'function') {
            formats = (0, _extend2["default"])(formats, blot.formats());
          }

          if (blot.parent == null || blot.parent.blotName == 'scroll' || blot.parent.statics.scope !== blot.statics.scope) {
            return formats;
          }

          return bubbleFormats(blot.parent, formats);
        }

        exports.bubbleFormats = bubbleFormats;
        exports.BlockEmbed = BlockEmbed;
        exports["default"] = Block;
        /***/
      },
      /* 5 */

      /***/
      function (module, exports, __webpack_require__) {

        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports["default"] = exports.overload = exports.expandConfig = undefined;

        var _typeof$1 = typeof Symbol === "function" && _typeof(Symbol.iterator) === "symbol" ? function (obj) {
          return _typeof(obj);
        } : function (obj) {
          return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof(obj);
        };

        var _slicedToArray = function () {
          function sliceIterator(arr, i) {
            var _arr = [];
            var _n = true;
            var _d = false;
            var _e = undefined;

            try {
              for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                _arr.push(_s.value);

                if (i && _arr.length === i) break;
              }
            } catch (err) {
              _d = true;
              _e = err;
            } finally {
              try {
                if (!_n && _i["return"]) _i["return"]();
              } finally {
                if (_d) throw _e;
              }
            }

            return _arr;
          }

          return function (arr, i) {
            if (Array.isArray(arr)) {
              return arr;
            } else if (Symbol.iterator in Object(arr)) {
              return sliceIterator(arr, i);
            } else {
              throw new TypeError("Invalid attempt to destructure non-iterable instance");
            }
          };
        }();

        var _createClass = function () {
          function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor) descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
          };
        }();

        __webpack_require__(50);

        var _quillDelta = __webpack_require__(2);

        var _quillDelta2 = _interopRequireDefault(_quillDelta);

        var _editor = __webpack_require__(14);

        var _editor2 = _interopRequireDefault(_editor);

        var _emitter3 = __webpack_require__(8);

        var _emitter4 = _interopRequireDefault(_emitter3);

        var _module = __webpack_require__(9);

        var _module2 = _interopRequireDefault(_module);

        var _parchment = __webpack_require__(0);

        var _parchment2 = _interopRequireDefault(_parchment);

        var _selection = __webpack_require__(15);

        var _selection2 = _interopRequireDefault(_selection);

        var _extend = __webpack_require__(3);

        var _extend2 = _interopRequireDefault(_extend);

        var _logger = __webpack_require__(10);

        var _logger2 = _interopRequireDefault(_logger);

        var _theme = __webpack_require__(34);

        var _theme2 = _interopRequireDefault(_theme);

        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : {
            "default": obj
          };
        }

        function _defineProperty(obj, key, value) {
          if (key in obj) {
            Object.defineProperty(obj, key, {
              value: value,
              enumerable: true,
              configurable: true,
              writable: true
            });
          } else {
            obj[key] = value;
          }

          return obj;
        }

        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }

        var debug = (0, _logger2["default"])('quill');

        var Quill = function () {
          _createClass(Quill, null, [{
            key: 'debug',
            value: function debug(limit) {
              if (limit === true) {
                limit = 'log';
              }

              _logger2["default"].level(limit);
            }
          }, {
            key: 'find',
            value: function find(node) {
              return node.__quill || _parchment2["default"].find(node);
            }
          }, {
            key: 'import',
            value: function _import(name) {
              if (this.imports[name] == null) {
                debug.error('Cannot import ' + name + '. Are you sure it was registered?');
              }

              return this.imports[name];
            }
          }, {
            key: 'register',
            value: function register(path, target) {
              var _this = this;

              var overwrite = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

              if (typeof path !== 'string') {
                var name = path.attrName || path.blotName;

                if (typeof name === 'string') {
                  // register(Blot | Attributor, overwrite)
                  this.register('formats/' + name, path, target);
                } else {
                  Object.keys(path).forEach(function (key) {
                    _this.register(key, path[key], target);
                  });
                }
              } else {
                if (this.imports[path] != null && !overwrite) {
                  debug.warn('Overwriting ' + path + ' with', target);
                }

                this.imports[path] = target;

                if ((path.startsWith('blots/') || path.startsWith('formats/')) && target.blotName !== 'abstract') {
                  _parchment2["default"].register(target);
                } else if (path.startsWith('modules') && typeof target.register === 'function') {
                  target.register();
                }
              }
            }
          }]);

          function Quill(container) {
            var _this2 = this;

            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

            _classCallCheck(this, Quill);

            this.options = expandConfig(container, options);
            this.container = this.options.container;

            if (this.container == null) {
              return debug.error('Invalid Quill container', container);
            }

            if (this.options.debug) {
              Quill.debug(this.options.debug);
            }

            var html = this.container.innerHTML.trim();
            this.container.classList.add('ql-container');
            this.container.innerHTML = '';
            this.container.__quill = this;
            this.root = this.addContainer('ql-editor');
            this.root.classList.add('ql-blank');
            this.root.setAttribute('data-gramm', false);
            this.scrollingContainer = this.options.scrollingContainer || this.root;
            this.emitter = new _emitter4["default"]();
            this.scroll = _parchment2["default"].create(this.root, {
              emitter: this.emitter,
              whitelist: this.options.formats
            });
            this.editor = new _editor2["default"](this.scroll);
            this.selection = new _selection2["default"](this.scroll, this.emitter);
            this.theme = new this.options.theme(this, this.options);
            this.keyboard = this.theme.addModule('keyboard');
            this.clipboard = this.theme.addModule('clipboard');
            this.history = this.theme.addModule('history');
            this.theme.init();
            this.emitter.on(_emitter4["default"].events.EDITOR_CHANGE, function (type) {
              if (type === _emitter4["default"].events.TEXT_CHANGE) {
                _this2.root.classList.toggle('ql-blank', _this2.editor.isBlank());
              }
            });
            this.emitter.on(_emitter4["default"].events.SCROLL_UPDATE, function (source, mutations) {
              var range = _this2.selection.lastRange;
              var index = range && range.length === 0 ? range.index : undefined;
              modify.call(_this2, function () {
                return _this2.editor.update(null, mutations, index);
              }, source);
            });
            var contents = this.clipboard.convert('<div class=\'ql-editor\' style="white-space: normal;">' + html + '<p><br></p></div>');
            this.setContents(contents);
            this.history.clear();

            if (this.options.placeholder) {
              this.root.setAttribute('data-placeholder', this.options.placeholder);
            }

            if (this.options.readOnly) {
              this.disable();
            }
          }

          _createClass(Quill, [{
            key: 'addContainer',
            value: function addContainer(container) {
              var refNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

              if (typeof container === 'string') {
                var className = container;
                container = document.createElement('div');
                container.classList.add(className);
              }

              this.container.insertBefore(container, refNode);
              return container;
            }
          }, {
            key: 'blur',
            value: function blur() {
              this.selection.setRange(null);
            }
          }, {
            key: 'deleteText',
            value: function deleteText(index, length, source) {
              var _this3 = this;

              var _overload = overload(index, length, source);

              var _overload2 = _slicedToArray(_overload, 4);

              index = _overload2[0];
              length = _overload2[1];
              source = _overload2[3];
              return modify.call(this, function () {
                return _this3.editor.deleteText(index, length);
              }, source, index, -1 * length);
            }
          }, {
            key: 'disable',
            value: function disable() {
              this.enable(false);
            }
          }, {
            key: 'enable',
            value: function enable() {
              var enabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
              this.scroll.enable(enabled);
              this.container.classList.toggle('ql-disabled', !enabled);
            }
          }, {
            key: 'focus',
            value: function focus() {
              var scrollTop = this.scrollingContainer.scrollTop;
              this.selection.focus();
              this.scrollingContainer.scrollTop = scrollTop;
              this.scrollIntoView();
            }
          }, {
            key: 'format',
            value: function format(name, value) {
              var _this4 = this;

              var source = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _emitter4["default"].sources.API;
              return modify.call(this, function () {
                var range = _this4.getSelection(true);

                var change = new _quillDelta2["default"]();

                if (range == null) {
                  return change;
                } else if (_parchment2["default"].query(name, _parchment2["default"].Scope.BLOCK)) {
                  change = _this4.editor.formatLine(range.index, range.length, _defineProperty({}, name, value));
                } else if (range.length === 0) {
                  _this4.selection.format(name, value);

                  return change;
                } else {
                  change = _this4.editor.formatText(range.index, range.length, _defineProperty({}, name, value));
                }

                _this4.setSelection(range, _emitter4["default"].sources.SILENT);

                return change;
              }, source);
            }
          }, {
            key: 'formatLine',
            value: function formatLine(index, length, name, value, source) {
              var _this5 = this;

              var formats = void 0;

              var _overload3 = overload(index, length, name, value, source);

              var _overload4 = _slicedToArray(_overload3, 4);

              index = _overload4[0];
              length = _overload4[1];
              formats = _overload4[2];
              source = _overload4[3];
              return modify.call(this, function () {
                return _this5.editor.formatLine(index, length, formats);
              }, source, index, 0);
            }
          }, {
            key: 'formatText',
            value: function formatText(index, length, name, value, source) {
              var _this6 = this;

              var formats = void 0;

              var _overload5 = overload(index, length, name, value, source);

              var _overload6 = _slicedToArray(_overload5, 4);

              index = _overload6[0];
              length = _overload6[1];
              formats = _overload6[2];
              source = _overload6[3];
              return modify.call(this, function () {
                return _this6.editor.formatText(index, length, formats);
              }, source, index, 0);
            }
          }, {
            key: 'getBounds',
            value: function getBounds(index) {
              var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
              var bounds = void 0;

              if (typeof index === 'number') {
                bounds = this.selection.getBounds(index, length);
              } else {
                bounds = this.selection.getBounds(index.index, index.length);
              }

              var containerBounds = this.container.getBoundingClientRect();
              return {
                bottom: bounds.bottom - containerBounds.top,
                height: bounds.height,
                left: bounds.left - containerBounds.left,
                right: bounds.right - containerBounds.left,
                top: bounds.top - containerBounds.top,
                width: bounds.width
              };
            }
          }, {
            key: 'getContents',
            value: function getContents() {
              var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
              var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.getLength() - index;

              var _overload7 = overload(index, length);

              var _overload8 = _slicedToArray(_overload7, 2);

              index = _overload8[0];
              length = _overload8[1];
              return this.editor.getContents(index, length);
            }
          }, {
            key: 'getFormat',
            value: function getFormat() {
              var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getSelection(true);
              var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

              if (typeof index === 'number') {
                return this.editor.getFormat(index, length);
              } else {
                return this.editor.getFormat(index.index, index.length);
              }
            }
          }, {
            key: 'getIndex',
            value: function getIndex(blot) {
              return blot.offset(this.scroll);
            }
          }, {
            key: 'getLength',
            value: function getLength() {
              return this.scroll.length();
            }
          }, {
            key: 'getLeaf',
            value: function getLeaf(index) {
              return this.scroll.leaf(index);
            }
          }, {
            key: 'getLine',
            value: function getLine(index) {
              return this.scroll.line(index);
            }
          }, {
            key: 'getLines',
            value: function getLines() {
              var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
              var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Number.MAX_VALUE;

              if (typeof index !== 'number') {
                return this.scroll.lines(index.index, index.length);
              } else {
                return this.scroll.lines(index, length);
              }
            }
          }, {
            key: 'getModule',
            value: function getModule(name) {
              return this.theme.modules[name];
            }
          }, {
            key: 'getSelection',
            value: function getSelection() {
              var focus = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
              if (focus) this.focus();
              this.update(); // Make sure we access getRange with editor in consistent state

              return this.selection.getRange()[0];
            }
          }, {
            key: 'getText',
            value: function getText() {
              var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
              var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.getLength() - index;

              var _overload9 = overload(index, length);

              var _overload10 = _slicedToArray(_overload9, 2);

              index = _overload10[0];
              length = _overload10[1];
              return this.editor.getText(index, length);
            }
          }, {
            key: 'hasFocus',
            value: function hasFocus() {
              return this.selection.hasFocus();
            }
          }, {
            key: 'insertEmbed',
            value: function insertEmbed(index, embed, value) {
              var _this7 = this;

              var source = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Quill.sources.API;
              return modify.call(this, function () {
                return _this7.editor.insertEmbed(index, embed, value);
              }, source, index);
            }
          }, {
            key: 'insertText',
            value: function insertText(index, text, name, value, source) {
              var _this8 = this;

              var formats = void 0;

              var _overload11 = overload(index, 0, name, value, source);

              var _overload12 = _slicedToArray(_overload11, 4);

              index = _overload12[0];
              formats = _overload12[2];
              source = _overload12[3];
              return modify.call(this, function () {
                return _this8.editor.insertText(index, text, formats);
              }, source, index, text.length);
            }
          }, {
            key: 'isEnabled',
            value: function isEnabled() {
              return !this.container.classList.contains('ql-disabled');
            }
          }, {
            key: 'off',
            value: function off() {
              return this.emitter.off.apply(this.emitter, arguments);
            }
          }, {
            key: 'on',
            value: function on() {
              return this.emitter.on.apply(this.emitter, arguments);
            }
          }, {
            key: 'once',
            value: function once() {
              return this.emitter.once.apply(this.emitter, arguments);
            }
          }, {
            key: 'pasteHTML',
            value: function pasteHTML(index, html, source) {
              this.clipboard.dangerouslyPasteHTML(index, html, source);
            }
          }, {
            key: 'removeFormat',
            value: function removeFormat(index, length, source) {
              var _this9 = this;

              var _overload13 = overload(index, length, source);

              var _overload14 = _slicedToArray(_overload13, 4);

              index = _overload14[0];
              length = _overload14[1];
              source = _overload14[3];
              return modify.call(this, function () {
                return _this9.editor.removeFormat(index, length);
              }, source, index);
            }
          }, {
            key: 'scrollIntoView',
            value: function scrollIntoView() {
              this.selection.scrollIntoView(this.scrollingContainer);
            }
          }, {
            key: 'setContents',
            value: function setContents(delta) {
              var _this10 = this;

              var source = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _emitter4["default"].sources.API;
              return modify.call(this, function () {
                delta = new _quillDelta2["default"](delta);

                var length = _this10.getLength();

                var deleted = _this10.editor.deleteText(0, length);

                var applied = _this10.editor.applyDelta(delta);

                var lastOp = applied.ops[applied.ops.length - 1];

                if (lastOp != null && typeof lastOp.insert === 'string' && lastOp.insert[lastOp.insert.length - 1] === '\n') {
                  _this10.editor.deleteText(_this10.getLength() - 1, 1);

                  applied["delete"](1);
                }

                var ret = deleted.compose(applied);
                return ret;
              }, source);
            }
          }, {
            key: 'setSelection',
            value: function setSelection(index, length, source) {
              if (index == null) {
                this.selection.setRange(null, length || Quill.sources.API);
              } else {
                var _overload15 = overload(index, length, source);

                var _overload16 = _slicedToArray(_overload15, 4);

                index = _overload16[0];
                length = _overload16[1];
                source = _overload16[3];
                this.selection.setRange(new _selection.Range(index, length), source);

                if (source !== _emitter4["default"].sources.SILENT) {
                  this.selection.scrollIntoView(this.scrollingContainer);
                }
              }
            }
          }, {
            key: 'setText',
            value: function setText(text) {
              var source = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _emitter4["default"].sources.API;
              var delta = new _quillDelta2["default"]().insert(text);
              return this.setContents(delta, source);
            }
          }, {
            key: 'update',
            value: function update() {
              var source = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _emitter4["default"].sources.USER;
              var change = this.scroll.update(source); // Will update selection before selection.update() does if text changes

              this.selection.update(source);
              return change;
            }
          }, {
            key: 'updateContents',
            value: function updateContents(delta) {
              var _this11 = this;

              var source = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _emitter4["default"].sources.API;
              return modify.call(this, function () {
                delta = new _quillDelta2["default"](delta);
                return _this11.editor.applyDelta(delta, source);
              }, source, true);
            }
          }]);

          return Quill;
        }();

        Quill.DEFAULTS = {
          bounds: null,
          formats: null,
          modules: {},
          placeholder: '',
          readOnly: false,
          scrollingContainer: null,
          strict: true,
          theme: 'default'
        };
        Quill.events = _emitter4["default"].events;
        Quill.sources = _emitter4["default"].sources; // eslint-disable-next-line no-undef

        Quill.version = "1.3.7";
        Quill.imports = {
          'delta': _quillDelta2["default"],
          'parchment': _parchment2["default"],
          'core/module': _module2["default"],
          'core/theme': _theme2["default"]
        };

        function expandConfig(container, userConfig) {
          userConfig = (0, _extend2["default"])(true, {
            container: container,
            modules: {
              clipboard: true,
              keyboard: true,
              history: true
            }
          }, userConfig);

          if (!userConfig.theme || userConfig.theme === Quill.DEFAULTS.theme) {
            userConfig.theme = _theme2["default"];
          } else {
            userConfig.theme = Quill["import"]('themes/' + userConfig.theme);

            if (userConfig.theme == null) {
              throw new Error('Invalid theme ' + userConfig.theme + '. Did you register it?');
            }
          }

          var themeConfig = (0, _extend2["default"])(true, {}, userConfig.theme.DEFAULTS);
          [themeConfig, userConfig].forEach(function (config) {
            config.modules = config.modules || {};
            Object.keys(config.modules).forEach(function (module) {
              if (config.modules[module] === true) {
                config.modules[module] = {};
              }
            });
          });
          var moduleNames = Object.keys(themeConfig.modules).concat(Object.keys(userConfig.modules));
          var moduleConfig = moduleNames.reduce(function (config, name) {
            var moduleClass = Quill["import"]('modules/' + name);

            if (moduleClass == null) {
              debug.error('Cannot load ' + name + ' module. Are you sure you registered it?');
            } else {
              config[name] = moduleClass.DEFAULTS || {};
            }

            return config;
          }, {}); // Special case toolbar shorthand

          if (userConfig.modules != null && userConfig.modules.toolbar && userConfig.modules.toolbar.constructor !== Object) {
            userConfig.modules.toolbar = {
              container: userConfig.modules.toolbar
            };
          }

          userConfig = (0, _extend2["default"])(true, {}, Quill.DEFAULTS, {
            modules: moduleConfig
          }, themeConfig, userConfig);
          ['bounds', 'container', 'scrollingContainer'].forEach(function (key) {
            if (typeof userConfig[key] === 'string') {
              userConfig[key] = document.querySelector(userConfig[key]);
            }
          });
          userConfig.modules = Object.keys(userConfig.modules).reduce(function (config, name) {
            if (userConfig.modules[name]) {
              config[name] = userConfig.modules[name];
            }

            return config;
          }, {});
          return userConfig;
        } // Handle selection preservation and TEXT_CHANGE emission
        // common to modification APIs


        function modify(modifier, source, index, shift) {
          if (this.options.strict && !this.isEnabled() && source === _emitter4["default"].sources.USER) {
            return new _quillDelta2["default"]();
          }

          var range = index == null ? null : this.getSelection();
          var oldDelta = this.editor.delta;
          var change = modifier();

          if (range != null) {
            if (index === true) index = range.index;

            if (shift == null) {
              range = shiftRange(range, change, source);
            } else if (shift !== 0) {
              range = shiftRange(range, index, shift, source);
            }

            this.setSelection(range, _emitter4["default"].sources.SILENT);
          }

          if (change.length() > 0) {
            var _emitter;

            var args = [_emitter4["default"].events.TEXT_CHANGE, change, oldDelta, source];

            (_emitter = this.emitter).emit.apply(_emitter, [_emitter4["default"].events.EDITOR_CHANGE].concat(args));

            if (source !== _emitter4["default"].sources.SILENT) {
              var _emitter2;

              (_emitter2 = this.emitter).emit.apply(_emitter2, args);
            }
          }

          return change;
        }

        function overload(index, length, name, value, source) {
          var formats = {};

          if (typeof index.index === 'number' && typeof index.length === 'number') {
            // Allow for throwaway end (used by insertText/insertEmbed)
            if (typeof length !== 'number') {
              source = value, value = name, name = length, length = index.length, index = index.index;
            } else {
              length = index.length, index = index.index;
            }
          } else if (typeof length !== 'number') {
            source = value, value = name, name = length, length = 0;
          } // Handle format being object, two format name/value strings or excluded


          if ((typeof name === 'undefined' ? 'undefined' : _typeof$1(name)) === 'object') {
            formats = name;
            source = value;
          } else if (typeof name === 'string') {
            if (value != null) {
              formats[name] = value;
            } else {
              source = name;
            }
          } // Handle optional source


          source = source || _emitter4["default"].sources.API;
          return [index, length, formats, source];
        }

        function shiftRange(range, index, length, source) {
          if (range == null) return null;
          var start = void 0,
              end = void 0;

          if (index instanceof _quillDelta2["default"]) {
            var _map = [range.index, range.index + range.length].map(function (pos) {
              return index.transformPosition(pos, source !== _emitter4["default"].sources.USER);
            });

            var _map2 = _slicedToArray(_map, 2);

            start = _map2[0];
            end = _map2[1];
          } else {
            var _map3 = [range.index, range.index + range.length].map(function (pos) {
              if (pos < index || pos === index && source === _emitter4["default"].sources.USER) return pos;

              if (length >= 0) {
                return pos + length;
              } else {
                return Math.max(index, pos + length);
              }
            });

            var _map4 = _slicedToArray(_map3, 2);

            start = _map4[0];
            end = _map4[1];
          }

          return new _selection.Range(start, end - start);
        }

        exports.expandConfig = expandConfig;
        exports.overload = overload;
        exports["default"] = Quill;
        /***/
      },
      /* 6 */

      /***/
      function (module, exports, __webpack_require__) {

        Object.defineProperty(exports, "__esModule", {
          value: true
        });

        var _createClass = function () {
          function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor) descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
          };
        }();

        var _get = function get(object, property, receiver) {
          if (object === null) object = Function.prototype;
          var desc = Object.getOwnPropertyDescriptor(object, property);

          if (desc === undefined) {
            var parent = Object.getPrototypeOf(object);

            if (parent === null) {
              return undefined;
            } else {
              return get(parent, property, receiver);
            }
          } else if ("value" in desc) {
            return desc.value;
          } else {
            var getter = desc.get;

            if (getter === undefined) {
              return undefined;
            }

            return getter.call(receiver);
          }
        };

        var _text = __webpack_require__(7);

        var _text2 = _interopRequireDefault(_text);

        var _parchment = __webpack_require__(0);

        var _parchment2 = _interopRequireDefault(_parchment);

        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : {
            "default": obj
          };
        }

        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }

        function _possibleConstructorReturn(self, call) {
          if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }

          return call && (_typeof(call) === "object" || typeof call === "function") ? call : self;
        }

        function _inherits(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + _typeof(superClass));
          }

          subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
              value: subClass,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }

        var Inline = function (_Parchment$Inline) {
          _inherits(Inline, _Parchment$Inline);

          function Inline() {
            _classCallCheck(this, Inline);

            return _possibleConstructorReturn(this, (Inline.__proto__ || Object.getPrototypeOf(Inline)).apply(this, arguments));
          }

          _createClass(Inline, [{
            key: 'formatAt',
            value: function formatAt(index, length, name, value) {
              if (Inline.compare(this.statics.blotName, name) < 0 && _parchment2["default"].query(name, _parchment2["default"].Scope.BLOT)) {
                var blot = this.isolate(index, length);

                if (value) {
                  blot.wrap(name, value);
                }
              } else {
                _get(Inline.prototype.__proto__ || Object.getPrototypeOf(Inline.prototype), 'formatAt', this).call(this, index, length, name, value);
              }
            }
          }, {
            key: 'optimize',
            value: function optimize(context) {
              _get(Inline.prototype.__proto__ || Object.getPrototypeOf(Inline.prototype), 'optimize', this).call(this, context);

              if (this.parent instanceof Inline && Inline.compare(this.statics.blotName, this.parent.statics.blotName) > 0) {
                var parent = this.parent.isolate(this.offset(), this.length());
                this.moveChildren(parent);
                parent.wrap(this);
              }
            }
          }], [{
            key: 'compare',
            value: function compare(self, other) {
              var selfIndex = Inline.order.indexOf(self);
              var otherIndex = Inline.order.indexOf(other);

              if (selfIndex >= 0 || otherIndex >= 0) {
                return selfIndex - otherIndex;
              } else if (self === other) {
                return 0;
              } else if (self < other) {
                return -1;
              } else {
                return 1;
              }
            }
          }]);

          return Inline;
        }(_parchment2["default"].Inline);

        Inline.allowedChildren = [Inline, _parchment2["default"].Embed, _text2["default"]]; // Lower index means deeper in the DOM tree, since not found (-1) is for embeds

        Inline.order = ['cursor', 'inline', // Must be lower
        'underline', 'strike', 'italic', 'bold', 'script', 'link', 'code' // Must be higher
        ];
        exports["default"] = Inline;
        /***/
      },
      /* 7 */

      /***/
      function (module, exports, __webpack_require__) {

        Object.defineProperty(exports, "__esModule", {
          value: true
        });

        var _parchment = __webpack_require__(0);

        var _parchment2 = _interopRequireDefault(_parchment);

        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : {
            "default": obj
          };
        }

        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }

        function _possibleConstructorReturn(self, call) {
          if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }

          return call && (_typeof(call) === "object" || typeof call === "function") ? call : self;
        }

        function _inherits(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + _typeof(superClass));
          }

          subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
              value: subClass,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }

        var TextBlot = function (_Parchment$Text) {
          _inherits(TextBlot, _Parchment$Text);

          function TextBlot() {
            _classCallCheck(this, TextBlot);

            return _possibleConstructorReturn(this, (TextBlot.__proto__ || Object.getPrototypeOf(TextBlot)).apply(this, arguments));
          }

          return TextBlot;
        }(_parchment2["default"].Text);

        exports["default"] = TextBlot;
        /***/
      },
      /* 8 */

      /***/
      function (module, exports, __webpack_require__) {

        Object.defineProperty(exports, "__esModule", {
          value: true
        });

        var _createClass = function () {
          function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor) descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
          };
        }();

        var _get = function get(object, property, receiver) {
          if (object === null) object = Function.prototype;
          var desc = Object.getOwnPropertyDescriptor(object, property);

          if (desc === undefined) {
            var parent = Object.getPrototypeOf(object);

            if (parent === null) {
              return undefined;
            } else {
              return get(parent, property, receiver);
            }
          } else if ("value" in desc) {
            return desc.value;
          } else {
            var getter = desc.get;

            if (getter === undefined) {
              return undefined;
            }

            return getter.call(receiver);
          }
        };

        var _eventemitter = __webpack_require__(54);

        var _eventemitter2 = _interopRequireDefault(_eventemitter);

        var _logger = __webpack_require__(10);

        var _logger2 = _interopRequireDefault(_logger);

        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : {
            "default": obj
          };
        }

        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }

        function _possibleConstructorReturn(self, call) {
          if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }

          return call && (_typeof(call) === "object" || typeof call === "function") ? call : self;
        }

        function _inherits(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + _typeof(superClass));
          }

          subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
              value: subClass,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }

        var debug = (0, _logger2["default"])('quill:events');
        var EVENTS = ['selectionchange', 'mousedown', 'mouseup', 'click'];
        EVENTS.forEach(function (eventName) {
          document.addEventListener(eventName, function () {
            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }

            [].slice.call(document.querySelectorAll('.ql-container')).forEach(function (node) {
              // TODO use WeakMap
              if (node.__quill && node.__quill.emitter) {
                var _node$__quill$emitter;

                (_node$__quill$emitter = node.__quill.emitter).handleDOM.apply(_node$__quill$emitter, args);
              }
            });
          });
        });

        var Emitter = function (_EventEmitter) {
          _inherits(Emitter, _EventEmitter);

          function Emitter() {
            _classCallCheck(this, Emitter);

            var _this = _possibleConstructorReturn(this, (Emitter.__proto__ || Object.getPrototypeOf(Emitter)).call(this));

            _this.listeners = {};

            _this.on('error', debug.error);

            return _this;
          }

          _createClass(Emitter, [{
            key: 'emit',
            value: function emit() {
              debug.log.apply(debug, arguments);

              _get(Emitter.prototype.__proto__ || Object.getPrototypeOf(Emitter.prototype), 'emit', this).apply(this, arguments);
            }
          }, {
            key: 'handleDOM',
            value: function handleDOM(event) {
              for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                args[_key2 - 1] = arguments[_key2];
              }

              (this.listeners[event.type] || []).forEach(function (_ref) {
                var node = _ref.node,
                    handler = _ref.handler;

                if (event.target === node || node.contains(event.target)) {
                  handler.apply(undefined, [event].concat(args));
                }
              });
            }
          }, {
            key: 'listenDOM',
            value: function listenDOM(eventName, node, handler) {
              if (!this.listeners[eventName]) {
                this.listeners[eventName] = [];
              }

              this.listeners[eventName].push({
                node: node,
                handler: handler
              });
            }
          }]);

          return Emitter;
        }(_eventemitter2["default"]);

        Emitter.events = {
          EDITOR_CHANGE: 'editor-change',
          SCROLL_BEFORE_UPDATE: 'scroll-before-update',
          SCROLL_OPTIMIZE: 'scroll-optimize',
          SCROLL_UPDATE: 'scroll-update',
          SELECTION_CHANGE: 'selection-change',
          TEXT_CHANGE: 'text-change'
        };
        Emitter.sources = {
          API: 'api',
          SILENT: 'silent',
          USER: 'user'
        };
        exports["default"] = Emitter;
        /***/
      },
      /* 9 */

      /***/
      function (module, exports, __webpack_require__) {

        Object.defineProperty(exports, "__esModule", {
          value: true
        });

        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }

        var Module = function Module(quill) {
          var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

          _classCallCheck(this, Module);

          this.quill = quill;
          this.options = options;
        };

        Module.DEFAULTS = {};
        exports["default"] = Module;
        /***/
      },
      /* 10 */

      /***/
      function (module, exports, __webpack_require__) {

        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        var levels = ['error', 'warn', 'log', 'info'];
        var level = 'warn';

        function debug(method) {
          if (levels.indexOf(method) <= levels.indexOf(level)) {
            var _console;

            for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }

            (_console = console)[method].apply(_console, args); // eslint-disable-line no-console

          }
        }

        function namespace(ns) {
          return levels.reduce(function (logger, method) {
            logger[method] = debug.bind(console, method, ns);
            return logger;
          }, {});
        }

        debug.level = namespace.level = function (newLevel) {
          level = newLevel;
        };

        exports["default"] = namespace;
        /***/
      },
      /* 11 */

      /***/
      function (module, exports, __webpack_require__) {
        var pSlice = Array.prototype.slice;

        var objectKeys = __webpack_require__(52);

        var isArguments = __webpack_require__(53);

        var deepEqual = module.exports = function (actual, expected, opts) {
          if (!opts) opts = {}; // 7.1. All identical values are equivalent, as determined by ===.

          if (actual === expected) {
            return true;
          } else if (actual instanceof Date && expected instanceof Date) {
            return actual.getTime() === expected.getTime(); // 7.3. Other pairs that do not both pass typeof value == 'object',
            // equivalence is determined by ==.
          } else if (!actual || !expected || _typeof(actual) != 'object' && _typeof(expected) != 'object') {
            return opts.strict ? actual === expected : actual == expected; // 7.4. For all other Object pairs, including Array objects, equivalence is
            // determined by having the same number of owned properties (as verified
            // with Object.prototype.hasOwnProperty.call), the same set of keys
            // (although not necessarily the same order), equivalent values for every
            // corresponding key, and an identical 'prototype' property. Note: this
            // accounts for both named and indexed properties on Arrays.
          } else {
            return objEquiv(actual, expected, opts);
          }
        };

        function isUndefinedOrNull(value) {
          return value === null || value === undefined;
        }

        function isBuffer(x) {
          if (!x || _typeof(x) !== 'object' || typeof x.length !== 'number') return false;

          if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {
            return false;
          }

          if (x.length > 0 && typeof x[0] !== 'number') return false;
          return true;
        }

        function objEquiv(a, b, opts) {
          var i, key;
          if (isUndefinedOrNull(a) || isUndefinedOrNull(b)) return false; // an identical 'prototype' property.

          if (a.prototype !== b.prototype) return false; //~~~I've managed to break Object.keys through screwy arguments passing.
          //   Converting to array solves the problem.

          if (isArguments(a)) {
            if (!isArguments(b)) {
              return false;
            }

            a = pSlice.call(a);
            b = pSlice.call(b);
            return deepEqual(a, b, opts);
          }

          if (isBuffer(a)) {
            if (!isBuffer(b)) {
              return false;
            }

            if (a.length !== b.length) return false;

            for (i = 0; i < a.length; i++) {
              if (a[i] !== b[i]) return false;
            }

            return true;
          }

          try {
            var ka = objectKeys(a),
                kb = objectKeys(b);
          } catch (e) {
            //happens when one is a string literal and the other isn't
            return false;
          } // having the same number of owned properties (keys incorporates
          // hasOwnProperty)


          if (ka.length != kb.length) return false; //the same set of keys (although not necessarily the same order),

          ka.sort();
          kb.sort(); //~~~cheap key test

          for (i = ka.length - 1; i >= 0; i--) {
            if (ka[i] != kb[i]) return false;
          } //equivalent values for every corresponding key, and
          //~~~possibly expensive deep test


          for (i = ka.length - 1; i >= 0; i--) {
            key = ka[i];
            if (!deepEqual(a[key], b[key], opts)) return false;
          }

          return _typeof(a) === _typeof(b);
        }
        /***/

      },
      /* 12 */

      /***/
      function (module, exports, __webpack_require__) {

        Object.defineProperty(exports, "__esModule", {
          value: true
        });

        var Registry = __webpack_require__(1);

        var Attributor =
        /** @class */
        function () {
          function Attributor(attrName, keyName, options) {
            if (options === void 0) {
              options = {};
            }

            this.attrName = attrName;
            this.keyName = keyName;
            var attributeBit = Registry.Scope.TYPE & Registry.Scope.ATTRIBUTE;

            if (options.scope != null) {
              // Ignore type bits, force attribute bit
              this.scope = options.scope & Registry.Scope.LEVEL | attributeBit;
            } else {
              this.scope = Registry.Scope.ATTRIBUTE;
            }

            if (options.whitelist != null) this.whitelist = options.whitelist;
          }

          Attributor.keys = function (node) {
            return [].map.call(node.attributes, function (item) {
              return item.name;
            });
          };

          Attributor.prototype.add = function (node, value) {
            if (!this.canAdd(node, value)) return false;
            node.setAttribute(this.keyName, value);
            return true;
          };

          Attributor.prototype.canAdd = function (node, value) {
            var match = Registry.query(node, Registry.Scope.BLOT & (this.scope | Registry.Scope.TYPE));
            if (match == null) return false;
            if (this.whitelist == null) return true;

            if (typeof value === 'string') {
              return this.whitelist.indexOf(value.replace(/["']/g, '')) > -1;
            } else {
              return this.whitelist.indexOf(value) > -1;
            }
          };

          Attributor.prototype.remove = function (node) {
            node.removeAttribute(this.keyName);
          };

          Attributor.prototype.value = function (node) {
            var value = node.getAttribute(this.keyName);

            if (this.canAdd(node, value) && value) {
              return value;
            }

            return '';
          };

          return Attributor;
        }();

        exports["default"] = Attributor;
        /***/
      },
      /* 13 */

      /***/
      function (module, exports, __webpack_require__) {

        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports["default"] = exports.Code = undefined;

        var _slicedToArray = function () {
          function sliceIterator(arr, i) {
            var _arr = [];
            var _n = true;
            var _d = false;
            var _e = undefined;

            try {
              for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                _arr.push(_s.value);

                if (i && _arr.length === i) break;
              }
            } catch (err) {
              _d = true;
              _e = err;
            } finally {
              try {
                if (!_n && _i["return"]) _i["return"]();
              } finally {
                if (_d) throw _e;
              }
            }

            return _arr;
          }

          return function (arr, i) {
            if (Array.isArray(arr)) {
              return arr;
            } else if (Symbol.iterator in Object(arr)) {
              return sliceIterator(arr, i);
            } else {
              throw new TypeError("Invalid attempt to destructure non-iterable instance");
            }
          };
        }();

        var _createClass = function () {
          function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor) descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
          };
        }();

        var _get = function get(object, property, receiver) {
          if (object === null) object = Function.prototype;
          var desc = Object.getOwnPropertyDescriptor(object, property);

          if (desc === undefined) {
            var parent = Object.getPrototypeOf(object);

            if (parent === null) {
              return undefined;
            } else {
              return get(parent, property, receiver);
            }
          } else if ("value" in desc) {
            return desc.value;
          } else {
            var getter = desc.get;

            if (getter === undefined) {
              return undefined;
            }

            return getter.call(receiver);
          }
        };

        var _quillDelta = __webpack_require__(2);

        var _quillDelta2 = _interopRequireDefault(_quillDelta);

        var _parchment = __webpack_require__(0);

        var _parchment2 = _interopRequireDefault(_parchment);

        var _block = __webpack_require__(4);

        var _block2 = _interopRequireDefault(_block);

        var _inline = __webpack_require__(6);

        var _inline2 = _interopRequireDefault(_inline);

        var _text = __webpack_require__(7);

        var _text2 = _interopRequireDefault(_text);

        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : {
            "default": obj
          };
        }

        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }

        function _possibleConstructorReturn(self, call) {
          if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }

          return call && (_typeof(call) === "object" || typeof call === "function") ? call : self;
        }

        function _inherits(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + _typeof(superClass));
          }

          subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
              value: subClass,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }

        var Code = function (_Inline) {
          _inherits(Code, _Inline);

          function Code() {
            _classCallCheck(this, Code);

            return _possibleConstructorReturn(this, (Code.__proto__ || Object.getPrototypeOf(Code)).apply(this, arguments));
          }

          return Code;
        }(_inline2["default"]);

        Code.blotName = 'code';
        Code.tagName = 'CODE';

        var CodeBlock = function (_Block) {
          _inherits(CodeBlock, _Block);

          function CodeBlock() {
            _classCallCheck(this, CodeBlock);

            return _possibleConstructorReturn(this, (CodeBlock.__proto__ || Object.getPrototypeOf(CodeBlock)).apply(this, arguments));
          }

          _createClass(CodeBlock, [{
            key: 'delta',
            value: function delta() {
              var _this3 = this;

              var text = this.domNode.textContent;

              if (text.endsWith('\n')) {
                // Should always be true
                text = text.slice(0, -1);
              }

              return text.split('\n').reduce(function (delta, frag) {
                return delta.insert(frag).insert('\n', _this3.formats());
              }, new _quillDelta2["default"]());
            }
          }, {
            key: 'format',
            value: function format(name, value) {
              if (name === this.statics.blotName && value) return;

              var _descendant = this.descendant(_text2["default"], this.length() - 1),
                  _descendant2 = _slicedToArray(_descendant, 1),
                  text = _descendant2[0];

              if (text != null) {
                text.deleteAt(text.length() - 1, 1);
              }

              _get(CodeBlock.prototype.__proto__ || Object.getPrototypeOf(CodeBlock.prototype), 'format', this).call(this, name, value);
            }
          }, {
            key: 'formatAt',
            value: function formatAt(index, length, name, value) {
              if (length === 0) return;

              if (_parchment2["default"].query(name, _parchment2["default"].Scope.BLOCK) == null || name === this.statics.blotName && value === this.statics.formats(this.domNode)) {
                return;
              }

              var nextNewline = this.newlineIndex(index);
              if (nextNewline < 0 || nextNewline >= index + length) return;
              var prevNewline = this.newlineIndex(index, true) + 1;
              var isolateLength = nextNewline - prevNewline + 1;
              var blot = this.isolate(prevNewline, isolateLength);
              var next = blot.next;
              blot.format(name, value);

              if (next instanceof CodeBlock) {
                next.formatAt(0, index - prevNewline + length - isolateLength, name, value);
              }
            }
          }, {
            key: 'insertAt',
            value: function insertAt(index, value, def) {
              if (def != null) return;

              var _descendant3 = this.descendant(_text2["default"], index),
                  _descendant4 = _slicedToArray(_descendant3, 2),
                  text = _descendant4[0],
                  offset = _descendant4[1];

              text.insertAt(offset, value);
            }
          }, {
            key: 'length',
            value: function length() {
              var length = this.domNode.textContent.length;

              if (!this.domNode.textContent.endsWith('\n')) {
                return length + 1;
              }

              return length;
            }
          }, {
            key: 'newlineIndex',
            value: function newlineIndex(searchIndex) {
              var reverse = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

              if (!reverse) {
                var offset = this.domNode.textContent.slice(searchIndex).indexOf('\n');
                return offset > -1 ? searchIndex + offset : -1;
              } else {
                return this.domNode.textContent.slice(0, searchIndex).lastIndexOf('\n');
              }
            }
          }, {
            key: 'optimize',
            value: function optimize(context) {
              if (!this.domNode.textContent.endsWith('\n')) {
                this.appendChild(_parchment2["default"].create('text', '\n'));
              }

              _get(CodeBlock.prototype.__proto__ || Object.getPrototypeOf(CodeBlock.prototype), 'optimize', this).call(this, context);

              var next = this.next;

              if (next != null && next.prev === this && next.statics.blotName === this.statics.blotName && this.statics.formats(this.domNode) === next.statics.formats(next.domNode)) {
                next.optimize(context);
                next.moveChildren(this);
                next.remove();
              }
            }
          }, {
            key: 'replace',
            value: function replace(target) {
              _get(CodeBlock.prototype.__proto__ || Object.getPrototypeOf(CodeBlock.prototype), 'replace', this).call(this, target);

              [].slice.call(this.domNode.querySelectorAll('*')).forEach(function (node) {
                var blot = _parchment2["default"].find(node);

                if (blot == null) {
                  node.parentNode.removeChild(node);
                } else if (blot instanceof _parchment2["default"].Embed) {
                  blot.remove();
                } else {
                  blot.unwrap();
                }
              });
            }
          }], [{
            key: 'create',
            value: function create(value) {
              var domNode = _get(CodeBlock.__proto__ || Object.getPrototypeOf(CodeBlock), 'create', this).call(this, value);

              domNode.setAttribute('spellcheck', false);
              return domNode;
            }
          }, {
            key: 'formats',
            value: function formats() {
              return true;
            }
          }]);

          return CodeBlock;
        }(_block2["default"]);

        CodeBlock.blotName = 'code-block';
        CodeBlock.tagName = 'PRE';
        CodeBlock.TAB = '  ';
        exports.Code = Code;
        exports["default"] = CodeBlock;
        /***/
      },
      /* 14 */

      /***/
      function (module, exports, __webpack_require__) {

        Object.defineProperty(exports, "__esModule", {
          value: true
        });

        var _typeof$1 = typeof Symbol === "function" && _typeof(Symbol.iterator) === "symbol" ? function (obj) {
          return _typeof(obj);
        } : function (obj) {
          return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof(obj);
        };

        var _slicedToArray = function () {
          function sliceIterator(arr, i) {
            var _arr = [];
            var _n = true;
            var _d = false;
            var _e = undefined;

            try {
              for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                _arr.push(_s.value);

                if (i && _arr.length === i) break;
              }
            } catch (err) {
              _d = true;
              _e = err;
            } finally {
              try {
                if (!_n && _i["return"]) _i["return"]();
              } finally {
                if (_d) throw _e;
              }
            }

            return _arr;
          }

          return function (arr, i) {
            if (Array.isArray(arr)) {
              return arr;
            } else if (Symbol.iterator in Object(arr)) {
              return sliceIterator(arr, i);
            } else {
              throw new TypeError("Invalid attempt to destructure non-iterable instance");
            }
          };
        }();

        var _createClass = function () {
          function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor) descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
          };
        }();

        var _quillDelta = __webpack_require__(2);

        var _quillDelta2 = _interopRequireDefault(_quillDelta);

        var _op = __webpack_require__(20);

        var _op2 = _interopRequireDefault(_op);

        var _parchment = __webpack_require__(0);

        var _parchment2 = _interopRequireDefault(_parchment);

        var _code = __webpack_require__(13);

        var _code2 = _interopRequireDefault(_code);

        var _cursor = __webpack_require__(24);

        var _cursor2 = _interopRequireDefault(_cursor);

        var _block = __webpack_require__(4);

        var _block2 = _interopRequireDefault(_block);

        var _break = __webpack_require__(16);

        var _break2 = _interopRequireDefault(_break);

        var _clone = __webpack_require__(21);

        var _clone2 = _interopRequireDefault(_clone);

        var _deepEqual = __webpack_require__(11);

        var _deepEqual2 = _interopRequireDefault(_deepEqual);

        var _extend = __webpack_require__(3);

        var _extend2 = _interopRequireDefault(_extend);

        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : {
            "default": obj
          };
        }

        function _defineProperty(obj, key, value) {
          if (key in obj) {
            Object.defineProperty(obj, key, {
              value: value,
              enumerable: true,
              configurable: true,
              writable: true
            });
          } else {
            obj[key] = value;
          }

          return obj;
        }

        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }

        var ASCII = /^[ -~]*$/;

        var Editor = function () {
          function Editor(scroll) {
            _classCallCheck(this, Editor);

            this.scroll = scroll;
            this.delta = this.getDelta();
          }

          _createClass(Editor, [{
            key: 'applyDelta',
            value: function applyDelta(delta) {
              var _this = this;

              var consumeNextNewline = false;
              this.scroll.update();
              var scrollLength = this.scroll.length();
              this.scroll.batchStart();
              delta = normalizeDelta(delta);
              delta.reduce(function (index, op) {
                var length = op.retain || op["delete"] || op.insert.length || 1;
                var attributes = op.attributes || {};

                if (op.insert != null) {
                  if (typeof op.insert === 'string') {
                    var text = op.insert;

                    if (text.endsWith('\n') && consumeNextNewline) {
                      consumeNextNewline = false;
                      text = text.slice(0, -1);
                    }

                    if (index >= scrollLength && !text.endsWith('\n')) {
                      consumeNextNewline = true;
                    }

                    _this.scroll.insertAt(index, text);

                    var _scroll$line = _this.scroll.line(index),
                        _scroll$line2 = _slicedToArray(_scroll$line, 2),
                        line = _scroll$line2[0],
                        offset = _scroll$line2[1];

                    var formats = (0, _extend2["default"])({}, (0, _block.bubbleFormats)(line));

                    if (line instanceof _block2["default"]) {
                      var _line$descendant = line.descendant(_parchment2["default"].Leaf, offset),
                          _line$descendant2 = _slicedToArray(_line$descendant, 1),
                          leaf = _line$descendant2[0];

                      formats = (0, _extend2["default"])(formats, (0, _block.bubbleFormats)(leaf));
                    }

                    attributes = _op2["default"].attributes.diff(formats, attributes) || {};
                  } else if (_typeof$1(op.insert) === 'object') {
                    var key = Object.keys(op.insert)[0]; // There should only be one key

                    if (key == null) return index;

                    _this.scroll.insertAt(index, key, op.insert[key]);
                  }

                  scrollLength += length;
                }

                Object.keys(attributes).forEach(function (name) {
                  _this.scroll.formatAt(index, length, name, attributes[name]);
                });
                return index + length;
              }, 0);
              delta.reduce(function (index, op) {
                if (typeof op["delete"] === 'number') {
                  _this.scroll.deleteAt(index, op["delete"]);

                  return index;
                }

                return index + (op.retain || op.insert.length || 1);
              }, 0);
              this.scroll.batchEnd();
              return this.update(delta);
            }
          }, {
            key: 'deleteText',
            value: function deleteText(index, length) {
              this.scroll.deleteAt(index, length);
              return this.update(new _quillDelta2["default"]().retain(index)["delete"](length));
            }
          }, {
            key: 'formatLine',
            value: function formatLine(index, length) {
              var _this2 = this;

              var formats = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
              this.scroll.update();
              Object.keys(formats).forEach(function (format) {
                if (_this2.scroll.whitelist != null && !_this2.scroll.whitelist[format]) return;

                var lines = _this2.scroll.lines(index, Math.max(length, 1));

                var lengthRemaining = length;
                lines.forEach(function (line) {
                  var lineLength = line.length();

                  if (!(line instanceof _code2["default"])) {
                    line.format(format, formats[format]);
                  } else {
                    var codeIndex = index - line.offset(_this2.scroll);
                    var codeLength = line.newlineIndex(codeIndex + lengthRemaining) - codeIndex + 1;
                    line.formatAt(codeIndex, codeLength, format, formats[format]);
                  }

                  lengthRemaining -= lineLength;
                });
              });
              this.scroll.optimize();
              return this.update(new _quillDelta2["default"]().retain(index).retain(length, (0, _clone2["default"])(formats)));
            }
          }, {
            key: 'formatText',
            value: function formatText(index, length) {
              var _this3 = this;

              var formats = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
              Object.keys(formats).forEach(function (format) {
                _this3.scroll.formatAt(index, length, format, formats[format]);
              });
              return this.update(new _quillDelta2["default"]().retain(index).retain(length, (0, _clone2["default"])(formats)));
            }
          }, {
            key: 'getContents',
            value: function getContents(index, length) {
              return this.delta.slice(index, index + length);
            }
          }, {
            key: 'getDelta',
            value: function getDelta() {
              return this.scroll.lines().reduce(function (delta, line) {
                return delta.concat(line.delta());
              }, new _quillDelta2["default"]());
            }
          }, {
            key: 'getFormat',
            value: function getFormat(index) {
              var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
              var lines = [],
                  leaves = [];

              if (length === 0) {
                this.scroll.path(index).forEach(function (path) {
                  var _path = _slicedToArray(path, 1),
                      blot = _path[0];

                  if (blot instanceof _block2["default"]) {
                    lines.push(blot);
                  } else if (blot instanceof _parchment2["default"].Leaf) {
                    leaves.push(blot);
                  }
                });
              } else {
                lines = this.scroll.lines(index, length);
                leaves = this.scroll.descendants(_parchment2["default"].Leaf, index, length);
              }

              var formatsArr = [lines, leaves].map(function (blots) {
                if (blots.length === 0) return {};
                var formats = (0, _block.bubbleFormats)(blots.shift());

                while (Object.keys(formats).length > 0) {
                  var blot = blots.shift();
                  if (blot == null) return formats;
                  formats = combineFormats((0, _block.bubbleFormats)(blot), formats);
                }

                return formats;
              });
              return _extend2["default"].apply(_extend2["default"], formatsArr);
            }
          }, {
            key: 'getText',
            value: function getText(index, length) {
              return this.getContents(index, length).filter(function (op) {
                return typeof op.insert === 'string';
              }).map(function (op) {
                return op.insert;
              }).join('');
            }
          }, {
            key: 'insertEmbed',
            value: function insertEmbed(index, embed, value) {
              this.scroll.insertAt(index, embed, value);
              return this.update(new _quillDelta2["default"]().retain(index).insert(_defineProperty({}, embed, value)));
            }
          }, {
            key: 'insertText',
            value: function insertText(index, text) {
              var _this4 = this;

              var formats = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
              text = text.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
              this.scroll.insertAt(index, text);
              Object.keys(formats).forEach(function (format) {
                _this4.scroll.formatAt(index, text.length, format, formats[format]);
              });
              return this.update(new _quillDelta2["default"]().retain(index).insert(text, (0, _clone2["default"])(formats)));
            }
          }, {
            key: 'isBlank',
            value: function isBlank() {
              if (this.scroll.children.length == 0) return true;
              if (this.scroll.children.length > 1) return false;
              var block = this.scroll.children.head;
              if (block.statics.blotName !== _block2["default"].blotName) return false;
              if (block.children.length > 1) return false;
              return block.children.head instanceof _break2["default"];
            }
          }, {
            key: 'removeFormat',
            value: function removeFormat(index, length) {
              var text = this.getText(index, length);

              var _scroll$line3 = this.scroll.line(index + length),
                  _scroll$line4 = _slicedToArray(_scroll$line3, 2),
                  line = _scroll$line4[0],
                  offset = _scroll$line4[1];

              var suffixLength = 0,
                  suffix = new _quillDelta2["default"]();

              if (line != null) {
                if (!(line instanceof _code2["default"])) {
                  suffixLength = line.length() - offset;
                } else {
                  suffixLength = line.newlineIndex(offset) - offset + 1;
                }

                suffix = line.delta().slice(offset, offset + suffixLength - 1).insert('\n');
              }

              var contents = this.getContents(index, length + suffixLength);
              var diff = contents.diff(new _quillDelta2["default"]().insert(text).concat(suffix));
              var delta = new _quillDelta2["default"]().retain(index).concat(diff);
              return this.applyDelta(delta);
            }
          }, {
            key: 'update',
            value: function update(change) {
              var mutations = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
              var cursorIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
              var oldDelta = this.delta;

              if (mutations.length === 1 && mutations[0].type === 'characterData' && mutations[0].target.data.match(ASCII) && _parchment2["default"].find(mutations[0].target)) {
                // Optimization for character changes
                var textBlot = _parchment2["default"].find(mutations[0].target);

                var formats = (0, _block.bubbleFormats)(textBlot);
                var index = textBlot.offset(this.scroll);
                var oldValue = mutations[0].oldValue.replace(_cursor2["default"].CONTENTS, '');
                var oldText = new _quillDelta2["default"]().insert(oldValue);
                var newText = new _quillDelta2["default"]().insert(textBlot.value());
                var diffDelta = new _quillDelta2["default"]().retain(index).concat(oldText.diff(newText, cursorIndex));
                change = diffDelta.reduce(function (delta, op) {
                  if (op.insert) {
                    return delta.insert(op.insert, formats);
                  } else {
                    return delta.push(op);
                  }
                }, new _quillDelta2["default"]());
                this.delta = oldDelta.compose(change);
              } else {
                this.delta = this.getDelta();

                if (!change || !(0, _deepEqual2["default"])(oldDelta.compose(change), this.delta)) {
                  change = oldDelta.diff(this.delta, cursorIndex);
                }
              }

              return change;
            }
          }]);

          return Editor;
        }();

        function combineFormats(formats, combined) {
          return Object.keys(combined).reduce(function (merged, name) {
            if (formats[name] == null) return merged;

            if (combined[name] === formats[name]) {
              merged[name] = combined[name];
            } else if (Array.isArray(combined[name])) {
              if (combined[name].indexOf(formats[name]) < 0) {
                merged[name] = combined[name].concat([formats[name]]);
              }
            } else {
              merged[name] = [combined[name], formats[name]];
            }

            return merged;
          }, {});
        }

        function normalizeDelta(delta) {
          return delta.reduce(function (delta, op) {
            if (op.insert === 1) {
              var attributes = (0, _clone2["default"])(op.attributes);
              delete attributes['image'];
              return delta.insert({
                image: op.attributes.image
              }, attributes);
            }

            if (op.attributes != null && (op.attributes.list === true || op.attributes.bullet === true)) {
              op = (0, _clone2["default"])(op);

              if (op.attributes.list) {
                op.attributes.list = 'ordered';
              } else {
                op.attributes.list = 'bullet';
                delete op.attributes.bullet;
              }
            }

            if (typeof op.insert === 'string') {
              var text = op.insert.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
              return delta.insert(text, op.attributes);
            }

            return delta.push(op);
          }, new _quillDelta2["default"]());
        }

        exports["default"] = Editor;
        /***/
      },
      /* 15 */

      /***/
      function (module, exports, __webpack_require__) {

        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports["default"] = exports.Range = undefined;

        var _slicedToArray = function () {
          function sliceIterator(arr, i) {
            var _arr = [];
            var _n = true;
            var _d = false;
            var _e = undefined;

            try {
              for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                _arr.push(_s.value);

                if (i && _arr.length === i) break;
              }
            } catch (err) {
              _d = true;
              _e = err;
            } finally {
              try {
                if (!_n && _i["return"]) _i["return"]();
              } finally {
                if (_d) throw _e;
              }
            }

            return _arr;
          }

          return function (arr, i) {
            if (Array.isArray(arr)) {
              return arr;
            } else if (Symbol.iterator in Object(arr)) {
              return sliceIterator(arr, i);
            } else {
              throw new TypeError("Invalid attempt to destructure non-iterable instance");
            }
          };
        }();

        var _createClass = function () {
          function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor) descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
          };
        }();

        var _parchment = __webpack_require__(0);

        var _parchment2 = _interopRequireDefault(_parchment);

        var _clone = __webpack_require__(21);

        var _clone2 = _interopRequireDefault(_clone);

        var _deepEqual = __webpack_require__(11);

        var _deepEqual2 = _interopRequireDefault(_deepEqual);

        var _emitter3 = __webpack_require__(8);

        var _emitter4 = _interopRequireDefault(_emitter3);

        var _logger = __webpack_require__(10);

        var _logger2 = _interopRequireDefault(_logger);

        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : {
            "default": obj
          };
        }

        function _toConsumableArray(arr) {
          if (Array.isArray(arr)) {
            for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
              arr2[i] = arr[i];
            }

            return arr2;
          } else {
            return Array.from(arr);
          }
        }

        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }

        var debug = (0, _logger2["default"])('quill:selection');

        var Range = function Range(index) {
          var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

          _classCallCheck(this, Range);

          this.index = index;
          this.length = length;
        };

        var Selection = function () {
          function Selection(scroll, emitter) {
            var _this = this;

            _classCallCheck(this, Selection);

            this.emitter = emitter;
            this.scroll = scroll;
            this.composing = false;
            this.mouseDown = false;
            this.root = this.scroll.domNode;
            this.cursor = _parchment2["default"].create('cursor', this); // savedRange is last non-null range

            this.lastRange = this.savedRange = new Range(0, 0);
            this.handleComposition();
            this.handleDragging();
            this.emitter.listenDOM('selectionchange', document, function () {
              if (!_this.mouseDown) {
                setTimeout(_this.update.bind(_this, _emitter4["default"].sources.USER), 1);
              }
            });
            this.emitter.on(_emitter4["default"].events.EDITOR_CHANGE, function (type, delta) {
              if (type === _emitter4["default"].events.TEXT_CHANGE && delta.length() > 0) {
                _this.update(_emitter4["default"].sources.SILENT);
              }
            });
            this.emitter.on(_emitter4["default"].events.SCROLL_BEFORE_UPDATE, function () {
              if (!_this.hasFocus()) return;

              var _native = _this.getNativeRange();

              if (_native == null) return;
              if (_native.start.node === _this.cursor.textNode) return; // cursor.restore() will handle
              // TODO unclear if this has negative side effects

              _this.emitter.once(_emitter4["default"].events.SCROLL_UPDATE, function () {
                try {
                  _this.setNativeRange(_native.start.node, _native.start.offset, _native.end.node, _native.end.offset);
                } catch (ignored) {}
              });
            });
            this.emitter.on(_emitter4["default"].events.SCROLL_OPTIMIZE, function (mutations, context) {
              if (context.range) {
                var _context$range = context.range,
                    startNode = _context$range.startNode,
                    startOffset = _context$range.startOffset,
                    endNode = _context$range.endNode,
                    endOffset = _context$range.endOffset;

                _this.setNativeRange(startNode, startOffset, endNode, endOffset);
              }
            });
            this.update(_emitter4["default"].sources.SILENT);
          }

          _createClass(Selection, [{
            key: 'handleComposition',
            value: function handleComposition() {
              var _this2 = this;

              this.root.addEventListener('compositionstart', function () {
                _this2.composing = true;
              });
              this.root.addEventListener('compositionend', function () {
                _this2.composing = false;

                if (_this2.cursor.parent) {
                  var range = _this2.cursor.restore();

                  if (!range) return;
                  setTimeout(function () {
                    _this2.setNativeRange(range.startNode, range.startOffset, range.endNode, range.endOffset);
                  }, 1);
                }
              });
            }
          }, {
            key: 'handleDragging',
            value: function handleDragging() {
              var _this3 = this;

              this.emitter.listenDOM('mousedown', document.body, function () {
                _this3.mouseDown = true;
              });
              this.emitter.listenDOM('mouseup', document.body, function () {
                _this3.mouseDown = false;

                _this3.update(_emitter4["default"].sources.USER);
              });
            }
          }, {
            key: 'focus',
            value: function focus() {
              if (this.hasFocus()) return;
              this.root.focus();
              this.setRange(this.savedRange);
            }
          }, {
            key: 'format',
            value: function format(_format, value) {
              if (this.scroll.whitelist != null && !this.scroll.whitelist[_format]) return;
              this.scroll.update();
              var nativeRange = this.getNativeRange();
              if (nativeRange == null || !nativeRange["native"].collapsed || _parchment2["default"].query(_format, _parchment2["default"].Scope.BLOCK)) return;

              if (nativeRange.start.node !== this.cursor.textNode) {
                var blot = _parchment2["default"].find(nativeRange.start.node, false);

                if (blot == null) return; // TODO Give blot ability to not split

                if (blot instanceof _parchment2["default"].Leaf) {
                  var after = blot.split(nativeRange.start.offset);
                  blot.parent.insertBefore(this.cursor, after);
                } else {
                  blot.insertBefore(this.cursor, nativeRange.start.node); // Should never happen
                }

                this.cursor.attach();
              }

              this.cursor.format(_format, value);
              this.scroll.optimize();
              this.setNativeRange(this.cursor.textNode, this.cursor.textNode.data.length);
              this.update();
            }
          }, {
            key: 'getBounds',
            value: function getBounds(index) {
              var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
              var scrollLength = this.scroll.length();
              index = Math.min(index, scrollLength - 1);
              length = Math.min(index + length, scrollLength - 1) - index;

              var node = void 0,
                  _scroll$leaf = this.scroll.leaf(index),
                  _scroll$leaf2 = _slicedToArray(_scroll$leaf, 2),
                  leaf = _scroll$leaf2[0],
                  offset = _scroll$leaf2[1];

              if (leaf == null) return null;

              var _leaf$position = leaf.position(offset, true);

              var _leaf$position2 = _slicedToArray(_leaf$position, 2);

              node = _leaf$position2[0];
              offset = _leaf$position2[1];
              var range = document.createRange();

              if (length > 0) {
                range.setStart(node, offset);

                var _scroll$leaf3 = this.scroll.leaf(index + length);

                var _scroll$leaf4 = _slicedToArray(_scroll$leaf3, 2);

                leaf = _scroll$leaf4[0];
                offset = _scroll$leaf4[1];
                if (leaf == null) return null;

                var _leaf$position3 = leaf.position(offset, true);

                var _leaf$position4 = _slicedToArray(_leaf$position3, 2);

                node = _leaf$position4[0];
                offset = _leaf$position4[1];
                range.setEnd(node, offset);
                return range.getBoundingClientRect();
              } else {
                var side = 'left';
                var rect = void 0;

                if (node instanceof Text) {
                  if (offset < node.data.length) {
                    range.setStart(node, offset);
                    range.setEnd(node, offset + 1);
                  } else {
                    range.setStart(node, offset - 1);
                    range.setEnd(node, offset);
                    side = 'right';
                  }

                  rect = range.getBoundingClientRect();
                } else {
                  rect = leaf.domNode.getBoundingClientRect();
                  if (offset > 0) side = 'right';
                }

                return {
                  bottom: rect.top + rect.height,
                  height: rect.height,
                  left: rect[side],
                  right: rect[side],
                  top: rect.top,
                  width: 0
                };
              }
            }
          }, {
            key: 'getNativeRange',
            value: function getNativeRange() {
              var selection = document.getSelection();
              if (selection == null || selection.rangeCount <= 0) return null;
              var nativeRange = selection.getRangeAt(0);
              if (nativeRange == null) return null;
              var range = this.normalizeNative(nativeRange);
              debug.info('getNativeRange', range);
              return range;
            }
          }, {
            key: 'getRange',
            value: function getRange() {
              var normalized = this.getNativeRange();
              if (normalized == null) return [null, null];
              var range = this.normalizedToRange(normalized);
              return [range, normalized];
            }
          }, {
            key: 'hasFocus',
            value: function hasFocus() {
              return document.activeElement === this.root;
            }
          }, {
            key: 'normalizedToRange',
            value: function normalizedToRange(range) {
              var _this4 = this;

              var positions = [[range.start.node, range.start.offset]];

              if (!range["native"].collapsed) {
                positions.push([range.end.node, range.end.offset]);
              }

              var indexes = positions.map(function (position) {
                var _position = _slicedToArray(position, 2),
                    node = _position[0],
                    offset = _position[1];

                var blot = _parchment2["default"].find(node, true);

                var index = blot.offset(_this4.scroll);

                if (offset === 0) {
                  return index;
                } else if (blot instanceof _parchment2["default"].Container) {
                  return index + blot.length();
                } else {
                  return index + blot.index(node, offset);
                }
              });
              var end = Math.min(Math.max.apply(Math, _toConsumableArray(indexes)), this.scroll.length() - 1);
              var start = Math.min.apply(Math, [end].concat(_toConsumableArray(indexes)));
              return new Range(start, end - start);
            }
          }, {
            key: 'normalizeNative',
            value: function normalizeNative(nativeRange) {
              if (!contains(this.root, nativeRange.startContainer) || !nativeRange.collapsed && !contains(this.root, nativeRange.endContainer)) {
                return null;
              }

              var range = {
                start: {
                  node: nativeRange.startContainer,
                  offset: nativeRange.startOffset
                },
                end: {
                  node: nativeRange.endContainer,
                  offset: nativeRange.endOffset
                },
                "native": nativeRange
              };
              [range.start, range.end].forEach(function (position) {
                var node = position.node,
                    offset = position.offset;

                while (!(node instanceof Text) && node.childNodes.length > 0) {
                  if (node.childNodes.length > offset) {
                    node = node.childNodes[offset];
                    offset = 0;
                  } else if (node.childNodes.length === offset) {
                    node = node.lastChild;
                    offset = node instanceof Text ? node.data.length : node.childNodes.length + 1;
                  } else {
                    break;
                  }
                }

                position.node = node, position.offset = offset;
              });
              return range;
            }
          }, {
            key: 'rangeToNative',
            value: function rangeToNative(range) {
              var _this5 = this;

              var indexes = range.collapsed ? [range.index] : [range.index, range.index + range.length];
              var args = [];
              var scrollLength = this.scroll.length();
              indexes.forEach(function (index, i) {
                index = Math.min(scrollLength - 1, index);

                var node = void 0,
                    _scroll$leaf5 = _this5.scroll.leaf(index),
                    _scroll$leaf6 = _slicedToArray(_scroll$leaf5, 2),
                    leaf = _scroll$leaf6[0],
                    offset = _scroll$leaf6[1];

                var _leaf$position5 = leaf.position(offset, i !== 0);

                var _leaf$position6 = _slicedToArray(_leaf$position5, 2);

                node = _leaf$position6[0];
                offset = _leaf$position6[1];
                args.push(node, offset);
              });

              if (args.length < 2) {
                args = args.concat(args);
              }

              return args;
            }
          }, {
            key: 'scrollIntoView',
            value: function scrollIntoView(scrollingContainer) {
              var range = this.lastRange;
              if (range == null) return;
              var bounds = this.getBounds(range.index, range.length);
              if (bounds == null) return;
              var limit = this.scroll.length() - 1;

              var _scroll$line = this.scroll.line(Math.min(range.index, limit)),
                  _scroll$line2 = _slicedToArray(_scroll$line, 1),
                  first = _scroll$line2[0];

              var last = first;

              if (range.length > 0) {
                var _scroll$line3 = this.scroll.line(Math.min(range.index + range.length, limit));

                var _scroll$line4 = _slicedToArray(_scroll$line3, 1);

                last = _scroll$line4[0];
              }

              if (first == null || last == null) return;
              var scrollBounds = scrollingContainer.getBoundingClientRect();

              if (bounds.top < scrollBounds.top) {
                scrollingContainer.scrollTop -= scrollBounds.top - bounds.top;
              } else if (bounds.bottom > scrollBounds.bottom) {
                scrollingContainer.scrollTop += bounds.bottom - scrollBounds.bottom;
              }
            }
          }, {
            key: 'setNativeRange',
            value: function setNativeRange(startNode, startOffset) {
              var endNode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : startNode;
              var endOffset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : startOffset;
              var force = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
              debug.info('setNativeRange', startNode, startOffset, endNode, endOffset);

              if (startNode != null && (this.root.parentNode == null || startNode.parentNode == null || endNode.parentNode == null)) {
                return;
              }

              var selection = document.getSelection();
              if (selection == null) return;

              if (startNode != null) {
                if (!this.hasFocus()) this.root.focus();
                var _native2 = (this.getNativeRange() || {})["native"];

                if (_native2 == null || force || startNode !== _native2.startContainer || startOffset !== _native2.startOffset || endNode !== _native2.endContainer || endOffset !== _native2.endOffset) {
                  if (startNode.tagName == "BR") {
                    startOffset = [].indexOf.call(startNode.parentNode.childNodes, startNode);
                    startNode = startNode.parentNode;
                  }

                  if (endNode.tagName == "BR") {
                    endOffset = [].indexOf.call(endNode.parentNode.childNodes, endNode);
                    endNode = endNode.parentNode;
                  }

                  var range = document.createRange();
                  range.setStart(startNode, startOffset);
                  range.setEnd(endNode, endOffset);
                  selection.removeAllRanges();
                  selection.addRange(range);
                }
              } else {
                selection.removeAllRanges();
                this.root.blur();
                document.body.focus(); // root.blur() not enough on IE11+Travis+SauceLabs (but not local VMs)
              }
            }
          }, {
            key: 'setRange',
            value: function setRange(range) {
              var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
              var source = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _emitter4["default"].sources.API;

              if (typeof force === 'string') {
                source = force;
                force = false;
              }

              debug.info('setRange', range);

              if (range != null) {
                var args = this.rangeToNative(range);
                this.setNativeRange.apply(this, _toConsumableArray(args).concat([force]));
              } else {
                this.setNativeRange(null);
              }

              this.update(source);
            }
          }, {
            key: 'update',
            value: function update() {
              var source = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _emitter4["default"].sources.USER;
              var oldRange = this.lastRange;

              var _getRange = this.getRange(),
                  _getRange2 = _slicedToArray(_getRange, 2),
                  lastRange = _getRange2[0],
                  nativeRange = _getRange2[1];

              this.lastRange = lastRange;

              if (this.lastRange != null) {
                this.savedRange = this.lastRange;
              }

              if (!(0, _deepEqual2["default"])(oldRange, this.lastRange)) {
                var _emitter;

                if (!this.composing && nativeRange != null && nativeRange["native"].collapsed && nativeRange.start.node !== this.cursor.textNode) {
                  this.cursor.restore();
                }

                var args = [_emitter4["default"].events.SELECTION_CHANGE, (0, _clone2["default"])(this.lastRange), (0, _clone2["default"])(oldRange), source];

                (_emitter = this.emitter).emit.apply(_emitter, [_emitter4["default"].events.EDITOR_CHANGE].concat(args));

                if (source !== _emitter4["default"].sources.SILENT) {
                  var _emitter2;

                  (_emitter2 = this.emitter).emit.apply(_emitter2, args);
                }
              }
            }
          }]);

          return Selection;
        }();

        function contains(parent, descendant) {
          try {
            // Firefox inserts inaccessible nodes around video elements
            descendant.parentNode;
          } catch (e) {
            return false;
          } // IE11 has bug with Text nodes
          // https://connect.microsoft.com/IE/feedback/details/780874/node-contains-is-incorrect


          if (descendant instanceof Text) {
            descendant = descendant.parentNode;
          }

          return parent.contains(descendant);
        }

        exports.Range = Range;
        exports["default"] = Selection;
        /***/
      },
      /* 16 */

      /***/
      function (module, exports, __webpack_require__) {

        Object.defineProperty(exports, "__esModule", {
          value: true
        });

        var _createClass = function () {
          function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor) descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
          };
        }();

        var _get = function get(object, property, receiver) {
          if (object === null) object = Function.prototype;
          var desc = Object.getOwnPropertyDescriptor(object, property);

          if (desc === undefined) {
            var parent = Object.getPrototypeOf(object);

            if (parent === null) {
              return undefined;
            } else {
              return get(parent, property, receiver);
            }
          } else if ("value" in desc) {
            return desc.value;
          } else {
            var getter = desc.get;

            if (getter === undefined) {
              return undefined;
            }

            return getter.call(receiver);
          }
        };

        var _parchment = __webpack_require__(0);

        var _parchment2 = _interopRequireDefault(_parchment);

        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : {
            "default": obj
          };
        }

        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }

        function _possibleConstructorReturn(self, call) {
          if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }

          return call && (_typeof(call) === "object" || typeof call === "function") ? call : self;
        }

        function _inherits(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + _typeof(superClass));
          }

          subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
              value: subClass,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }

        var Break = function (_Parchment$Embed) {
          _inherits(Break, _Parchment$Embed);

          function Break() {
            _classCallCheck(this, Break);

            return _possibleConstructorReturn(this, (Break.__proto__ || Object.getPrototypeOf(Break)).apply(this, arguments));
          }

          _createClass(Break, [{
            key: 'insertInto',
            value: function insertInto(parent, ref) {
              if (parent.children.length === 0) {
                _get(Break.prototype.__proto__ || Object.getPrototypeOf(Break.prototype), 'insertInto', this).call(this, parent, ref);
              } else {
                this.remove();
              }
            }
          }, {
            key: 'length',
            value: function length() {
              return 0;
            }
          }, {
            key: 'value',
            value: function value() {
              return '';
            }
          }], [{
            key: 'value',
            value: function value() {
              return undefined;
            }
          }]);

          return Break;
        }(_parchment2["default"].Embed);

        Break.blotName = 'break';
        Break.tagName = 'BR';
        exports["default"] = Break;
        /***/
      },
      /* 17 */

      /***/
      function (module, exports, __webpack_require__) {

        var __extends = this && this.__extends || function () {
          var extendStatics = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function (d, b) {
            d.__proto__ = b;
          } || function (d, b) {
            for (var p in b) {
              if (b.hasOwnProperty(p)) d[p] = b[p];
            }
          };

          return function (d, b) {
            extendStatics(d, b);

            function __() {
              this.constructor = d;
            }

            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();

        Object.defineProperty(exports, "__esModule", {
          value: true
        });

        var linked_list_1 = __webpack_require__(44);

        var shadow_1 = __webpack_require__(30);

        var Registry = __webpack_require__(1);

        var ContainerBlot =
        /** @class */
        function (_super) {
          __extends(ContainerBlot, _super);

          function ContainerBlot(domNode) {
            var _this = _super.call(this, domNode) || this;

            _this.build();

            return _this;
          }

          ContainerBlot.prototype.appendChild = function (other) {
            this.insertBefore(other);
          };

          ContainerBlot.prototype.attach = function () {
            _super.prototype.attach.call(this);

            this.children.forEach(function (child) {
              child.attach();
            });
          };

          ContainerBlot.prototype.build = function () {
            var _this = this;

            this.children = new linked_list_1["default"](); // Need to be reversed for if DOM nodes already in order

            [].slice.call(this.domNode.childNodes).reverse().forEach(function (node) {
              try {
                var child = makeBlot(node);

                _this.insertBefore(child, _this.children.head || undefined);
              } catch (err) {
                if (err instanceof Registry.ParchmentError) return;else throw err;
              }
            });
          };

          ContainerBlot.prototype.deleteAt = function (index, length) {
            if (index === 0 && length === this.length()) {
              return this.remove();
            }

            this.children.forEachAt(index, length, function (child, offset, length) {
              child.deleteAt(offset, length);
            });
          };

          ContainerBlot.prototype.descendant = function (criteria, index) {
            var _a = this.children.find(index),
                child = _a[0],
                offset = _a[1];

            if (criteria.blotName == null && criteria(child) || criteria.blotName != null && child instanceof criteria) {
              return [child, offset];
            } else if (child instanceof ContainerBlot) {
              return child.descendant(criteria, offset);
            } else {
              return [null, -1];
            }
          };

          ContainerBlot.prototype.descendants = function (criteria, index, length) {
            if (index === void 0) {
              index = 0;
            }

            if (length === void 0) {
              length = Number.MAX_VALUE;
            }

            var descendants = [];
            var lengthLeft = length;
            this.children.forEachAt(index, length, function (child, index, length) {
              if (criteria.blotName == null && criteria(child) || criteria.blotName != null && child instanceof criteria) {
                descendants.push(child);
              }

              if (child instanceof ContainerBlot) {
                descendants = descendants.concat(child.descendants(criteria, index, lengthLeft));
              }

              lengthLeft -= length;
            });
            return descendants;
          };

          ContainerBlot.prototype.detach = function () {
            this.children.forEach(function (child) {
              child.detach();
            });

            _super.prototype.detach.call(this);
          };

          ContainerBlot.prototype.formatAt = function (index, length, name, value) {
            this.children.forEachAt(index, length, function (child, offset, length) {
              child.formatAt(offset, length, name, value);
            });
          };

          ContainerBlot.prototype.insertAt = function (index, value, def) {
            var _a = this.children.find(index),
                child = _a[0],
                offset = _a[1];

            if (child) {
              child.insertAt(offset, value, def);
            } else {
              var blot = def == null ? Registry.create('text', value) : Registry.create(value, def);
              this.appendChild(blot);
            }
          };

          ContainerBlot.prototype.insertBefore = function (childBlot, refBlot) {
            if (this.statics.allowedChildren != null && !this.statics.allowedChildren.some(function (child) {
              return childBlot instanceof child;
            })) {
              throw new Registry.ParchmentError("Cannot insert " + childBlot.statics.blotName + " into " + this.statics.blotName);
            }

            childBlot.insertInto(this, refBlot);
          };

          ContainerBlot.prototype.length = function () {
            return this.children.reduce(function (memo, child) {
              return memo + child.length();
            }, 0);
          };

          ContainerBlot.prototype.moveChildren = function (targetParent, refNode) {
            this.children.forEach(function (child) {
              targetParent.insertBefore(child, refNode);
            });
          };

          ContainerBlot.prototype.optimize = function (context) {
            _super.prototype.optimize.call(this, context);

            if (this.children.length === 0) {
              if (this.statics.defaultChild != null) {
                var child = Registry.create(this.statics.defaultChild);
                this.appendChild(child);
                child.optimize(context);
              } else {
                this.remove();
              }
            }
          };

          ContainerBlot.prototype.path = function (index, inclusive) {
            if (inclusive === void 0) {
              inclusive = false;
            }

            var _a = this.children.find(index, inclusive),
                child = _a[0],
                offset = _a[1];

            var position = [[this, index]];

            if (child instanceof ContainerBlot) {
              return position.concat(child.path(offset, inclusive));
            } else if (child != null) {
              position.push([child, offset]);
            }

            return position;
          };

          ContainerBlot.prototype.removeChild = function (child) {
            this.children.remove(child);
          };

          ContainerBlot.prototype.replace = function (target) {
            if (target instanceof ContainerBlot) {
              target.moveChildren(this);
            }

            _super.prototype.replace.call(this, target);
          };

          ContainerBlot.prototype.split = function (index, force) {
            if (force === void 0) {
              force = false;
            }

            if (!force) {
              if (index === 0) return this;
              if (index === this.length()) return this.next;
            }

            var after = this.clone();
            this.parent.insertBefore(after, this.next);
            this.children.forEachAt(index, this.length(), function (child, offset, length) {
              child = child.split(offset, force);
              after.appendChild(child);
            });
            return after;
          };

          ContainerBlot.prototype.unwrap = function () {
            this.moveChildren(this.parent, this.next);
            this.remove();
          };

          ContainerBlot.prototype.update = function (mutations, context) {
            var _this = this;

            var addedNodes = [];
            var removedNodes = [];
            mutations.forEach(function (mutation) {
              if (mutation.target === _this.domNode && mutation.type === 'childList') {
                addedNodes.push.apply(addedNodes, mutation.addedNodes);
                removedNodes.push.apply(removedNodes, mutation.removedNodes);
              }
            });
            removedNodes.forEach(function (node) {
              // Check node has actually been removed
              // One exception is Chrome does not immediately remove IFRAMEs
              // from DOM but MutationRecord is correct in its reported removal
              if (node.parentNode != null && // @ts-ignore
              node.tagName !== 'IFRAME' && document.body.compareDocumentPosition(node) & Node.DOCUMENT_POSITION_CONTAINED_BY) {
                return;
              }

              var blot = Registry.find(node);
              if (blot == null) return;

              if (blot.domNode.parentNode == null || blot.domNode.parentNode === _this.domNode) {
                blot.detach();
              }
            });
            addedNodes.filter(function (node) {
              return node.parentNode == _this.domNode;
            }).sort(function (a, b) {
              if (a === b) return 0;

              if (a.compareDocumentPosition(b) & Node.DOCUMENT_POSITION_FOLLOWING) {
                return 1;
              }

              return -1;
            }).forEach(function (node) {
              var refBlot = null;

              if (node.nextSibling != null) {
                refBlot = Registry.find(node.nextSibling);
              }

              var blot = makeBlot(node);

              if (blot.next != refBlot || blot.next == null) {
                if (blot.parent != null) {
                  blot.parent.removeChild(_this);
                }

                _this.insertBefore(blot, refBlot || undefined);
              }
            });
          };

          return ContainerBlot;
        }(shadow_1["default"]);

        function makeBlot(node) {
          var blot = Registry.find(node);

          if (blot == null) {
            try {
              blot = Registry.create(node);
            } catch (e) {
              blot = Registry.create(Registry.Scope.INLINE);
              [].slice.call(node.childNodes).forEach(function (child) {
                // @ts-ignore
                blot.domNode.appendChild(child);
              });

              if (node.parentNode) {
                node.parentNode.replaceChild(blot.domNode, node);
              }

              blot.attach();
            }
          }

          return blot;
        }

        exports["default"] = ContainerBlot;
        /***/
      },
      /* 18 */

      /***/
      function (module, exports, __webpack_require__) {

        var __extends = this && this.__extends || function () {
          var extendStatics = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function (d, b) {
            d.__proto__ = b;
          } || function (d, b) {
            for (var p in b) {
              if (b.hasOwnProperty(p)) d[p] = b[p];
            }
          };

          return function (d, b) {
            extendStatics(d, b);

            function __() {
              this.constructor = d;
            }

            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();

        Object.defineProperty(exports, "__esModule", {
          value: true
        });

        var attributor_1 = __webpack_require__(12);

        var store_1 = __webpack_require__(31);

        var container_1 = __webpack_require__(17);

        var Registry = __webpack_require__(1);

        var FormatBlot =
        /** @class */
        function (_super) {
          __extends(FormatBlot, _super);

          function FormatBlot(domNode) {
            var _this = _super.call(this, domNode) || this;

            _this.attributes = new store_1["default"](_this.domNode);
            return _this;
          }

          FormatBlot.formats = function (domNode) {
            if (typeof this.tagName === 'string') {
              return true;
            } else if (Array.isArray(this.tagName)) {
              return domNode.tagName.toLowerCase();
            }

            return undefined;
          };

          FormatBlot.prototype.format = function (name, value) {
            var format = Registry.query(name);

            if (format instanceof attributor_1["default"]) {
              this.attributes.attribute(format, value);
            } else if (value) {
              if (format != null && (name !== this.statics.blotName || this.formats()[name] !== value)) {
                this.replaceWith(name, value);
              }
            }
          };

          FormatBlot.prototype.formats = function () {
            var formats = this.attributes.values();
            var format = this.statics.formats(this.domNode);

            if (format != null) {
              formats[this.statics.blotName] = format;
            }

            return formats;
          };

          FormatBlot.prototype.replaceWith = function (name, value) {
            var replacement = _super.prototype.replaceWith.call(this, name, value);

            this.attributes.copy(replacement);
            return replacement;
          };

          FormatBlot.prototype.update = function (mutations, context) {
            var _this = this;

            _super.prototype.update.call(this, mutations, context);

            if (mutations.some(function (mutation) {
              return mutation.target === _this.domNode && mutation.type === 'attributes';
            })) {
              this.attributes.build();
            }
          };

          FormatBlot.prototype.wrap = function (name, value) {
            var wrapper = _super.prototype.wrap.call(this, name, value);

            if (wrapper instanceof FormatBlot && wrapper.statics.scope === this.statics.scope) {
              this.attributes.move(wrapper);
            }

            return wrapper;
          };

          return FormatBlot;
        }(container_1["default"]);

        exports["default"] = FormatBlot;
        /***/
      },
      /* 19 */

      /***/
      function (module, exports, __webpack_require__) {

        var __extends = this && this.__extends || function () {
          var extendStatics = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function (d, b) {
            d.__proto__ = b;
          } || function (d, b) {
            for (var p in b) {
              if (b.hasOwnProperty(p)) d[p] = b[p];
            }
          };

          return function (d, b) {
            extendStatics(d, b);

            function __() {
              this.constructor = d;
            }

            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();

        Object.defineProperty(exports, "__esModule", {
          value: true
        });

        var shadow_1 = __webpack_require__(30);

        var Registry = __webpack_require__(1);

        var LeafBlot =
        /** @class */
        function (_super) {
          __extends(LeafBlot, _super);

          function LeafBlot() {
            return _super !== null && _super.apply(this, arguments) || this;
          }

          LeafBlot.value = function (domNode) {
            return true;
          };

          LeafBlot.prototype.index = function (node, offset) {
            if (this.domNode === node || this.domNode.compareDocumentPosition(node) & Node.DOCUMENT_POSITION_CONTAINED_BY) {
              return Math.min(offset, 1);
            }

            return -1;
          };

          LeafBlot.prototype.position = function (index, inclusive) {
            var offset = [].indexOf.call(this.parent.domNode.childNodes, this.domNode);
            if (index > 0) offset += 1;
            return [this.parent.domNode, offset];
          };

          LeafBlot.prototype.value = function () {
            var _a;

            return _a = {}, _a[this.statics.blotName] = this.statics.value(this.domNode) || true, _a;
          };

          LeafBlot.scope = Registry.Scope.INLINE_BLOT;
          return LeafBlot;
        }(shadow_1["default"]);

        exports["default"] = LeafBlot;
        /***/
      },
      /* 20 */

      /***/
      function (module, exports, __webpack_require__) {
        var equal = __webpack_require__(11);

        var extend = __webpack_require__(3);

        var lib = {
          attributes: {
            compose: function compose(a, b, keepNull) {
              if (_typeof(a) !== 'object') a = {};
              if (_typeof(b) !== 'object') b = {};
              var attributes = extend(true, {}, b);

              if (!keepNull) {
                attributes = Object.keys(attributes).reduce(function (copy, key) {
                  if (attributes[key] != null) {
                    copy[key] = attributes[key];
                  }

                  return copy;
                }, {});
              }

              for (var key in a) {
                if (a[key] !== undefined && b[key] === undefined) {
                  attributes[key] = a[key];
                }
              }

              return Object.keys(attributes).length > 0 ? attributes : undefined;
            },
            diff: function diff(a, b) {
              if (_typeof(a) !== 'object') a = {};
              if (_typeof(b) !== 'object') b = {};
              var attributes = Object.keys(a).concat(Object.keys(b)).reduce(function (attributes, key) {
                if (!equal(a[key], b[key])) {
                  attributes[key] = b[key] === undefined ? null : b[key];
                }

                return attributes;
              }, {});
              return Object.keys(attributes).length > 0 ? attributes : undefined;
            },
            transform: function transform(a, b, priority) {
              if (_typeof(a) !== 'object') return b;
              if (_typeof(b) !== 'object') return undefined;
              if (!priority) return b; // b simply overwrites us without priority

              var attributes = Object.keys(b).reduce(function (attributes, key) {
                if (a[key] === undefined) attributes[key] = b[key]; // null is a valid value

                return attributes;
              }, {});
              return Object.keys(attributes).length > 0 ? attributes : undefined;
            }
          },
          iterator: function iterator(ops) {
            return new Iterator(ops);
          },
          length: function length(op) {
            if (typeof op['delete'] === 'number') {
              return op['delete'];
            } else if (typeof op.retain === 'number') {
              return op.retain;
            } else {
              return typeof op.insert === 'string' ? op.insert.length : 1;
            }
          }
        };

        function Iterator(ops) {
          this.ops = ops;
          this.index = 0;
          this.offset = 0;
        }

        Iterator.prototype.hasNext = function () {
          return this.peekLength() < Infinity;
        };

        Iterator.prototype.next = function (length) {
          if (!length) length = Infinity;
          var nextOp = this.ops[this.index];

          if (nextOp) {
            var offset = this.offset;
            var opLength = lib.length(nextOp);

            if (length >= opLength - offset) {
              length = opLength - offset;
              this.index += 1;
              this.offset = 0;
            } else {
              this.offset += length;
            }

            if (typeof nextOp['delete'] === 'number') {
              return {
                'delete': length
              };
            } else {
              var retOp = {};

              if (nextOp.attributes) {
                retOp.attributes = nextOp.attributes;
              }

              if (typeof nextOp.retain === 'number') {
                retOp.retain = length;
              } else if (typeof nextOp.insert === 'string') {
                retOp.insert = nextOp.insert.substr(offset, length);
              } else {
                // offset should === 0, length should === 1
                retOp.insert = nextOp.insert;
              }

              return retOp;
            }
          } else {
            return {
              retain: Infinity
            };
          }
        };

        Iterator.prototype.peek = function () {
          return this.ops[this.index];
        };

        Iterator.prototype.peekLength = function () {
          if (this.ops[this.index]) {
            // Should never return 0 if our index is being managed correctly
            return lib.length(this.ops[this.index]) - this.offset;
          } else {
            return Infinity;
          }
        };

        Iterator.prototype.peekType = function () {
          if (this.ops[this.index]) {
            if (typeof this.ops[this.index]['delete'] === 'number') {
              return 'delete';
            } else if (typeof this.ops[this.index].retain === 'number') {
              return 'retain';
            } else {
              return 'insert';
            }
          }

          return 'retain';
        };

        Iterator.prototype.rest = function () {
          if (!this.hasNext()) {
            return [];
          } else if (this.offset === 0) {
            return this.ops.slice(this.index);
          } else {
            var offset = this.offset;
            var index = this.index;
            var next = this.next();
            var rest = this.ops.slice(this.index);
            this.offset = offset;
            this.index = index;
            return [next].concat(rest);
          }
        };

        module.exports = lib;
        /***/
      },
      /* 21 */

      /***/
      function (module, exports) {
        var clone = function () {

          function _instanceof(obj, type) {
            return type != null && obj instanceof type;
          }

          var nativeMap;

          try {
            nativeMap = Map;
          } catch (_) {
            // maybe a reference error because no `Map`. Give it a dummy value that no
            // value will ever be an instanceof.
            nativeMap = function nativeMap() {};
          }

          var nativeSet;

          try {
            nativeSet = Set;
          } catch (_) {
            nativeSet = function nativeSet() {};
          }

          var nativePromise;

          try {
            nativePromise = Promise;
          } catch (_) {
            nativePromise = function nativePromise() {};
          }
          /**
           * Clones (copies) an Object using deep copying.
           *
           * This function supports circular references by default, but if you are certain
           * there are no circular references in your object, you can save some CPU time
           * by calling clone(obj, false).
           *
           * Caution: if `circular` is false and `parent` contains circular references,
           * your program may enter an infinite loop and crash.
           *
           * @param `parent` - the object to be cloned
           * @param `circular` - set to true if the object to be cloned may contain
           *    circular references. (optional - true by default)
           * @param `depth` - set to a number if the object is only to be cloned to
           *    a particular depth. (optional - defaults to Infinity)
           * @param `prototype` - sets the prototype to be used when cloning an object.
           *    (optional - defaults to parent prototype).
           * @param `includeNonEnumerable` - set to true if the non-enumerable properties
           *    should be cloned as well. Non-enumerable properties on the prototype
           *    chain will be ignored. (optional - false by default)
          */


          function clone(parent, circular, depth, prototype, includeNonEnumerable) {
            if (_typeof(circular) === 'object') {
              depth = circular.depth;
              prototype = circular.prototype;
              includeNonEnumerable = circular.includeNonEnumerable;
              circular = circular.circular;
            } // maintain two arrays for circular references, where corresponding parents
            // and children have the same index


            var allParents = [];
            var allChildren = [];
            var useBuffer = typeof Buffer != 'undefined';
            if (typeof circular == 'undefined') circular = true;
            if (typeof depth == 'undefined') depth = Infinity; // recurse this function so we don't reset allParents and allChildren

            function _clone(parent, depth) {
              // cloning null always returns null
              if (parent === null) return null;
              if (depth === 0) return parent;
              var child;
              var proto;

              if (_typeof(parent) != 'object') {
                return parent;
              }

              if (_instanceof(parent, nativeMap)) {
                child = new nativeMap();
              } else if (_instanceof(parent, nativeSet)) {
                child = new nativeSet();
              } else if (_instanceof(parent, nativePromise)) {
                child = new nativePromise(function (resolve, reject) {
                  parent.then(function (value) {
                    resolve(_clone(value, depth - 1));
                  }, function (err) {
                    reject(_clone(err, depth - 1));
                  });
                });
              } else if (clone.__isArray(parent)) {
                child = [];
              } else if (clone.__isRegExp(parent)) {
                child = new RegExp(parent.source, __getRegExpFlags(parent));
                if (parent.lastIndex) child.lastIndex = parent.lastIndex;
              } else if (clone.__isDate(parent)) {
                child = new Date(parent.getTime());
              } else if (useBuffer && Buffer.isBuffer(parent)) {
                if (Buffer.allocUnsafe) {
                  // Node.js >= 4.5.0
                  child = Buffer.allocUnsafe(parent.length);
                } else {
                  // Older Node.js versions
                  child = new Buffer(parent.length);
                }

                parent.copy(child);
                return child;
              } else if (_instanceof(parent, Error)) {
                child = Object.create(parent);
              } else {
                if (typeof prototype == 'undefined') {
                  proto = Object.getPrototypeOf(parent);
                  child = Object.create(proto);
                } else {
                  child = Object.create(prototype);
                  proto = prototype;
                }
              }

              if (circular) {
                var index = allParents.indexOf(parent);

                if (index != -1) {
                  return allChildren[index];
                }

                allParents.push(parent);
                allChildren.push(child);
              }

              if (_instanceof(parent, nativeMap)) {
                parent.forEach(function (value, key) {
                  var keyChild = _clone(key, depth - 1);

                  var valueChild = _clone(value, depth - 1);

                  child.set(keyChild, valueChild);
                });
              }

              if (_instanceof(parent, nativeSet)) {
                parent.forEach(function (value) {
                  var entryChild = _clone(value, depth - 1);

                  child.add(entryChild);
                });
              }

              for (var i in parent) {
                var attrs;

                if (proto) {
                  attrs = Object.getOwnPropertyDescriptor(proto, i);
                }

                if (attrs && attrs.set == null) {
                  continue;
                }

                child[i] = _clone(parent[i], depth - 1);
              }

              if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(parent);

                for (var i = 0; i < symbols.length; i++) {
                  // Don't need to worry about cloning a symbol because it is a primitive,
                  // like a number or string.
                  var symbol = symbols[i];
                  var descriptor = Object.getOwnPropertyDescriptor(parent, symbol);

                  if (descriptor && !descriptor.enumerable && !includeNonEnumerable) {
                    continue;
                  }

                  child[symbol] = _clone(parent[symbol], depth - 1);

                  if (!descriptor.enumerable) {
                    Object.defineProperty(child, symbol, {
                      enumerable: false
                    });
                  }
                }
              }

              if (includeNonEnumerable) {
                var allPropertyNames = Object.getOwnPropertyNames(parent);

                for (var i = 0; i < allPropertyNames.length; i++) {
                  var propertyName = allPropertyNames[i];
                  var descriptor = Object.getOwnPropertyDescriptor(parent, propertyName);

                  if (descriptor && descriptor.enumerable) {
                    continue;
                  }

                  child[propertyName] = _clone(parent[propertyName], depth - 1);
                  Object.defineProperty(child, propertyName, {
                    enumerable: false
                  });
                }
              }

              return child;
            }

            return _clone(parent, depth);
          }
          /**
           * Simple flat clone using prototype, accepts only objects, usefull for property
           * override on FLAT configuration object (no nested props).
           *
           * USE WITH CAUTION! This may not behave as you wish if you do not know how this
           * works.
           */


          clone.clonePrototype = function clonePrototype(parent) {
            if (parent === null) return null;

            var c = function c() {};

            c.prototype = parent;
            return new c();
          }; // private utility functions


          function __objToStr(o) {
            return Object.prototype.toString.call(o);
          }

          clone.__objToStr = __objToStr;

          function __isDate(o) {
            return _typeof(o) === 'object' && __objToStr(o) === '[object Date]';
          }

          clone.__isDate = __isDate;

          function __isArray(o) {
            return _typeof(o) === 'object' && __objToStr(o) === '[object Array]';
          }

          clone.__isArray = __isArray;

          function __isRegExp(o) {
            return _typeof(o) === 'object' && __objToStr(o) === '[object RegExp]';
          }

          clone.__isRegExp = __isRegExp;

          function __getRegExpFlags(re) {
            var flags = '';
            if (re.global) flags += 'g';
            if (re.ignoreCase) flags += 'i';
            if (re.multiline) flags += 'm';
            return flags;
          }

          clone.__getRegExpFlags = __getRegExpFlags;
          return clone;
        }();

        if (_typeof(module) === 'object' && module.exports) {
          module.exports = clone;
        }
        /***/

      },
      /* 22 */

      /***/
      function (module, exports, __webpack_require__) {

        Object.defineProperty(exports, "__esModule", {
          value: true
        });

        var _slicedToArray = function () {
          function sliceIterator(arr, i) {
            var _arr = [];
            var _n = true;
            var _d = false;
            var _e = undefined;

            try {
              for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                _arr.push(_s.value);

                if (i && _arr.length === i) break;
              }
            } catch (err) {
              _d = true;
              _e = err;
            } finally {
              try {
                if (!_n && _i["return"]) _i["return"]();
              } finally {
                if (_d) throw _e;
              }
            }

            return _arr;
          }

          return function (arr, i) {
            if (Array.isArray(arr)) {
              return arr;
            } else if (Symbol.iterator in Object(arr)) {
              return sliceIterator(arr, i);
            } else {
              throw new TypeError("Invalid attempt to destructure non-iterable instance");
            }
          };
        }();

        var _createClass = function () {
          function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor) descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
          };
        }();

        var _get = function get(object, property, receiver) {
          if (object === null) object = Function.prototype;
          var desc = Object.getOwnPropertyDescriptor(object, property);

          if (desc === undefined) {
            var parent = Object.getPrototypeOf(object);

            if (parent === null) {
              return undefined;
            } else {
              return get(parent, property, receiver);
            }
          } else if ("value" in desc) {
            return desc.value;
          } else {
            var getter = desc.get;

            if (getter === undefined) {
              return undefined;
            }

            return getter.call(receiver);
          }
        };

        var _parchment = __webpack_require__(0);

        var _parchment2 = _interopRequireDefault(_parchment);

        var _emitter = __webpack_require__(8);

        var _emitter2 = _interopRequireDefault(_emitter);

        var _block = __webpack_require__(4);

        var _block2 = _interopRequireDefault(_block);

        var _break = __webpack_require__(16);

        var _break2 = _interopRequireDefault(_break);

        var _code = __webpack_require__(13);

        var _code2 = _interopRequireDefault(_code);

        var _container = __webpack_require__(25);

        var _container2 = _interopRequireDefault(_container);

        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : {
            "default": obj
          };
        }

        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }

        function _possibleConstructorReturn(self, call) {
          if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }

          return call && (_typeof(call) === "object" || typeof call === "function") ? call : self;
        }

        function _inherits(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + _typeof(superClass));
          }

          subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
              value: subClass,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }

        function isLine(blot) {
          return blot instanceof _block2["default"] || blot instanceof _block.BlockEmbed;
        }

        var Scroll = function (_Parchment$Scroll) {
          _inherits(Scroll, _Parchment$Scroll);

          function Scroll(domNode, config) {
            _classCallCheck(this, Scroll);

            var _this = _possibleConstructorReturn(this, (Scroll.__proto__ || Object.getPrototypeOf(Scroll)).call(this, domNode));

            _this.emitter = config.emitter;

            if (Array.isArray(config.whitelist)) {
              _this.whitelist = config.whitelist.reduce(function (whitelist, format) {
                whitelist[format] = true;
                return whitelist;
              }, {});
            } // Some reason fixes composition issues with character languages in Windows/Chrome, Safari


            _this.domNode.addEventListener('DOMNodeInserted', function () {});

            _this.optimize();

            _this.enable();

            return _this;
          }

          _createClass(Scroll, [{
            key: 'batchStart',
            value: function batchStart() {
              this.batch = true;
            }
          }, {
            key: 'batchEnd',
            value: function batchEnd() {
              this.batch = false;
              this.optimize();
            }
          }, {
            key: 'deleteAt',
            value: function deleteAt(index, length) {
              var _line = this.line(index),
                  _line2 = _slicedToArray(_line, 2),
                  first = _line2[0],
                  offset = _line2[1];

              var _line3 = this.line(index + length),
                  _line4 = _slicedToArray(_line3, 1),
                  last = _line4[0];

              _get(Scroll.prototype.__proto__ || Object.getPrototypeOf(Scroll.prototype), 'deleteAt', this).call(this, index, length);

              if (last != null && first !== last && offset > 0) {
                if (first instanceof _block.BlockEmbed || last instanceof _block.BlockEmbed) {
                  this.optimize();
                  return;
                }

                if (first instanceof _code2["default"]) {
                  var newlineIndex = first.newlineIndex(first.length(), true);

                  if (newlineIndex > -1) {
                    first = first.split(newlineIndex + 1);

                    if (first === last) {
                      this.optimize();
                      return;
                    }
                  }
                } else if (last instanceof _code2["default"]) {
                  var _newlineIndex = last.newlineIndex(0);

                  if (_newlineIndex > -1) {
                    last.split(_newlineIndex + 1);
                  }
                }

                var ref = last.children.head instanceof _break2["default"] ? null : last.children.head;
                first.moveChildren(last, ref);
                first.remove();
              }

              this.optimize();
            }
          }, {
            key: 'enable',
            value: function enable() {
              var enabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
              this.domNode.setAttribute('contenteditable', enabled);
            }
          }, {
            key: 'formatAt',
            value: function formatAt(index, length, format, value) {
              if (this.whitelist != null && !this.whitelist[format]) return;

              _get(Scroll.prototype.__proto__ || Object.getPrototypeOf(Scroll.prototype), 'formatAt', this).call(this, index, length, format, value);

              this.optimize();
            }
          }, {
            key: 'insertAt',
            value: function insertAt(index, value, def) {
              if (def != null && this.whitelist != null && !this.whitelist[value]) return;

              if (index >= this.length()) {
                if (def == null || _parchment2["default"].query(value, _parchment2["default"].Scope.BLOCK) == null) {
                  var blot = _parchment2["default"].create(this.statics.defaultChild);

                  this.appendChild(blot);

                  if (def == null && value.endsWith('\n')) {
                    value = value.slice(0, -1);
                  }

                  blot.insertAt(0, value, def);
                } else {
                  var embed = _parchment2["default"].create(value, def);

                  this.appendChild(embed);
                }
              } else {
                _get(Scroll.prototype.__proto__ || Object.getPrototypeOf(Scroll.prototype), 'insertAt', this).call(this, index, value, def);
              }

              this.optimize();
            }
          }, {
            key: 'insertBefore',
            value: function insertBefore(blot, ref) {
              if (blot.statics.scope === _parchment2["default"].Scope.INLINE_BLOT) {
                var wrapper = _parchment2["default"].create(this.statics.defaultChild);

                wrapper.appendChild(blot);
                blot = wrapper;
              }

              _get(Scroll.prototype.__proto__ || Object.getPrototypeOf(Scroll.prototype), 'insertBefore', this).call(this, blot, ref);
            }
          }, {
            key: 'leaf',
            value: function leaf(index) {
              return this.path(index).pop() || [null, -1];
            }
          }, {
            key: 'line',
            value: function line(index) {
              if (index === this.length()) {
                return this.line(index - 1);
              }

              return this.descendant(isLine, index);
            }
          }, {
            key: 'lines',
            value: function lines() {
              var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
              var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Number.MAX_VALUE;

              var getLines = function getLines(blot, index, length) {
                var lines = [],
                    lengthLeft = length;
                blot.children.forEachAt(index, length, function (child, index, length) {
                  if (isLine(child)) {
                    lines.push(child);
                  } else if (child instanceof _parchment2["default"].Container) {
                    lines = lines.concat(getLines(child, index, lengthLeft));
                  }

                  lengthLeft -= length;
                });
                return lines;
              };

              return getLines(this, index, length);
            }
          }, {
            key: 'optimize',
            value: function optimize() {
              var mutations = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
              var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
              if (this.batch === true) return;

              _get(Scroll.prototype.__proto__ || Object.getPrototypeOf(Scroll.prototype), 'optimize', this).call(this, mutations, context);

              if (mutations.length > 0) {
                this.emitter.emit(_emitter2["default"].events.SCROLL_OPTIMIZE, mutations, context);
              }
            }
          }, {
            key: 'path',
            value: function path(index) {
              return _get(Scroll.prototype.__proto__ || Object.getPrototypeOf(Scroll.prototype), 'path', this).call(this, index).slice(1); // Exclude self
            }
          }, {
            key: 'update',
            value: function update(mutations) {
              if (this.batch === true) return;
              var source = _emitter2["default"].sources.USER;

              if (typeof mutations === 'string') {
                source = mutations;
              }

              if (!Array.isArray(mutations)) {
                mutations = this.observer.takeRecords();
              }

              if (mutations.length > 0) {
                this.emitter.emit(_emitter2["default"].events.SCROLL_BEFORE_UPDATE, source, mutations);
              }

              _get(Scroll.prototype.__proto__ || Object.getPrototypeOf(Scroll.prototype), 'update', this).call(this, mutations.concat([])); // pass copy


              if (mutations.length > 0) {
                this.emitter.emit(_emitter2["default"].events.SCROLL_UPDATE, source, mutations);
              }
            }
          }]);

          return Scroll;
        }(_parchment2["default"].Scroll);

        Scroll.blotName = 'scroll';
        Scroll.className = 'ql-editor';
        Scroll.tagName = 'DIV';
        Scroll.defaultChild = 'block';
        Scroll.allowedChildren = [_block2["default"], _block.BlockEmbed, _container2["default"]];
        exports["default"] = Scroll;
        /***/
      },
      /* 23 */

      /***/
      function (module, exports, __webpack_require__) {

        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.SHORTKEY = exports["default"] = undefined;

        var _typeof$1 = typeof Symbol === "function" && _typeof(Symbol.iterator) === "symbol" ? function (obj) {
          return _typeof(obj);
        } : function (obj) {
          return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof(obj);
        };

        var _slicedToArray = function () {
          function sliceIterator(arr, i) {
            var _arr = [];
            var _n = true;
            var _d = false;
            var _e = undefined;

            try {
              for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                _arr.push(_s.value);

                if (i && _arr.length === i) break;
              }
            } catch (err) {
              _d = true;
              _e = err;
            } finally {
              try {
                if (!_n && _i["return"]) _i["return"]();
              } finally {
                if (_d) throw _e;
              }
            }

            return _arr;
          }

          return function (arr, i) {
            if (Array.isArray(arr)) {
              return arr;
            } else if (Symbol.iterator in Object(arr)) {
              return sliceIterator(arr, i);
            } else {
              throw new TypeError("Invalid attempt to destructure non-iterable instance");
            }
          };
        }();

        var _createClass = function () {
          function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor) descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
          };
        }();

        var _clone = __webpack_require__(21);

        var _clone2 = _interopRequireDefault(_clone);

        var _deepEqual = __webpack_require__(11);

        var _deepEqual2 = _interopRequireDefault(_deepEqual);

        var _extend = __webpack_require__(3);

        var _extend2 = _interopRequireDefault(_extend);

        var _quillDelta = __webpack_require__(2);

        var _quillDelta2 = _interopRequireDefault(_quillDelta);

        var _op = __webpack_require__(20);

        var _op2 = _interopRequireDefault(_op);

        var _parchment = __webpack_require__(0);

        var _parchment2 = _interopRequireDefault(_parchment);

        var _quill = __webpack_require__(5);

        var _quill2 = _interopRequireDefault(_quill);

        var _logger = __webpack_require__(10);

        var _logger2 = _interopRequireDefault(_logger);

        var _module = __webpack_require__(9);

        var _module2 = _interopRequireDefault(_module);

        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : {
            "default": obj
          };
        }

        function _defineProperty(obj, key, value) {
          if (key in obj) {
            Object.defineProperty(obj, key, {
              value: value,
              enumerable: true,
              configurable: true,
              writable: true
            });
          } else {
            obj[key] = value;
          }

          return obj;
        }

        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }

        function _possibleConstructorReturn(self, call) {
          if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }

          return call && (_typeof(call) === "object" || typeof call === "function") ? call : self;
        }

        function _inherits(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + _typeof(superClass));
          }

          subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
              value: subClass,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }

        var debug = (0, _logger2["default"])('quill:keyboard');
        var SHORTKEY = /Mac/i.test(navigator.platform) ? 'metaKey' : 'ctrlKey';

        var Keyboard = function (_Module) {
          _inherits(Keyboard, _Module);

          _createClass(Keyboard, null, [{
            key: 'match',
            value: function match(evt, binding) {
              binding = normalize(binding);

              if (['altKey', 'ctrlKey', 'metaKey', 'shiftKey'].some(function (key) {
                return !!binding[key] !== evt[key] && binding[key] !== null;
              })) {
                return false;
              }

              return binding.key === (evt.which || evt.keyCode);
            }
          }]);

          function Keyboard(quill, options) {
            _classCallCheck(this, Keyboard);

            var _this = _possibleConstructorReturn(this, (Keyboard.__proto__ || Object.getPrototypeOf(Keyboard)).call(this, quill, options));

            _this.bindings = {};
            Object.keys(_this.options.bindings).forEach(function (name) {
              if (name === 'list autofill' && quill.scroll.whitelist != null && !quill.scroll.whitelist['list']) {
                return;
              }

              if (_this.options.bindings[name]) {
                _this.addBinding(_this.options.bindings[name]);
              }
            });

            _this.addBinding({
              key: Keyboard.keys.ENTER,
              shiftKey: null
            }, handleEnter);

            _this.addBinding({
              key: Keyboard.keys.ENTER,
              metaKey: null,
              ctrlKey: null,
              altKey: null
            }, function () {});

            if (/Firefox/i.test(navigator.userAgent)) {
              // Need to handle delete and backspace for Firefox in the general case #1171
              _this.addBinding({
                key: Keyboard.keys.BACKSPACE
              }, {
                collapsed: true
              }, handleBackspace);

              _this.addBinding({
                key: Keyboard.keys.DELETE
              }, {
                collapsed: true
              }, handleDelete);
            } else {
              _this.addBinding({
                key: Keyboard.keys.BACKSPACE
              }, {
                collapsed: true,
                prefix: /^.?$/
              }, handleBackspace);

              _this.addBinding({
                key: Keyboard.keys.DELETE
              }, {
                collapsed: true,
                suffix: /^.?$/
              }, handleDelete);
            }

            _this.addBinding({
              key: Keyboard.keys.BACKSPACE
            }, {
              collapsed: false
            }, handleDeleteRange);

            _this.addBinding({
              key: Keyboard.keys.DELETE
            }, {
              collapsed: false
            }, handleDeleteRange);

            _this.addBinding({
              key: Keyboard.keys.BACKSPACE,
              altKey: null,
              ctrlKey: null,
              metaKey: null,
              shiftKey: null
            }, {
              collapsed: true,
              offset: 0
            }, handleBackspace);

            _this.listen();

            return _this;
          }

          _createClass(Keyboard, [{
            key: 'addBinding',
            value: function addBinding(key) {
              var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
              var handler = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
              var binding = normalize(key);

              if (binding == null || binding.key == null) {
                return debug.warn('Attempted to add invalid keyboard binding', binding);
              }

              if (typeof context === 'function') {
                context = {
                  handler: context
                };
              }

              if (typeof handler === 'function') {
                handler = {
                  handler: handler
                };
              }

              binding = (0, _extend2["default"])(binding, context, handler);
              this.bindings[binding.key] = this.bindings[binding.key] || [];
              this.bindings[binding.key].push(binding);
            }
          }, {
            key: 'listen',
            value: function listen() {
              var _this2 = this;

              this.quill.root.addEventListener('keydown', function (evt) {
                if (evt.defaultPrevented) return;
                var which = evt.which || evt.keyCode;
                var bindings = (_this2.bindings[which] || []).filter(function (binding) {
                  return Keyboard.match(evt, binding);
                });
                if (bindings.length === 0) return;

                var range = _this2.quill.getSelection();

                if (range == null || !_this2.quill.hasFocus()) return;

                var _quill$getLine = _this2.quill.getLine(range.index),
                    _quill$getLine2 = _slicedToArray(_quill$getLine, 2),
                    line = _quill$getLine2[0],
                    offset = _quill$getLine2[1];

                var _quill$getLeaf = _this2.quill.getLeaf(range.index),
                    _quill$getLeaf2 = _slicedToArray(_quill$getLeaf, 2),
                    leafStart = _quill$getLeaf2[0],
                    offsetStart = _quill$getLeaf2[1];

                var _ref = range.length === 0 ? [leafStart, offsetStart] : _this2.quill.getLeaf(range.index + range.length),
                    _ref2 = _slicedToArray(_ref, 2),
                    leafEnd = _ref2[0],
                    offsetEnd = _ref2[1];

                var prefixText = leafStart instanceof _parchment2["default"].Text ? leafStart.value().slice(0, offsetStart) : '';
                var suffixText = leafEnd instanceof _parchment2["default"].Text ? leafEnd.value().slice(offsetEnd) : '';
                var curContext = {
                  collapsed: range.length === 0,
                  empty: range.length === 0 && line.length() <= 1,
                  format: _this2.quill.getFormat(range),
                  offset: offset,
                  prefix: prefixText,
                  suffix: suffixText
                };
                var prevented = bindings.some(function (binding) {
                  if (binding.collapsed != null && binding.collapsed !== curContext.collapsed) return false;
                  if (binding.empty != null && binding.empty !== curContext.empty) return false;
                  if (binding.offset != null && binding.offset !== curContext.offset) return false;

                  if (Array.isArray(binding.format)) {
                    // any format is present
                    if (binding.format.every(function (name) {
                      return curContext.format[name] == null;
                    })) {
                      return false;
                    }
                  } else if (_typeof$1(binding.format) === 'object') {
                    // all formats must match
                    if (!Object.keys(binding.format).every(function (name) {
                      if (binding.format[name] === true) return curContext.format[name] != null;
                      if (binding.format[name] === false) return curContext.format[name] == null;
                      return (0, _deepEqual2["default"])(binding.format[name], curContext.format[name]);
                    })) {
                      return false;
                    }
                  }

                  if (binding.prefix != null && !binding.prefix.test(curContext.prefix)) return false;
                  if (binding.suffix != null && !binding.suffix.test(curContext.suffix)) return false;
                  return binding.handler.call(_this2, range, curContext) !== true;
                });

                if (prevented) {
                  evt.preventDefault();
                }
              });
            }
          }]);

          return Keyboard;
        }(_module2["default"]);

        Keyboard.keys = {
          BACKSPACE: 8,
          TAB: 9,
          ENTER: 13,
          ESCAPE: 27,
          LEFT: 37,
          UP: 38,
          RIGHT: 39,
          DOWN: 40,
          DELETE: 46
        };
        Keyboard.DEFAULTS = {
          bindings: {
            'bold': makeFormatHandler('bold'),
            'italic': makeFormatHandler('italic'),
            'underline': makeFormatHandler('underline'),
            'indent': {
              // highlight tab or tab at beginning of list, indent or blockquote
              key: Keyboard.keys.TAB,
              format: ['blockquote', 'indent', 'list'],
              handler: function handler(range, context) {
                if (context.collapsed && context.offset !== 0) return true;
                this.quill.format('indent', '+1', _quill2["default"].sources.USER);
              }
            },
            'outdent': {
              key: Keyboard.keys.TAB,
              shiftKey: true,
              format: ['blockquote', 'indent', 'list'],
              // highlight tab or tab at beginning of list, indent or blockquote
              handler: function handler(range, context) {
                if (context.collapsed && context.offset !== 0) return true;
                this.quill.format('indent', '-1', _quill2["default"].sources.USER);
              }
            },
            'outdent backspace': {
              key: Keyboard.keys.BACKSPACE,
              collapsed: true,
              shiftKey: null,
              metaKey: null,
              ctrlKey: null,
              altKey: null,
              format: ['indent', 'list'],
              offset: 0,
              handler: function handler(range, context) {
                if (context.format.indent != null) {
                  this.quill.format('indent', '-1', _quill2["default"].sources.USER);
                } else if (context.format.list != null) {
                  this.quill.format('list', false, _quill2["default"].sources.USER);
                }
              }
            },
            'indent code-block': makeCodeBlockHandler(true),
            'outdent code-block': makeCodeBlockHandler(false),
            'remove tab': {
              key: Keyboard.keys.TAB,
              shiftKey: true,
              collapsed: true,
              prefix: /\t$/,
              handler: function handler(range) {
                this.quill.deleteText(range.index - 1, 1, _quill2["default"].sources.USER);
              }
            },
            'tab': {
              key: Keyboard.keys.TAB,
              handler: function handler(range) {
                this.quill.history.cutoff();
                var delta = new _quillDelta2["default"]().retain(range.index)["delete"](range.length).insert('\t');
                this.quill.updateContents(delta, _quill2["default"].sources.USER);
                this.quill.history.cutoff();
                this.quill.setSelection(range.index + 1, _quill2["default"].sources.SILENT);
              }
            },
            'list empty enter': {
              key: Keyboard.keys.ENTER,
              collapsed: true,
              format: ['list'],
              empty: true,
              handler: function handler(range, context) {
                this.quill.format('list', false, _quill2["default"].sources.USER);

                if (context.format.indent) {
                  this.quill.format('indent', false, _quill2["default"].sources.USER);
                }
              }
            },
            'checklist enter': {
              key: Keyboard.keys.ENTER,
              collapsed: true,
              format: {
                list: 'checked'
              },
              handler: function handler(range) {
                var _quill$getLine3 = this.quill.getLine(range.index),
                    _quill$getLine4 = _slicedToArray(_quill$getLine3, 2),
                    line = _quill$getLine4[0],
                    offset = _quill$getLine4[1];

                var formats = (0, _extend2["default"])({}, line.formats(), {
                  list: 'checked'
                });
                var delta = new _quillDelta2["default"]().retain(range.index).insert('\n', formats).retain(line.length() - offset - 1).retain(1, {
                  list: 'unchecked'
                });
                this.quill.updateContents(delta, _quill2["default"].sources.USER);
                this.quill.setSelection(range.index + 1, _quill2["default"].sources.SILENT);
                this.quill.scrollIntoView();
              }
            },
            'header enter': {
              key: Keyboard.keys.ENTER,
              collapsed: true,
              format: ['header'],
              suffix: /^$/,
              handler: function handler(range, context) {
                var _quill$getLine5 = this.quill.getLine(range.index),
                    _quill$getLine6 = _slicedToArray(_quill$getLine5, 2),
                    line = _quill$getLine6[0],
                    offset = _quill$getLine6[1];

                var delta = new _quillDelta2["default"]().retain(range.index).insert('\n', context.format).retain(line.length() - offset - 1).retain(1, {
                  header: null
                });
                this.quill.updateContents(delta, _quill2["default"].sources.USER);
                this.quill.setSelection(range.index + 1, _quill2["default"].sources.SILENT);
                this.quill.scrollIntoView();
              }
            },
            'list autofill': {
              key: ' ',
              collapsed: true,
              format: {
                list: false
              },
              prefix: /^\s*?(\d+\.|-|\*|\[ ?\]|\[x\])$/,
              handler: function handler(range, context) {
                var length = context.prefix.length;

                var _quill$getLine7 = this.quill.getLine(range.index),
                    _quill$getLine8 = _slicedToArray(_quill$getLine7, 2),
                    line = _quill$getLine8[0],
                    offset = _quill$getLine8[1];

                if (offset > length) return true;
                var value = void 0;

                switch (context.prefix.trim()) {
                  case '[]':
                  case '[ ]':
                    value = 'unchecked';
                    break;

                  case '[x]':
                    value = 'checked';
                    break;

                  case '-':
                  case '*':
                    value = 'bullet';
                    break;

                  default:
                    value = 'ordered';
                }

                this.quill.insertText(range.index, ' ', _quill2["default"].sources.USER);
                this.quill.history.cutoff();
                var delta = new _quillDelta2["default"]().retain(range.index - offset)["delete"](length + 1).retain(line.length() - 2 - offset).retain(1, {
                  list: value
                });
                this.quill.updateContents(delta, _quill2["default"].sources.USER);
                this.quill.history.cutoff();
                this.quill.setSelection(range.index - length, _quill2["default"].sources.SILENT);
              }
            },
            'code exit': {
              key: Keyboard.keys.ENTER,
              collapsed: true,
              format: ['code-block'],
              prefix: /\n\n$/,
              suffix: /^\s+$/,
              handler: function handler(range) {
                var _quill$getLine9 = this.quill.getLine(range.index),
                    _quill$getLine10 = _slicedToArray(_quill$getLine9, 2),
                    line = _quill$getLine10[0],
                    offset = _quill$getLine10[1];

                var delta = new _quillDelta2["default"]().retain(range.index + line.length() - offset - 2).retain(1, {
                  'code-block': null
                })["delete"](1);
                this.quill.updateContents(delta, _quill2["default"].sources.USER);
              }
            },
            'embed left': makeEmbedArrowHandler(Keyboard.keys.LEFT, false),
            'embed left shift': makeEmbedArrowHandler(Keyboard.keys.LEFT, true),
            'embed right': makeEmbedArrowHandler(Keyboard.keys.RIGHT, false),
            'embed right shift': makeEmbedArrowHandler(Keyboard.keys.RIGHT, true)
          }
        };

        function makeEmbedArrowHandler(key, shiftKey) {
          var _ref3;

          var where = key === Keyboard.keys.LEFT ? 'prefix' : 'suffix';
          return _ref3 = {
            key: key,
            shiftKey: shiftKey,
            altKey: null
          }, _defineProperty(_ref3, where, /^$/), _defineProperty(_ref3, 'handler', function handler(range) {
            var index = range.index;

            if (key === Keyboard.keys.RIGHT) {
              index += range.length + 1;
            }

            var _quill$getLeaf3 = this.quill.getLeaf(index),
                _quill$getLeaf4 = _slicedToArray(_quill$getLeaf3, 1),
                leaf = _quill$getLeaf4[0];

            if (!(leaf instanceof _parchment2["default"].Embed)) return true;

            if (key === Keyboard.keys.LEFT) {
              if (shiftKey) {
                this.quill.setSelection(range.index - 1, range.length + 1, _quill2["default"].sources.USER);
              } else {
                this.quill.setSelection(range.index - 1, _quill2["default"].sources.USER);
              }
            } else {
              if (shiftKey) {
                this.quill.setSelection(range.index, range.length + 1, _quill2["default"].sources.USER);
              } else {
                this.quill.setSelection(range.index + range.length + 1, _quill2["default"].sources.USER);
              }
            }

            return false;
          }), _ref3;
        }

        function handleBackspace(range, context) {
          if (range.index === 0 || this.quill.getLength() <= 1) return;

          var _quill$getLine11 = this.quill.getLine(range.index),
              _quill$getLine12 = _slicedToArray(_quill$getLine11, 1),
              line = _quill$getLine12[0];

          var formats = {};

          if (context.offset === 0) {
            var _quill$getLine13 = this.quill.getLine(range.index - 1),
                _quill$getLine14 = _slicedToArray(_quill$getLine13, 1),
                prev = _quill$getLine14[0];

            if (prev != null && prev.length() > 1) {
              var curFormats = line.formats();
              var prevFormats = this.quill.getFormat(range.index - 1, 1);
              formats = _op2["default"].attributes.diff(curFormats, prevFormats) || {};
            }
          } // Check for astral symbols


          var length = /[\uD800-\uDBFF][\uDC00-\uDFFF]$/.test(context.prefix) ? 2 : 1;
          this.quill.deleteText(range.index - length, length, _quill2["default"].sources.USER);

          if (Object.keys(formats).length > 0) {
            this.quill.formatLine(range.index - length, length, formats, _quill2["default"].sources.USER);
          }

          this.quill.focus();
        }

        function handleDelete(range, context) {
          // Check for astral symbols
          var length = /^[\uD800-\uDBFF][\uDC00-\uDFFF]/.test(context.suffix) ? 2 : 1;
          if (range.index >= this.quill.getLength() - length) return;
          var formats = {},
              nextLength = 0;

          var _quill$getLine15 = this.quill.getLine(range.index),
              _quill$getLine16 = _slicedToArray(_quill$getLine15, 1),
              line = _quill$getLine16[0];

          if (context.offset >= line.length() - 1) {
            var _quill$getLine17 = this.quill.getLine(range.index + 1),
                _quill$getLine18 = _slicedToArray(_quill$getLine17, 1),
                next = _quill$getLine18[0];

            if (next) {
              var curFormats = line.formats();
              var nextFormats = this.quill.getFormat(range.index, 1);
              formats = _op2["default"].attributes.diff(curFormats, nextFormats) || {};
              nextLength = next.length();
            }
          }

          this.quill.deleteText(range.index, length, _quill2["default"].sources.USER);

          if (Object.keys(formats).length > 0) {
            this.quill.formatLine(range.index + nextLength - 1, length, formats, _quill2["default"].sources.USER);
          }
        }

        function handleDeleteRange(range) {
          var lines = this.quill.getLines(range);
          var formats = {};

          if (lines.length > 1) {
            var firstFormats = lines[0].formats();
            var lastFormats = lines[lines.length - 1].formats();
            formats = _op2["default"].attributes.diff(lastFormats, firstFormats) || {};
          }

          this.quill.deleteText(range, _quill2["default"].sources.USER);

          if (Object.keys(formats).length > 0) {
            this.quill.formatLine(range.index, 1, formats, _quill2["default"].sources.USER);
          }

          this.quill.setSelection(range.index, _quill2["default"].sources.SILENT);
          this.quill.focus();
        }

        function handleEnter(range, context) {
          var _this3 = this;

          if (range.length > 0) {
            this.quill.scroll.deleteAt(range.index, range.length); // So we do not trigger text-change
          }

          var lineFormats = Object.keys(context.format).reduce(function (lineFormats, format) {
            if (_parchment2["default"].query(format, _parchment2["default"].Scope.BLOCK) && !Array.isArray(context.format[format])) {
              lineFormats[format] = context.format[format];
            }

            return lineFormats;
          }, {});
          this.quill.insertText(range.index, '\n', lineFormats, _quill2["default"].sources.USER); // Earlier scroll.deleteAt might have messed up our selection,
          // so insertText's built in selection preservation is not reliable

          this.quill.setSelection(range.index + 1, _quill2["default"].sources.SILENT);
          this.quill.focus();
          Object.keys(context.format).forEach(function (name) {
            if (lineFormats[name] != null) return;
            if (Array.isArray(context.format[name])) return;
            if (name === 'link') return;

            _this3.quill.format(name, context.format[name], _quill2["default"].sources.USER);
          });
        }

        function makeCodeBlockHandler(indent) {
          return {
            key: Keyboard.keys.TAB,
            shiftKey: !indent,
            format: {
              'code-block': true
            },
            handler: function handler(range) {
              var CodeBlock = _parchment2["default"].query('code-block');

              var index = range.index,
                  length = range.length;

              var _quill$scroll$descend = this.quill.scroll.descendant(CodeBlock, index),
                  _quill$scroll$descend2 = _slicedToArray(_quill$scroll$descend, 2),
                  block = _quill$scroll$descend2[0],
                  offset = _quill$scroll$descend2[1];

              if (block == null) return;
              var scrollIndex = this.quill.getIndex(block);
              var start = block.newlineIndex(offset, true) + 1;
              var end = block.newlineIndex(scrollIndex + offset + length);
              var lines = block.domNode.textContent.slice(start, end).split('\n');
              offset = 0;
              lines.forEach(function (line, i) {
                if (indent) {
                  block.insertAt(start + offset, CodeBlock.TAB);
                  offset += CodeBlock.TAB.length;

                  if (i === 0) {
                    index += CodeBlock.TAB.length;
                  } else {
                    length += CodeBlock.TAB.length;
                  }
                } else if (line.startsWith(CodeBlock.TAB)) {
                  block.deleteAt(start + offset, CodeBlock.TAB.length);
                  offset -= CodeBlock.TAB.length;

                  if (i === 0) {
                    index -= CodeBlock.TAB.length;
                  } else {
                    length -= CodeBlock.TAB.length;
                  }
                }

                offset += line.length + 1;
              });
              this.quill.update(_quill2["default"].sources.USER);
              this.quill.setSelection(index, length, _quill2["default"].sources.SILENT);
            }
          };
        }

        function makeFormatHandler(format) {
          return {
            key: format[0].toUpperCase(),
            shortKey: true,
            handler: function handler(range, context) {
              this.quill.format(format, !context.format[format], _quill2["default"].sources.USER);
            }
          };
        }

        function normalize(binding) {
          if (typeof binding === 'string' || typeof binding === 'number') {
            return normalize({
              key: binding
            });
          }

          if ((typeof binding === 'undefined' ? 'undefined' : _typeof$1(binding)) === 'object') {
            binding = (0, _clone2["default"])(binding, false);
          }

          if (typeof binding.key === 'string') {
            if (Keyboard.keys[binding.key.toUpperCase()] != null) {
              binding.key = Keyboard.keys[binding.key.toUpperCase()];
            } else if (binding.key.length === 1) {
              binding.key = binding.key.toUpperCase().charCodeAt(0);
            } else {
              return null;
            }
          }

          if (binding.shortKey) {
            binding[SHORTKEY] = binding.shortKey;
            delete binding.shortKey;
          }

          return binding;
        }

        exports["default"] = Keyboard;
        exports.SHORTKEY = SHORTKEY;
        /***/
      },
      /* 24 */

      /***/
      function (module, exports, __webpack_require__) {

        Object.defineProperty(exports, "__esModule", {
          value: true
        });

        var _slicedToArray = function () {
          function sliceIterator(arr, i) {
            var _arr = [];
            var _n = true;
            var _d = false;
            var _e = undefined;

            try {
              for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                _arr.push(_s.value);

                if (i && _arr.length === i) break;
              }
            } catch (err) {
              _d = true;
              _e = err;
            } finally {
              try {
                if (!_n && _i["return"]) _i["return"]();
              } finally {
                if (_d) throw _e;
              }
            }

            return _arr;
          }

          return function (arr, i) {
            if (Array.isArray(arr)) {
              return arr;
            } else if (Symbol.iterator in Object(arr)) {
              return sliceIterator(arr, i);
            } else {
              throw new TypeError("Invalid attempt to destructure non-iterable instance");
            }
          };
        }();

        var _get = function get(object, property, receiver) {
          if (object === null) object = Function.prototype;
          var desc = Object.getOwnPropertyDescriptor(object, property);

          if (desc === undefined) {
            var parent = Object.getPrototypeOf(object);

            if (parent === null) {
              return undefined;
            } else {
              return get(parent, property, receiver);
            }
          } else if ("value" in desc) {
            return desc.value;
          } else {
            var getter = desc.get;

            if (getter === undefined) {
              return undefined;
            }

            return getter.call(receiver);
          }
        };

        var _createClass = function () {
          function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor) descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
          };
        }();

        var _parchment = __webpack_require__(0);

        var _parchment2 = _interopRequireDefault(_parchment);

        var _text = __webpack_require__(7);

        var _text2 = _interopRequireDefault(_text);

        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : {
            "default": obj
          };
        }

        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }

        function _possibleConstructorReturn(self, call) {
          if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }

          return call && (_typeof(call) === "object" || typeof call === "function") ? call : self;
        }

        function _inherits(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + _typeof(superClass));
          }

          subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
              value: subClass,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }

        var Cursor = function (_Parchment$Embed) {
          _inherits(Cursor, _Parchment$Embed);

          _createClass(Cursor, null, [{
            key: 'value',
            value: function value() {
              return undefined;
            }
          }]);

          function Cursor(domNode, selection) {
            _classCallCheck(this, Cursor);

            var _this = _possibleConstructorReturn(this, (Cursor.__proto__ || Object.getPrototypeOf(Cursor)).call(this, domNode));

            _this.selection = selection;
            _this.textNode = document.createTextNode(Cursor.CONTENTS);

            _this.domNode.appendChild(_this.textNode);

            _this._length = 0;
            return _this;
          }

          _createClass(Cursor, [{
            key: 'detach',
            value: function detach() {
              // super.detach() will also clear domNode.__blot
              if (this.parent != null) this.parent.removeChild(this);
            }
          }, {
            key: 'format',
            value: function format(name, value) {
              if (this._length !== 0) {
                return _get(Cursor.prototype.__proto__ || Object.getPrototypeOf(Cursor.prototype), 'format', this).call(this, name, value);
              }

              var target = this,
                  index = 0;

              while (target != null && target.statics.scope !== _parchment2["default"].Scope.BLOCK_BLOT) {
                index += target.offset(target.parent);
                target = target.parent;
              }

              if (target != null) {
                this._length = Cursor.CONTENTS.length;
                target.optimize();
                target.formatAt(index, Cursor.CONTENTS.length, name, value);
                this._length = 0;
              }
            }
          }, {
            key: 'index',
            value: function index(node, offset) {
              if (node === this.textNode) return 0;
              return _get(Cursor.prototype.__proto__ || Object.getPrototypeOf(Cursor.prototype), 'index', this).call(this, node, offset);
            }
          }, {
            key: 'length',
            value: function length() {
              return this._length;
            }
          }, {
            key: 'position',
            value: function position() {
              return [this.textNode, this.textNode.data.length];
            }
          }, {
            key: 'remove',
            value: function remove() {
              _get(Cursor.prototype.__proto__ || Object.getPrototypeOf(Cursor.prototype), 'remove', this).call(this);

              this.parent = null;
            }
          }, {
            key: 'restore',
            value: function restore() {
              if (this.selection.composing || this.parent == null) return;
              var textNode = this.textNode;
              var range = this.selection.getNativeRange();
              var restoreText = void 0,
                  start = void 0,
                  end = void 0;

              if (range != null && range.start.node === textNode && range.end.node === textNode) {
                var _ref = [textNode, range.start.offset, range.end.offset];
                restoreText = _ref[0];
                start = _ref[1];
                end = _ref[2];
              } // Link format will insert text outside of anchor tag


              while (this.domNode.lastChild != null && this.domNode.lastChild !== this.textNode) {
                this.domNode.parentNode.insertBefore(this.domNode.lastChild, this.domNode);
              }

              if (this.textNode.data !== Cursor.CONTENTS) {
                var text = this.textNode.data.split(Cursor.CONTENTS).join('');

                if (this.next instanceof _text2["default"]) {
                  restoreText = this.next.domNode;
                  this.next.insertAt(0, text);
                  this.textNode.data = Cursor.CONTENTS;
                } else {
                  this.textNode.data = text;
                  this.parent.insertBefore(_parchment2["default"].create(this.textNode), this);
                  this.textNode = document.createTextNode(Cursor.CONTENTS);
                  this.domNode.appendChild(this.textNode);
                }
              }

              this.remove();

              if (start != null) {
                var _map = [start, end].map(function (offset) {
                  return Math.max(0, Math.min(restoreText.data.length, offset - 1));
                });

                var _map2 = _slicedToArray(_map, 2);

                start = _map2[0];
                end = _map2[1];
                return {
                  startNode: restoreText,
                  startOffset: start,
                  endNode: restoreText,
                  endOffset: end
                };
              }
            }
          }, {
            key: 'update',
            value: function update(mutations, context) {
              var _this2 = this;

              if (mutations.some(function (mutation) {
                return mutation.type === 'characterData' && mutation.target === _this2.textNode;
              })) {
                var range = this.restore();
                if (range) context.range = range;
              }
            }
          }, {
            key: 'value',
            value: function value() {
              return '';
            }
          }]);

          return Cursor;
        }(_parchment2["default"].Embed);

        Cursor.blotName = 'cursor';
        Cursor.className = 'ql-cursor';
        Cursor.tagName = 'span';
        Cursor.CONTENTS = "\uFEFF"; // Zero width no break space

        exports["default"] = Cursor;
        /***/
      },
      /* 25 */

      /***/
      function (module, exports, __webpack_require__) {

        Object.defineProperty(exports, "__esModule", {
          value: true
        });

        var _parchment = __webpack_require__(0);

        var _parchment2 = _interopRequireDefault(_parchment);

        var _block = __webpack_require__(4);

        var _block2 = _interopRequireDefault(_block);

        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : {
            "default": obj
          };
        }

        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }

        function _possibleConstructorReturn(self, call) {
          if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }

          return call && (_typeof(call) === "object" || typeof call === "function") ? call : self;
        }

        function _inherits(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + _typeof(superClass));
          }

          subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
              value: subClass,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }

        var Container = function (_Parchment$Container) {
          _inherits(Container, _Parchment$Container);

          function Container() {
            _classCallCheck(this, Container);

            return _possibleConstructorReturn(this, (Container.__proto__ || Object.getPrototypeOf(Container)).apply(this, arguments));
          }

          return Container;
        }(_parchment2["default"].Container);

        Container.allowedChildren = [_block2["default"], _block.BlockEmbed, Container];
        exports["default"] = Container;
        /***/
      },
      /* 26 */

      /***/
      function (module, exports, __webpack_require__) {

        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.ColorStyle = exports.ColorClass = exports.ColorAttributor = undefined;

        var _createClass = function () {
          function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor) descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
          };
        }();

        var _get = function get(object, property, receiver) {
          if (object === null) object = Function.prototype;
          var desc = Object.getOwnPropertyDescriptor(object, property);

          if (desc === undefined) {
            var parent = Object.getPrototypeOf(object);

            if (parent === null) {
              return undefined;
            } else {
              return get(parent, property, receiver);
            }
          } else if ("value" in desc) {
            return desc.value;
          } else {
            var getter = desc.get;

            if (getter === undefined) {
              return undefined;
            }

            return getter.call(receiver);
          }
        };

        var _parchment = __webpack_require__(0);

        var _parchment2 = _interopRequireDefault(_parchment);

        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : {
            "default": obj
          };
        }

        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }

        function _possibleConstructorReturn(self, call) {
          if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }

          return call && (_typeof(call) === "object" || typeof call === "function") ? call : self;
        }

        function _inherits(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + _typeof(superClass));
          }

          subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
              value: subClass,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }

        var ColorAttributor = function (_Parchment$Attributor) {
          _inherits(ColorAttributor, _Parchment$Attributor);

          function ColorAttributor() {
            _classCallCheck(this, ColorAttributor);

            return _possibleConstructorReturn(this, (ColorAttributor.__proto__ || Object.getPrototypeOf(ColorAttributor)).apply(this, arguments));
          }

          _createClass(ColorAttributor, [{
            key: 'value',
            value: function value(domNode) {
              var value = _get(ColorAttributor.prototype.__proto__ || Object.getPrototypeOf(ColorAttributor.prototype), 'value', this).call(this, domNode);

              if (!value.startsWith('rgb(')) return value;
              value = value.replace(/^[^\d]+/, '').replace(/[^\d]+$/, '');
              return '#' + value.split(',').map(function (component) {
                return ('00' + parseInt(component).toString(16)).slice(-2);
              }).join('');
            }
          }]);

          return ColorAttributor;
        }(_parchment2["default"].Attributor.Style);

        var ColorClass = new _parchment2["default"].Attributor.Class('color', 'ql-color', {
          scope: _parchment2["default"].Scope.INLINE
        });
        var ColorStyle = new ColorAttributor('color', 'color', {
          scope: _parchment2["default"].Scope.INLINE
        });
        exports.ColorAttributor = ColorAttributor;
        exports.ColorClass = ColorClass;
        exports.ColorStyle = ColorStyle;
        /***/
      },
      /* 27 */

      /***/
      function (module, exports, __webpack_require__) {

        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.sanitize = exports["default"] = undefined;

        var _createClass = function () {
          function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor) descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
          };
        }();

        var _get = function get(object, property, receiver) {
          if (object === null) object = Function.prototype;
          var desc = Object.getOwnPropertyDescriptor(object, property);

          if (desc === undefined) {
            var parent = Object.getPrototypeOf(object);

            if (parent === null) {
              return undefined;
            } else {
              return get(parent, property, receiver);
            }
          } else if ("value" in desc) {
            return desc.value;
          } else {
            var getter = desc.get;

            if (getter === undefined) {
              return undefined;
            }

            return getter.call(receiver);
          }
        };

        var _inline = __webpack_require__(6);

        var _inline2 = _interopRequireDefault(_inline);

        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : {
            "default": obj
          };
        }

        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }

        function _possibleConstructorReturn(self, call) {
          if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }

          return call && (_typeof(call) === "object" || typeof call === "function") ? call : self;
        }

        function _inherits(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + _typeof(superClass));
          }

          subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
              value: subClass,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }

        var Link = function (_Inline) {
          _inherits(Link, _Inline);

          function Link() {
            _classCallCheck(this, Link);

            return _possibleConstructorReturn(this, (Link.__proto__ || Object.getPrototypeOf(Link)).apply(this, arguments));
          }

          _createClass(Link, [{
            key: 'format',
            value: function format(name, value) {
              if (name !== this.statics.blotName || !value) return _get(Link.prototype.__proto__ || Object.getPrototypeOf(Link.prototype), 'format', this).call(this, name, value);
              value = this.constructor.sanitize(value);
              this.domNode.setAttribute('href', value);
            }
          }], [{
            key: 'create',
            value: function create(value) {
              var node = _get(Link.__proto__ || Object.getPrototypeOf(Link), 'create', this).call(this, value);

              value = this.sanitize(value);
              node.setAttribute('href', value);
              node.setAttribute('rel', 'noopener noreferrer');
              node.setAttribute('target', '_blank');
              return node;
            }
          }, {
            key: 'formats',
            value: function formats(domNode) {
              return domNode.getAttribute('href');
            }
          }, {
            key: 'sanitize',
            value: function sanitize(url) {
              return _sanitize(url, this.PROTOCOL_WHITELIST) ? url : this.SANITIZED_URL;
            }
          }]);

          return Link;
        }(_inline2["default"]);

        Link.blotName = 'link';
        Link.tagName = 'A';
        Link.SANITIZED_URL = 'about:blank';
        Link.PROTOCOL_WHITELIST = ['http', 'https', 'mailto', 'tel'];

        function _sanitize(url, protocols) {
          var anchor = document.createElement('a');
          anchor.href = url;
          var protocol = anchor.href.slice(0, anchor.href.indexOf(':'));
          return protocols.indexOf(protocol) > -1;
        }

        exports["default"] = Link;
        exports.sanitize = _sanitize;
        /***/
      },
      /* 28 */

      /***/
      function (module, exports, __webpack_require__) {

        Object.defineProperty(exports, "__esModule", {
          value: true
        });

        var _typeof$1 = typeof Symbol === "function" && _typeof(Symbol.iterator) === "symbol" ? function (obj) {
          return _typeof(obj);
        } : function (obj) {
          return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof(obj);
        };

        var _createClass = function () {
          function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor) descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
          };
        }();

        var _keyboard = __webpack_require__(23);

        var _keyboard2 = _interopRequireDefault(_keyboard);

        var _dropdown = __webpack_require__(107);

        var _dropdown2 = _interopRequireDefault(_dropdown);

        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : {
            "default": obj
          };
        }

        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }

        var optionsCounter = 0;

        function toggleAriaAttribute(element, attribute) {
          element.setAttribute(attribute, !(element.getAttribute(attribute) === 'true'));
        }

        var Picker = function () {
          function Picker(select) {
            var _this = this;

            _classCallCheck(this, Picker);

            this.select = select;
            this.container = document.createElement('span');
            this.buildPicker();
            this.select.style.display = 'none';
            this.select.parentNode.insertBefore(this.container, this.select);
            this.label.addEventListener('mousedown', function () {
              _this.togglePicker();
            });
            this.label.addEventListener('keydown', function (event) {
              switch (event.keyCode) {
                // Allows the "Enter" key to open the picker
                case _keyboard2["default"].keys.ENTER:
                  _this.togglePicker();

                  break;
                // Allows the "Escape" key to close the picker

                case _keyboard2["default"].keys.ESCAPE:
                  _this.escape();

                  event.preventDefault();
                  break;
              }
            });
            this.select.addEventListener('change', this.update.bind(this));
          }

          _createClass(Picker, [{
            key: 'togglePicker',
            value: function togglePicker() {
              this.container.classList.toggle('ql-expanded'); // Toggle aria-expanded and aria-hidden to make the picker accessible

              toggleAriaAttribute(this.label, 'aria-expanded');
              toggleAriaAttribute(this.options, 'aria-hidden');
            }
          }, {
            key: 'buildItem',
            value: function buildItem(option) {
              var _this2 = this;

              var item = document.createElement('span');
              item.tabIndex = '0';
              item.setAttribute('role', 'button');
              item.classList.add('ql-picker-item');

              if (option.hasAttribute('value')) {
                item.setAttribute('data-value', option.getAttribute('value'));
              }

              if (option.textContent) {
                item.setAttribute('data-label', option.textContent);
              }

              item.addEventListener('click', function () {
                _this2.selectItem(item, true);
              });
              item.addEventListener('keydown', function (event) {
                switch (event.keyCode) {
                  // Allows the "Enter" key to select an item
                  case _keyboard2["default"].keys.ENTER:
                    _this2.selectItem(item, true);

                    event.preventDefault();
                    break;
                  // Allows the "Escape" key to close the picker

                  case _keyboard2["default"].keys.ESCAPE:
                    _this2.escape();

                    event.preventDefault();
                    break;
                }
              });
              return item;
            }
          }, {
            key: 'buildLabel',
            value: function buildLabel() {
              var label = document.createElement('span');
              label.classList.add('ql-picker-label');
              label.innerHTML = _dropdown2["default"];
              label.tabIndex = '0';
              label.setAttribute('role', 'button');
              label.setAttribute('aria-expanded', 'false');
              this.container.appendChild(label);
              return label;
            }
          }, {
            key: 'buildOptions',
            value: function buildOptions() {
              var _this3 = this;

              var options = document.createElement('span');
              options.classList.add('ql-picker-options'); // Don't want screen readers to read this until options are visible

              options.setAttribute('aria-hidden', 'true');
              options.tabIndex = '-1'; // Need a unique id for aria-controls

              options.id = 'ql-picker-options-' + optionsCounter;
              optionsCounter += 1;
              this.label.setAttribute('aria-controls', options.id);
              this.options = options;
              [].slice.call(this.select.options).forEach(function (option) {
                var item = _this3.buildItem(option);

                options.appendChild(item);

                if (option.selected === true) {
                  _this3.selectItem(item);
                }
              });
              this.container.appendChild(options);
            }
          }, {
            key: 'buildPicker',
            value: function buildPicker() {
              var _this4 = this;

              [].slice.call(this.select.attributes).forEach(function (item) {
                _this4.container.setAttribute(item.name, item.value);
              });
              this.container.classList.add('ql-picker');
              this.label = this.buildLabel();
              this.buildOptions();
            }
          }, {
            key: 'escape',
            value: function escape() {
              var _this5 = this; // Close menu and return focus to trigger label


              this.close(); // Need setTimeout for accessibility to ensure that the browser executes
              // focus on the next process thread and after any DOM content changes

              setTimeout(function () {
                return _this5.label.focus();
              }, 1);
            }
          }, {
            key: 'close',
            value: function close() {
              this.container.classList.remove('ql-expanded');
              this.label.setAttribute('aria-expanded', 'false');
              this.options.setAttribute('aria-hidden', 'true');
            }
          }, {
            key: 'selectItem',
            value: function selectItem(item) {
              var trigger = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
              var selected = this.container.querySelector('.ql-selected');
              if (item === selected) return;

              if (selected != null) {
                selected.classList.remove('ql-selected');
              }

              if (item == null) return;
              item.classList.add('ql-selected');
              this.select.selectedIndex = [].indexOf.call(item.parentNode.children, item);

              if (item.hasAttribute('data-value')) {
                this.label.setAttribute('data-value', item.getAttribute('data-value'));
              } else {
                this.label.removeAttribute('data-value');
              }

              if (item.hasAttribute('data-label')) {
                this.label.setAttribute('data-label', item.getAttribute('data-label'));
              } else {
                this.label.removeAttribute('data-label');
              }

              if (trigger) {
                if (typeof Event === 'function') {
                  this.select.dispatchEvent(new Event('change'));
                } else if ((typeof Event === 'undefined' ? 'undefined' : _typeof$1(Event)) === 'object') {
                  // IE11
                  var event = document.createEvent('Event');
                  event.initEvent('change', true, true);
                  this.select.dispatchEvent(event);
                }

                this.close();
              }
            }
          }, {
            key: 'update',
            value: function update() {
              var option = void 0;

              if (this.select.selectedIndex > -1) {
                var item = this.container.querySelector('.ql-picker-options').children[this.select.selectedIndex];
                option = this.select.options[this.select.selectedIndex];
                this.selectItem(item);
              } else {
                this.selectItem(null);
              }

              var isActive = option != null && option !== this.select.querySelector('option[selected]');
              this.label.classList.toggle('ql-active', isActive);
            }
          }]);

          return Picker;
        }();

        exports["default"] = Picker;
        /***/
      },
      /* 29 */

      /***/
      function (module, exports, __webpack_require__) {

        Object.defineProperty(exports, "__esModule", {
          value: true
        });

        var _parchment = __webpack_require__(0);

        var _parchment2 = _interopRequireDefault(_parchment);

        var _quill = __webpack_require__(5);

        var _quill2 = _interopRequireDefault(_quill);

        var _block = __webpack_require__(4);

        var _block2 = _interopRequireDefault(_block);

        var _break = __webpack_require__(16);

        var _break2 = _interopRequireDefault(_break);

        var _container = __webpack_require__(25);

        var _container2 = _interopRequireDefault(_container);

        var _cursor = __webpack_require__(24);

        var _cursor2 = _interopRequireDefault(_cursor);

        var _embed = __webpack_require__(35);

        var _embed2 = _interopRequireDefault(_embed);

        var _inline = __webpack_require__(6);

        var _inline2 = _interopRequireDefault(_inline);

        var _scroll = __webpack_require__(22);

        var _scroll2 = _interopRequireDefault(_scroll);

        var _text = __webpack_require__(7);

        var _text2 = _interopRequireDefault(_text);

        var _clipboard = __webpack_require__(55);

        var _clipboard2 = _interopRequireDefault(_clipboard);

        var _history = __webpack_require__(42);

        var _history2 = _interopRequireDefault(_history);

        var _keyboard = __webpack_require__(23);

        var _keyboard2 = _interopRequireDefault(_keyboard);

        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : {
            "default": obj
          };
        }

        _quill2["default"].register({
          'blots/block': _block2["default"],
          'blots/block/embed': _block.BlockEmbed,
          'blots/break': _break2["default"],
          'blots/container': _container2["default"],
          'blots/cursor': _cursor2["default"],
          'blots/embed': _embed2["default"],
          'blots/inline': _inline2["default"],
          'blots/scroll': _scroll2["default"],
          'blots/text': _text2["default"],
          'modules/clipboard': _clipboard2["default"],
          'modules/history': _history2["default"],
          'modules/keyboard': _keyboard2["default"]
        });

        _parchment2["default"].register(_block2["default"], _break2["default"], _cursor2["default"], _inline2["default"], _scroll2["default"], _text2["default"]);

        exports["default"] = _quill2["default"];
        /***/
      },
      /* 30 */

      /***/
      function (module, exports, __webpack_require__) {

        Object.defineProperty(exports, "__esModule", {
          value: true
        });

        var Registry = __webpack_require__(1);

        var ShadowBlot =
        /** @class */
        function () {
          function ShadowBlot(domNode) {
            this.domNode = domNode; // @ts-ignore

            this.domNode[Registry.DATA_KEY] = {
              blot: this
            };
          }

          Object.defineProperty(ShadowBlot.prototype, "statics", {
            // Hack for accessing inherited static methods
            get: function get() {
              return this.constructor;
            },
            enumerable: true,
            configurable: true
          });

          ShadowBlot.create = function (value) {
            if (this.tagName == null) {
              throw new Registry.ParchmentError('Blot definition missing tagName');
            }

            var node;

            if (Array.isArray(this.tagName)) {
              if (typeof value === 'string') {
                value = value.toUpperCase();

                if (parseInt(value).toString() === value) {
                  value = parseInt(value);
                }
              }

              if (typeof value === 'number') {
                node = document.createElement(this.tagName[value - 1]);
              } else if (this.tagName.indexOf(value) > -1) {
                node = document.createElement(value);
              } else {
                node = document.createElement(this.tagName[0]);
              }
            } else {
              node = document.createElement(this.tagName);
            }

            if (this.className) {
              node.classList.add(this.className);
            }

            return node;
          };

          ShadowBlot.prototype.attach = function () {
            if (this.parent != null) {
              this.scroll = this.parent.scroll;
            }
          };

          ShadowBlot.prototype.clone = function () {
            var domNode = this.domNode.cloneNode(false);
            return Registry.create(domNode);
          };

          ShadowBlot.prototype.detach = function () {
            if (this.parent != null) this.parent.removeChild(this); // @ts-ignore

            delete this.domNode[Registry.DATA_KEY];
          };

          ShadowBlot.prototype.deleteAt = function (index, length) {
            var blot = this.isolate(index, length);
            blot.remove();
          };

          ShadowBlot.prototype.formatAt = function (index, length, name, value) {
            var blot = this.isolate(index, length);

            if (Registry.query(name, Registry.Scope.BLOT) != null && value) {
              blot.wrap(name, value);
            } else if (Registry.query(name, Registry.Scope.ATTRIBUTE) != null) {
              var parent = Registry.create(this.statics.scope);
              blot.wrap(parent);
              parent.format(name, value);
            }
          };

          ShadowBlot.prototype.insertAt = function (index, value, def) {
            var blot = def == null ? Registry.create('text', value) : Registry.create(value, def);
            var ref = this.split(index);
            this.parent.insertBefore(blot, ref);
          };

          ShadowBlot.prototype.insertInto = function (parentBlot, refBlot) {
            if (refBlot === void 0) {
              refBlot = null;
            }

            if (this.parent != null) {
              this.parent.children.remove(this);
            }

            var refDomNode = null;
            parentBlot.children.insertBefore(this, refBlot);

            if (refBlot != null) {
              refDomNode = refBlot.domNode;
            }

            if (this.domNode.parentNode != parentBlot.domNode || this.domNode.nextSibling != refDomNode) {
              parentBlot.domNode.insertBefore(this.domNode, refDomNode);
            }

            this.parent = parentBlot;
            this.attach();
          };

          ShadowBlot.prototype.isolate = function (index, length) {
            var target = this.split(index);
            target.split(length);
            return target;
          };

          ShadowBlot.prototype.length = function () {
            return 1;
          };

          ShadowBlot.prototype.offset = function (root) {
            if (root === void 0) {
              root = this.parent;
            }

            if (this.parent == null || this == root) return 0;
            return this.parent.children.offset(this) + this.parent.offset(root);
          };

          ShadowBlot.prototype.optimize = function (context) {
            // TODO clean up once we use WeakMap
            // @ts-ignore
            if (this.domNode[Registry.DATA_KEY] != null) {
              // @ts-ignore
              delete this.domNode[Registry.DATA_KEY].mutations;
            }
          };

          ShadowBlot.prototype.remove = function () {
            if (this.domNode.parentNode != null) {
              this.domNode.parentNode.removeChild(this.domNode);
            }

            this.detach();
          };

          ShadowBlot.prototype.replace = function (target) {
            if (target.parent == null) return;
            target.parent.insertBefore(this, target.next);
            target.remove();
          };

          ShadowBlot.prototype.replaceWith = function (name, value) {
            var replacement = typeof name === 'string' ? Registry.create(name, value) : name;
            replacement.replace(this);
            return replacement;
          };

          ShadowBlot.prototype.split = function (index, force) {
            return index === 0 ? this : this.next;
          };

          ShadowBlot.prototype.update = function (mutations, context) {// Nothing to do by default
          };

          ShadowBlot.prototype.wrap = function (name, value) {
            var wrapper = typeof name === 'string' ? Registry.create(name, value) : name;

            if (this.parent != null) {
              this.parent.insertBefore(wrapper, this.next);
            }

            wrapper.appendChild(this);
            return wrapper;
          };

          ShadowBlot.blotName = 'abstract';
          return ShadowBlot;
        }();

        exports["default"] = ShadowBlot;
        /***/
      },
      /* 31 */

      /***/
      function (module, exports, __webpack_require__) {

        Object.defineProperty(exports, "__esModule", {
          value: true
        });

        var attributor_1 = __webpack_require__(12);

        var class_1 = __webpack_require__(32);

        var style_1 = __webpack_require__(33);

        var Registry = __webpack_require__(1);

        var AttributorStore =
        /** @class */
        function () {
          function AttributorStore(domNode) {
            this.attributes = {};
            this.domNode = domNode;
            this.build();
          }

          AttributorStore.prototype.attribute = function (attribute, value) {
            // verb
            if (value) {
              if (attribute.add(this.domNode, value)) {
                if (attribute.value(this.domNode) != null) {
                  this.attributes[attribute.attrName] = attribute;
                } else {
                  delete this.attributes[attribute.attrName];
                }
              }
            } else {
              attribute.remove(this.domNode);
              delete this.attributes[attribute.attrName];
            }
          };

          AttributorStore.prototype.build = function () {
            var _this = this;

            this.attributes = {};
            var attributes = attributor_1["default"].keys(this.domNode);
            var classes = class_1["default"].keys(this.domNode);
            var styles = style_1["default"].keys(this.domNode);
            attributes.concat(classes).concat(styles).forEach(function (name) {
              var attr = Registry.query(name, Registry.Scope.ATTRIBUTE);

              if (attr instanceof attributor_1["default"]) {
                _this.attributes[attr.attrName] = attr;
              }
            });
          };

          AttributorStore.prototype.copy = function (target) {
            var _this = this;

            Object.keys(this.attributes).forEach(function (key) {
              var value = _this.attributes[key].value(_this.domNode);

              target.format(key, value);
            });
          };

          AttributorStore.prototype.move = function (target) {
            var _this = this;

            this.copy(target);
            Object.keys(this.attributes).forEach(function (key) {
              _this.attributes[key].remove(_this.domNode);
            });
            this.attributes = {};
          };

          AttributorStore.prototype.values = function () {
            var _this = this;

            return Object.keys(this.attributes).reduce(function (attributes, name) {
              attributes[name] = _this.attributes[name].value(_this.domNode);
              return attributes;
            }, {});
          };

          return AttributorStore;
        }();

        exports["default"] = AttributorStore;
        /***/
      },
      /* 32 */

      /***/
      function (module, exports, __webpack_require__) {

        var __extends = this && this.__extends || function () {
          var extendStatics = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function (d, b) {
            d.__proto__ = b;
          } || function (d, b) {
            for (var p in b) {
              if (b.hasOwnProperty(p)) d[p] = b[p];
            }
          };

          return function (d, b) {
            extendStatics(d, b);

            function __() {
              this.constructor = d;
            }

            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();

        Object.defineProperty(exports, "__esModule", {
          value: true
        });

        var attributor_1 = __webpack_require__(12);

        function match(node, prefix) {
          var className = node.getAttribute('class') || '';
          return className.split(/\s+/).filter(function (name) {
            return name.indexOf(prefix + "-") === 0;
          });
        }

        var ClassAttributor =
        /** @class */
        function (_super) {
          __extends(ClassAttributor, _super);

          function ClassAttributor() {
            return _super !== null && _super.apply(this, arguments) || this;
          }

          ClassAttributor.keys = function (node) {
            return (node.getAttribute('class') || '').split(/\s+/).map(function (name) {
              return name.split('-').slice(0, -1).join('-');
            });
          };

          ClassAttributor.prototype.add = function (node, value) {
            if (!this.canAdd(node, value)) return false;
            this.remove(node);
            node.classList.add(this.keyName + "-" + value);
            return true;
          };

          ClassAttributor.prototype.remove = function (node) {
            var matches = match(node, this.keyName);
            matches.forEach(function (name) {
              node.classList.remove(name);
            });

            if (node.classList.length === 0) {
              node.removeAttribute('class');
            }
          };

          ClassAttributor.prototype.value = function (node) {
            var result = match(node, this.keyName)[0] || '';
            var value = result.slice(this.keyName.length + 1); // +1 for hyphen

            return this.canAdd(node, value) ? value : '';
          };

          return ClassAttributor;
        }(attributor_1["default"]);

        exports["default"] = ClassAttributor;
        /***/
      },
      /* 33 */

      /***/
      function (module, exports, __webpack_require__) {

        var __extends = this && this.__extends || function () {
          var extendStatics = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function (d, b) {
            d.__proto__ = b;
          } || function (d, b) {
            for (var p in b) {
              if (b.hasOwnProperty(p)) d[p] = b[p];
            }
          };

          return function (d, b) {
            extendStatics(d, b);

            function __() {
              this.constructor = d;
            }

            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();

        Object.defineProperty(exports, "__esModule", {
          value: true
        });

        var attributor_1 = __webpack_require__(12);

        function camelize(name) {
          var parts = name.split('-');
          var rest = parts.slice(1).map(function (part) {
            return part[0].toUpperCase() + part.slice(1);
          }).join('');
          return parts[0] + rest;
        }

        var StyleAttributor =
        /** @class */
        function (_super) {
          __extends(StyleAttributor, _super);

          function StyleAttributor() {
            return _super !== null && _super.apply(this, arguments) || this;
          }

          StyleAttributor.keys = function (node) {
            return (node.getAttribute('style') || '').split(';').map(function (value) {
              var arr = value.split(':');
              return arr[0].trim();
            });
          };

          StyleAttributor.prototype.add = function (node, value) {
            if (!this.canAdd(node, value)) return false; // @ts-ignore

            node.style[camelize(this.keyName)] = value;
            return true;
          };

          StyleAttributor.prototype.remove = function (node) {
            // @ts-ignore
            node.style[camelize(this.keyName)] = '';

            if (!node.getAttribute('style')) {
              node.removeAttribute('style');
            }
          };

          StyleAttributor.prototype.value = function (node) {
            // @ts-ignore
            var value = node.style[camelize(this.keyName)];
            return this.canAdd(node, value) ? value : '';
          };

          return StyleAttributor;
        }(attributor_1["default"]);

        exports["default"] = StyleAttributor;
        /***/
      },
      /* 34 */

      /***/
      function (module, exports, __webpack_require__) {

        Object.defineProperty(exports, "__esModule", {
          value: true
        });

        var _createClass = function () {
          function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor) descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
          };
        }();

        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }

        var Theme = function () {
          function Theme(quill, options) {
            _classCallCheck(this, Theme);

            this.quill = quill;
            this.options = options;
            this.modules = {};
          }

          _createClass(Theme, [{
            key: 'init',
            value: function init() {
              var _this = this;

              Object.keys(this.options.modules).forEach(function (name) {
                if (_this.modules[name] == null) {
                  _this.addModule(name);
                }
              });
            }
          }, {
            key: 'addModule',
            value: function addModule(name) {
              var moduleClass = this.quill.constructor["import"]('modules/' + name);
              this.modules[name] = new moduleClass(this.quill, this.options.modules[name] || {});
              return this.modules[name];
            }
          }]);

          return Theme;
        }();

        Theme.DEFAULTS = {
          modules: {}
        };
        Theme.themes = {
          'default': Theme
        };
        exports["default"] = Theme;
        /***/
      },
      /* 35 */

      /***/
      function (module, exports, __webpack_require__) {

        Object.defineProperty(exports, "__esModule", {
          value: true
        });

        var _createClass = function () {
          function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor) descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
          };
        }();

        var _get = function get(object, property, receiver) {
          if (object === null) object = Function.prototype;
          var desc = Object.getOwnPropertyDescriptor(object, property);

          if (desc === undefined) {
            var parent = Object.getPrototypeOf(object);

            if (parent === null) {
              return undefined;
            } else {
              return get(parent, property, receiver);
            }
          } else if ("value" in desc) {
            return desc.value;
          } else {
            var getter = desc.get;

            if (getter === undefined) {
              return undefined;
            }

            return getter.call(receiver);
          }
        };

        var _parchment = __webpack_require__(0);

        var _parchment2 = _interopRequireDefault(_parchment);

        var _text = __webpack_require__(7);

        var _text2 = _interopRequireDefault(_text);

        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : {
            "default": obj
          };
        }

        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }

        function _possibleConstructorReturn(self, call) {
          if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }

          return call && (_typeof(call) === "object" || typeof call === "function") ? call : self;
        }

        function _inherits(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + _typeof(superClass));
          }

          subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
              value: subClass,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }

        var GUARD_TEXT = "\uFEFF";

        var Embed = function (_Parchment$Embed) {
          _inherits(Embed, _Parchment$Embed);

          function Embed(node) {
            _classCallCheck(this, Embed);

            var _this = _possibleConstructorReturn(this, (Embed.__proto__ || Object.getPrototypeOf(Embed)).call(this, node));

            _this.contentNode = document.createElement('span');

            _this.contentNode.setAttribute('contenteditable', false);

            [].slice.call(_this.domNode.childNodes).forEach(function (childNode) {
              _this.contentNode.appendChild(childNode);
            });
            _this.leftGuard = document.createTextNode(GUARD_TEXT);
            _this.rightGuard = document.createTextNode(GUARD_TEXT);

            _this.domNode.appendChild(_this.leftGuard);

            _this.domNode.appendChild(_this.contentNode);

            _this.domNode.appendChild(_this.rightGuard);

            return _this;
          }

          _createClass(Embed, [{
            key: 'index',
            value: function index(node, offset) {
              if (node === this.leftGuard) return 0;
              if (node === this.rightGuard) return 1;
              return _get(Embed.prototype.__proto__ || Object.getPrototypeOf(Embed.prototype), 'index', this).call(this, node, offset);
            }
          }, {
            key: 'restore',
            value: function restore(node) {
              var range = void 0,
                  textNode = void 0;
              var text = node.data.split(GUARD_TEXT).join('');

              if (node === this.leftGuard) {
                if (this.prev instanceof _text2["default"]) {
                  var prevLength = this.prev.length();
                  this.prev.insertAt(prevLength, text);
                  range = {
                    startNode: this.prev.domNode,
                    startOffset: prevLength + text.length
                  };
                } else {
                  textNode = document.createTextNode(text);
                  this.parent.insertBefore(_parchment2["default"].create(textNode), this);
                  range = {
                    startNode: textNode,
                    startOffset: text.length
                  };
                }
              } else if (node === this.rightGuard) {
                if (this.next instanceof _text2["default"]) {
                  this.next.insertAt(0, text);
                  range = {
                    startNode: this.next.domNode,
                    startOffset: text.length
                  };
                } else {
                  textNode = document.createTextNode(text);
                  this.parent.insertBefore(_parchment2["default"].create(textNode), this.next);
                  range = {
                    startNode: textNode,
                    startOffset: text.length
                  };
                }
              }

              node.data = GUARD_TEXT;
              return range;
            }
          }, {
            key: 'update',
            value: function update(mutations, context) {
              var _this2 = this;

              mutations.forEach(function (mutation) {
                if (mutation.type === 'characterData' && (mutation.target === _this2.leftGuard || mutation.target === _this2.rightGuard)) {
                  var range = _this2.restore(mutation.target);

                  if (range) context.range = range;
                }
              });
            }
          }]);

          return Embed;
        }(_parchment2["default"].Embed);

        exports["default"] = Embed;
        /***/
      },
      /* 36 */

      /***/
      function (module, exports, __webpack_require__) {

        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.AlignStyle = exports.AlignClass = exports.AlignAttribute = undefined;

        var _parchment = __webpack_require__(0);

        var _parchment2 = _interopRequireDefault(_parchment);

        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : {
            "default": obj
          };
        }

        var config = {
          scope: _parchment2["default"].Scope.BLOCK,
          whitelist: ['right', 'center', 'justify']
        };
        var AlignAttribute = new _parchment2["default"].Attributor.Attribute('align', 'align', config);
        var AlignClass = new _parchment2["default"].Attributor.Class('align', 'ql-align', config);
        var AlignStyle = new _parchment2["default"].Attributor.Style('align', 'text-align', config);
        exports.AlignAttribute = AlignAttribute;
        exports.AlignClass = AlignClass;
        exports.AlignStyle = AlignStyle;
        /***/
      },
      /* 37 */

      /***/
      function (module, exports, __webpack_require__) {

        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.BackgroundStyle = exports.BackgroundClass = undefined;

        var _parchment = __webpack_require__(0);

        var _parchment2 = _interopRequireDefault(_parchment);

        var _color = __webpack_require__(26);

        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : {
            "default": obj
          };
        }

        var BackgroundClass = new _parchment2["default"].Attributor.Class('background', 'ql-bg', {
          scope: _parchment2["default"].Scope.INLINE
        });
        var BackgroundStyle = new _color.ColorAttributor('background', 'background-color', {
          scope: _parchment2["default"].Scope.INLINE
        });
        exports.BackgroundClass = BackgroundClass;
        exports.BackgroundStyle = BackgroundStyle;
        /***/
      },
      /* 38 */

      /***/
      function (module, exports, __webpack_require__) {

        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.DirectionStyle = exports.DirectionClass = exports.DirectionAttribute = undefined;

        var _parchment = __webpack_require__(0);

        var _parchment2 = _interopRequireDefault(_parchment);

        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : {
            "default": obj
          };
        }

        var config = {
          scope: _parchment2["default"].Scope.BLOCK,
          whitelist: ['rtl']
        };
        var DirectionAttribute = new _parchment2["default"].Attributor.Attribute('direction', 'dir', config);
        var DirectionClass = new _parchment2["default"].Attributor.Class('direction', 'ql-direction', config);
        var DirectionStyle = new _parchment2["default"].Attributor.Style('direction', 'direction', config);
        exports.DirectionAttribute = DirectionAttribute;
        exports.DirectionClass = DirectionClass;
        exports.DirectionStyle = DirectionStyle;
        /***/
      },
      /* 39 */

      /***/
      function (module, exports, __webpack_require__) {

        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.FontClass = exports.FontStyle = undefined;

        var _createClass = function () {
          function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor) descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
          };
        }();

        var _get = function get(object, property, receiver) {
          if (object === null) object = Function.prototype;
          var desc = Object.getOwnPropertyDescriptor(object, property);

          if (desc === undefined) {
            var parent = Object.getPrototypeOf(object);

            if (parent === null) {
              return undefined;
            } else {
              return get(parent, property, receiver);
            }
          } else if ("value" in desc) {
            return desc.value;
          } else {
            var getter = desc.get;

            if (getter === undefined) {
              return undefined;
            }

            return getter.call(receiver);
          }
        };

        var _parchment = __webpack_require__(0);

        var _parchment2 = _interopRequireDefault(_parchment);

        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : {
            "default": obj
          };
        }

        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }

        function _possibleConstructorReturn(self, call) {
          if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }

          return call && (_typeof(call) === "object" || typeof call === "function") ? call : self;
        }

        function _inherits(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + _typeof(superClass));
          }

          subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
              value: subClass,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }

        var config = {
          scope: _parchment2["default"].Scope.INLINE,
          whitelist: ['serif', 'monospace']
        };
        var FontClass = new _parchment2["default"].Attributor.Class('font', 'ql-font', config);

        var FontStyleAttributor = function (_Parchment$Attributor) {
          _inherits(FontStyleAttributor, _Parchment$Attributor);

          function FontStyleAttributor() {
            _classCallCheck(this, FontStyleAttributor);

            return _possibleConstructorReturn(this, (FontStyleAttributor.__proto__ || Object.getPrototypeOf(FontStyleAttributor)).apply(this, arguments));
          }

          _createClass(FontStyleAttributor, [{
            key: 'value',
            value: function value(node) {
              return _get(FontStyleAttributor.prototype.__proto__ || Object.getPrototypeOf(FontStyleAttributor.prototype), 'value', this).call(this, node).replace(/["']/g, '');
            }
          }]);

          return FontStyleAttributor;
        }(_parchment2["default"].Attributor.Style);

        var FontStyle = new FontStyleAttributor('font', 'font-family', config);
        exports.FontStyle = FontStyle;
        exports.FontClass = FontClass;
        /***/
      },
      /* 40 */

      /***/
      function (module, exports, __webpack_require__) {

        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.SizeStyle = exports.SizeClass = undefined;

        var _parchment = __webpack_require__(0);

        var _parchment2 = _interopRequireDefault(_parchment);

        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : {
            "default": obj
          };
        }

        var SizeClass = new _parchment2["default"].Attributor.Class('size', 'ql-size', {
          scope: _parchment2["default"].Scope.INLINE,
          whitelist: ['small', 'large', 'huge']
        });
        var SizeStyle = new _parchment2["default"].Attributor.Style('size', 'font-size', {
          scope: _parchment2["default"].Scope.INLINE,
          whitelist: ['10px', '18px', '32px']
        });
        exports.SizeClass = SizeClass;
        exports.SizeStyle = SizeStyle;
        /***/
      },
      /* 41 */

      /***/
      function (module, exports, __webpack_require__) {

        module.exports = {
          'align': {
            '': __webpack_require__(76),
            'center': __webpack_require__(77),
            'right': __webpack_require__(78),
            'justify': __webpack_require__(79)
          },
          'background': __webpack_require__(80),
          'blockquote': __webpack_require__(81),
          'bold': __webpack_require__(82),
          'clean': __webpack_require__(83),
          'code': __webpack_require__(58),
          'code-block': __webpack_require__(58),
          'color': __webpack_require__(84),
          'direction': {
            '': __webpack_require__(85),
            'rtl': __webpack_require__(86)
          },
          'float': {
            'center': __webpack_require__(87),
            'full': __webpack_require__(88),
            'left': __webpack_require__(89),
            'right': __webpack_require__(90)
          },
          'formula': __webpack_require__(91),
          'header': {
            '1': __webpack_require__(92),
            '2': __webpack_require__(93)
          },
          'italic': __webpack_require__(94),
          'image': __webpack_require__(95),
          'indent': {
            '+1': __webpack_require__(96),
            '-1': __webpack_require__(97)
          },
          'link': __webpack_require__(98),
          'list': {
            'ordered': __webpack_require__(99),
            'bullet': __webpack_require__(100),
            'check': __webpack_require__(101)
          },
          'script': {
            'sub': __webpack_require__(102),
            'super': __webpack_require__(103)
          },
          'strike': __webpack_require__(104),
          'underline': __webpack_require__(105),
          'video': __webpack_require__(106)
        };
        /***/
      },
      /* 42 */

      /***/
      function (module, exports, __webpack_require__) {

        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.getLastChangeIndex = exports["default"] = undefined;

        var _createClass = function () {
          function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor) descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
          };
        }();

        var _parchment = __webpack_require__(0);

        var _parchment2 = _interopRequireDefault(_parchment);

        var _quill = __webpack_require__(5);

        var _quill2 = _interopRequireDefault(_quill);

        var _module = __webpack_require__(9);

        var _module2 = _interopRequireDefault(_module);

        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : {
            "default": obj
          };
        }

        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }

        function _possibleConstructorReturn(self, call) {
          if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }

          return call && (_typeof(call) === "object" || typeof call === "function") ? call : self;
        }

        function _inherits(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + _typeof(superClass));
          }

          subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
              value: subClass,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }

        var History = function (_Module) {
          _inherits(History, _Module);

          function History(quill, options) {
            _classCallCheck(this, History);

            var _this = _possibleConstructorReturn(this, (History.__proto__ || Object.getPrototypeOf(History)).call(this, quill, options));

            _this.lastRecorded = 0;
            _this.ignoreChange = false;

            _this.clear();

            _this.quill.on(_quill2["default"].events.EDITOR_CHANGE, function (eventName, delta, oldDelta, source) {
              if (eventName !== _quill2["default"].events.TEXT_CHANGE || _this.ignoreChange) return;

              if (!_this.options.userOnly || source === _quill2["default"].sources.USER) {
                _this.record(delta, oldDelta);
              } else {
                _this.transform(delta);
              }
            });

            _this.quill.keyboard.addBinding({
              key: 'Z',
              shortKey: true
            }, _this.undo.bind(_this));

            _this.quill.keyboard.addBinding({
              key: 'Z',
              shortKey: true,
              shiftKey: true
            }, _this.redo.bind(_this));

            if (/Win/i.test(navigator.platform)) {
              _this.quill.keyboard.addBinding({
                key: 'Y',
                shortKey: true
              }, _this.redo.bind(_this));
            }

            return _this;
          }

          _createClass(History, [{
            key: 'change',
            value: function change(source, dest) {
              if (this.stack[source].length === 0) return;
              var delta = this.stack[source].pop();
              this.stack[dest].push(delta);
              this.lastRecorded = 0;
              this.ignoreChange = true;
              this.quill.updateContents(delta[source], _quill2["default"].sources.USER);
              this.ignoreChange = false;
              var index = getLastChangeIndex(delta[source]);
              this.quill.setSelection(index);
            }
          }, {
            key: 'clear',
            value: function clear() {
              this.stack = {
                undo: [],
                redo: []
              };
            }
          }, {
            key: 'cutoff',
            value: function cutoff() {
              this.lastRecorded = 0;
            }
          }, {
            key: 'record',
            value: function record(changeDelta, oldDelta) {
              if (changeDelta.ops.length === 0) return;
              this.stack.redo = [];
              var undoDelta = this.quill.getContents().diff(oldDelta);
              var timestamp = Date.now();

              if (this.lastRecorded + this.options.delay > timestamp && this.stack.undo.length > 0) {
                var delta = this.stack.undo.pop();
                undoDelta = undoDelta.compose(delta.undo);
                changeDelta = delta.redo.compose(changeDelta);
              } else {
                this.lastRecorded = timestamp;
              }

              this.stack.undo.push({
                redo: changeDelta,
                undo: undoDelta
              });

              if (this.stack.undo.length > this.options.maxStack) {
                this.stack.undo.shift();
              }
            }
          }, {
            key: 'redo',
            value: function redo() {
              this.change('redo', 'undo');
            }
          }, {
            key: 'transform',
            value: function transform(delta) {
              this.stack.undo.forEach(function (change) {
                change.undo = delta.transform(change.undo, true);
                change.redo = delta.transform(change.redo, true);
              });
              this.stack.redo.forEach(function (change) {
                change.undo = delta.transform(change.undo, true);
                change.redo = delta.transform(change.redo, true);
              });
            }
          }, {
            key: 'undo',
            value: function undo() {
              this.change('undo', 'redo');
            }
          }]);

          return History;
        }(_module2["default"]);

        History.DEFAULTS = {
          delay: 1000,
          maxStack: 100,
          userOnly: false
        };

        function endsWithNewlineChange(delta) {
          var lastOp = delta.ops[delta.ops.length - 1];
          if (lastOp == null) return false;

          if (lastOp.insert != null) {
            return typeof lastOp.insert === 'string' && lastOp.insert.endsWith('\n');
          }

          if (lastOp.attributes != null) {
            return Object.keys(lastOp.attributes).some(function (attr) {
              return _parchment2["default"].query(attr, _parchment2["default"].Scope.BLOCK) != null;
            });
          }

          return false;
        }

        function getLastChangeIndex(delta) {
          var deleteLength = delta.reduce(function (length, op) {
            length += op["delete"] || 0;
            return length;
          }, 0);
          var changeIndex = delta.length() - deleteLength;

          if (endsWithNewlineChange(delta)) {
            changeIndex -= 1;
          }

          return changeIndex;
        }

        exports["default"] = History;
        exports.getLastChangeIndex = getLastChangeIndex;
        /***/
      },
      /* 43 */

      /***/
      function (module, exports, __webpack_require__) {

        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports["default"] = exports.BaseTooltip = undefined;

        var _createClass = function () {
          function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor) descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
          };
        }();

        var _get = function get(object, property, receiver) {
          if (object === null) object = Function.prototype;
          var desc = Object.getOwnPropertyDescriptor(object, property);

          if (desc === undefined) {
            var parent = Object.getPrototypeOf(object);

            if (parent === null) {
              return undefined;
            } else {
              return get(parent, property, receiver);
            }
          } else if ("value" in desc) {
            return desc.value;
          } else {
            var getter = desc.get;

            if (getter === undefined) {
              return undefined;
            }

            return getter.call(receiver);
          }
        };

        var _extend = __webpack_require__(3);

        var _extend2 = _interopRequireDefault(_extend);

        var _quillDelta = __webpack_require__(2);

        var _quillDelta2 = _interopRequireDefault(_quillDelta);

        var _emitter = __webpack_require__(8);

        var _emitter2 = _interopRequireDefault(_emitter);

        var _keyboard = __webpack_require__(23);

        var _keyboard2 = _interopRequireDefault(_keyboard);

        var _theme = __webpack_require__(34);

        var _theme2 = _interopRequireDefault(_theme);

        var _colorPicker = __webpack_require__(59);

        var _colorPicker2 = _interopRequireDefault(_colorPicker);

        var _iconPicker = __webpack_require__(60);

        var _iconPicker2 = _interopRequireDefault(_iconPicker);

        var _picker = __webpack_require__(28);

        var _picker2 = _interopRequireDefault(_picker);

        var _tooltip = __webpack_require__(61);

        var _tooltip2 = _interopRequireDefault(_tooltip);

        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : {
            "default": obj
          };
        }

        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }

        function _possibleConstructorReturn(self, call) {
          if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }

          return call && (_typeof(call) === "object" || typeof call === "function") ? call : self;
        }

        function _inherits(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + _typeof(superClass));
          }

          subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
              value: subClass,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }

        var ALIGNS = [false, 'center', 'right', 'justify'];
        var COLORS = ["#000000", "#e60000", "#ff9900", "#ffff00", "#008a00", "#0066cc", "#9933ff", "#ffffff", "#facccc", "#ffebcc", "#ffffcc", "#cce8cc", "#cce0f5", "#ebd6ff", "#bbbbbb", "#f06666", "#ffc266", "#ffff66", "#66b966", "#66a3e0", "#c285ff", "#888888", "#a10000", "#b26b00", "#b2b200", "#006100", "#0047b2", "#6b24b2", "#444444", "#5c0000", "#663d00", "#666600", "#003700", "#002966", "#3d1466"];
        var FONTS = [false, 'serif', 'monospace'];
        var HEADERS = ['1', '2', '3', false];
        var SIZES = ['small', false, 'large', 'huge'];

        var BaseTheme = function (_Theme) {
          _inherits(BaseTheme, _Theme);

          function BaseTheme(quill, options) {
            _classCallCheck(this, BaseTheme);

            var _this = _possibleConstructorReturn(this, (BaseTheme.__proto__ || Object.getPrototypeOf(BaseTheme)).call(this, quill, options));

            var listener = function listener(e) {
              if (!document.body.contains(quill.root)) {
                return document.body.removeEventListener('click', listener);
              }

              if (_this.tooltip != null && !_this.tooltip.root.contains(e.target) && document.activeElement !== _this.tooltip.textbox && !_this.quill.hasFocus()) {
                _this.tooltip.hide();
              }

              if (_this.pickers != null) {
                _this.pickers.forEach(function (picker) {
                  if (!picker.container.contains(e.target)) {
                    picker.close();
                  }
                });
              }
            };

            quill.emitter.listenDOM('click', document.body, listener);
            return _this;
          }

          _createClass(BaseTheme, [{
            key: 'addModule',
            value: function addModule(name) {
              var module = _get(BaseTheme.prototype.__proto__ || Object.getPrototypeOf(BaseTheme.prototype), 'addModule', this).call(this, name);

              if (name === 'toolbar') {
                this.extendToolbar(module);
              }

              return module;
            }
          }, {
            key: 'buildButtons',
            value: function buildButtons(buttons, icons) {
              buttons.forEach(function (button) {
                var className = button.getAttribute('class') || '';
                className.split(/\s+/).forEach(function (name) {
                  if (!name.startsWith('ql-')) return;
                  name = name.slice('ql-'.length);
                  if (icons[name] == null) return;

                  if (name === 'direction') {
                    button.innerHTML = icons[name][''] + icons[name]['rtl'];
                  } else if (typeof icons[name] === 'string') {
                    button.innerHTML = icons[name];
                  } else {
                    var value = button.value || '';

                    if (value != null && icons[name][value]) {
                      button.innerHTML = icons[name][value];
                    }
                  }
                });
              });
            }
          }, {
            key: 'buildPickers',
            value: function buildPickers(selects, icons) {
              var _this2 = this;

              this.pickers = selects.map(function (select) {
                if (select.classList.contains('ql-align')) {
                  if (select.querySelector('option') == null) {
                    fillSelect(select, ALIGNS);
                  }

                  return new _iconPicker2["default"](select, icons.align);
                } else if (select.classList.contains('ql-background') || select.classList.contains('ql-color')) {
                  var format = select.classList.contains('ql-background') ? 'background' : 'color';

                  if (select.querySelector('option') == null) {
                    fillSelect(select, COLORS, format === 'background' ? '#ffffff' : '#000000');
                  }

                  return new _colorPicker2["default"](select, icons[format]);
                } else {
                  if (select.querySelector('option') == null) {
                    if (select.classList.contains('ql-font')) {
                      fillSelect(select, FONTS);
                    } else if (select.classList.contains('ql-header')) {
                      fillSelect(select, HEADERS);
                    } else if (select.classList.contains('ql-size')) {
                      fillSelect(select, SIZES);
                    }
                  }

                  return new _picker2["default"](select);
                }
              });

              var update = function update() {
                _this2.pickers.forEach(function (picker) {
                  picker.update();
                });
              };

              this.quill.on(_emitter2["default"].events.EDITOR_CHANGE, update);
            }
          }]);

          return BaseTheme;
        }(_theme2["default"]);

        BaseTheme.DEFAULTS = (0, _extend2["default"])(true, {}, _theme2["default"].DEFAULTS, {
          modules: {
            toolbar: {
              handlers: {
                formula: function formula() {
                  this.quill.theme.tooltip.edit('formula');
                },
                image: function image() {
                  var _this3 = this;

                  var fileInput = this.container.querySelector('input.ql-image[type=file]');

                  if (fileInput == null) {
                    fileInput = document.createElement('input');
                    fileInput.setAttribute('type', 'file');
                    fileInput.setAttribute('accept', 'image/png, image/gif, image/jpeg, image/bmp, image/x-icon');
                    fileInput.classList.add('ql-image');
                    fileInput.addEventListener('change', function () {
                      if (fileInput.files != null && fileInput.files[0] != null) {
                        var reader = new FileReader();

                        reader.onload = function (e) {
                          var range = _this3.quill.getSelection(true);

                          _this3.quill.updateContents(new _quillDelta2["default"]().retain(range.index)["delete"](range.length).insert({
                            image: e.target.result
                          }), _emitter2["default"].sources.USER);

                          _this3.quill.setSelection(range.index + 1, _emitter2["default"].sources.SILENT);

                          fileInput.value = "";
                        };

                        reader.readAsDataURL(fileInput.files[0]);
                      }
                    });
                    this.container.appendChild(fileInput);
                  }

                  fileInput.click();
                },
                video: function video() {
                  this.quill.theme.tooltip.edit('video');
                }
              }
            }
          }
        });

        var BaseTooltip = function (_Tooltip) {
          _inherits(BaseTooltip, _Tooltip);

          function BaseTooltip(quill, boundsContainer) {
            _classCallCheck(this, BaseTooltip);

            var _this4 = _possibleConstructorReturn(this, (BaseTooltip.__proto__ || Object.getPrototypeOf(BaseTooltip)).call(this, quill, boundsContainer));

            _this4.textbox = _this4.root.querySelector('input[type="text"]');

            _this4.listen();

            return _this4;
          }

          _createClass(BaseTooltip, [{
            key: 'listen',
            value: function listen() {
              var _this5 = this;

              this.textbox.addEventListener('keydown', function (event) {
                if (_keyboard2["default"].match(event, 'enter')) {
                  _this5.save();

                  event.preventDefault();
                } else if (_keyboard2["default"].match(event, 'escape')) {
                  _this5.cancel();

                  event.preventDefault();
                }
              });
            }
          }, {
            key: 'cancel',
            value: function cancel() {
              this.hide();
            }
          }, {
            key: 'edit',
            value: function edit() {
              var mode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'link';
              var preview = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
              this.root.classList.remove('ql-hidden');
              this.root.classList.add('ql-editing');

              if (preview != null) {
                this.textbox.value = preview;
              } else if (mode !== this.root.getAttribute('data-mode')) {
                this.textbox.value = '';
              }

              this.position(this.quill.getBounds(this.quill.selection.savedRange));
              this.textbox.select();
              this.textbox.setAttribute('placeholder', this.textbox.getAttribute('data-' + mode) || '');
              this.root.setAttribute('data-mode', mode);
            }
          }, {
            key: 'restoreFocus',
            value: function restoreFocus() {
              var scrollTop = this.quill.scrollingContainer.scrollTop;
              this.quill.focus();
              this.quill.scrollingContainer.scrollTop = scrollTop;
            }
          }, {
            key: 'save',
            value: function save() {
              var value = this.textbox.value;

              switch (this.root.getAttribute('data-mode')) {
                case 'link':
                  {
                    var scrollTop = this.quill.root.scrollTop;

                    if (this.linkRange) {
                      this.quill.formatText(this.linkRange, 'link', value, _emitter2["default"].sources.USER);
                      delete this.linkRange;
                    } else {
                      this.restoreFocus();
                      this.quill.format('link', value, _emitter2["default"].sources.USER);
                    }

                    this.quill.root.scrollTop = scrollTop;
                    break;
                  }

                case 'video':
                  {
                    value = extractVideoUrl(value);
                  }
                // eslint-disable-next-line no-fallthrough

                case 'formula':
                  {
                    if (!value) break;
                    var range = this.quill.getSelection(true);

                    if (range != null) {
                      var index = range.index + range.length;
                      this.quill.insertEmbed(index, this.root.getAttribute('data-mode'), value, _emitter2["default"].sources.USER);

                      if (this.root.getAttribute('data-mode') === 'formula') {
                        this.quill.insertText(index + 1, ' ', _emitter2["default"].sources.USER);
                      }

                      this.quill.setSelection(index + 2, _emitter2["default"].sources.USER);
                    }

                    break;
                  }
              }

              this.textbox.value = '';
              this.hide();
            }
          }]);

          return BaseTooltip;
        }(_tooltip2["default"]);

        function extractVideoUrl(url) {
          var match = url.match(/^(?:(https?):\/\/)?(?:(?:www|m)\.)?youtube\.com\/watch.*v=([a-zA-Z0-9_-]+)/) || url.match(/^(?:(https?):\/\/)?(?:(?:www|m)\.)?youtu\.be\/([a-zA-Z0-9_-]+)/);

          if (match) {
            return (match[1] || 'https') + '://www.youtube.com/embed/' + match[2] + '?showinfo=0';
          }

          if (match = url.match(/^(?:(https?):\/\/)?(?:www\.)?vimeo\.com\/(\d+)/)) {
            // eslint-disable-line no-cond-assign
            return (match[1] || 'https') + '://player.vimeo.com/video/' + match[2] + '/';
          }

          return url;
        }

        function fillSelect(select, values) {
          var defaultValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          values.forEach(function (value) {
            var option = document.createElement('option');

            if (value === defaultValue) {
              option.setAttribute('selected', 'selected');
            } else {
              option.setAttribute('value', value);
            }

            select.appendChild(option);
          });
        }

        exports.BaseTooltip = BaseTooltip;
        exports["default"] = BaseTheme;
        /***/
      },
      /* 44 */

      /***/
      function (module, exports, __webpack_require__) {

        Object.defineProperty(exports, "__esModule", {
          value: true
        });

        var LinkedList =
        /** @class */
        function () {
          function LinkedList() {
            this.head = this.tail = null;
            this.length = 0;
          }

          LinkedList.prototype.append = function () {
            var nodes = [];

            for (var _i = 0; _i < arguments.length; _i++) {
              nodes[_i] = arguments[_i];
            }

            this.insertBefore(nodes[0], null);

            if (nodes.length > 1) {
              this.append.apply(this, nodes.slice(1));
            }
          };

          LinkedList.prototype.contains = function (node) {
            var cur,
                next = this.iterator();

            while (cur = next()) {
              if (cur === node) return true;
            }

            return false;
          };

          LinkedList.prototype.insertBefore = function (node, refNode) {
            if (!node) return;
            node.next = refNode;

            if (refNode != null) {
              node.prev = refNode.prev;

              if (refNode.prev != null) {
                refNode.prev.next = node;
              }

              refNode.prev = node;

              if (refNode === this.head) {
                this.head = node;
              }
            } else if (this.tail != null) {
              this.tail.next = node;
              node.prev = this.tail;
              this.tail = node;
            } else {
              node.prev = null;
              this.head = this.tail = node;
            }

            this.length += 1;
          };

          LinkedList.prototype.offset = function (target) {
            var index = 0,
                cur = this.head;

            while (cur != null) {
              if (cur === target) return index;
              index += cur.length();
              cur = cur.next;
            }

            return -1;
          };

          LinkedList.prototype.remove = function (node) {
            if (!this.contains(node)) return;
            if (node.prev != null) node.prev.next = node.next;
            if (node.next != null) node.next.prev = node.prev;
            if (node === this.head) this.head = node.next;
            if (node === this.tail) this.tail = node.prev;
            this.length -= 1;
          };

          LinkedList.prototype.iterator = function (curNode) {
            if (curNode === void 0) {
              curNode = this.head;
            } // TODO use yield when we can


            return function () {
              var ret = curNode;
              if (curNode != null) curNode = curNode.next;
              return ret;
            };
          };

          LinkedList.prototype.find = function (index, inclusive) {
            if (inclusive === void 0) {
              inclusive = false;
            }

            var cur,
                next = this.iterator();

            while (cur = next()) {
              var length = cur.length();

              if (index < length || inclusive && index === length && (cur.next == null || cur.next.length() !== 0)) {
                return [cur, index];
              }

              index -= length;
            }

            return [null, 0];
          };

          LinkedList.prototype.forEach = function (callback) {
            var cur,
                next = this.iterator();

            while (cur = next()) {
              callback(cur);
            }
          };

          LinkedList.prototype.forEachAt = function (index, length, callback) {
            if (length <= 0) return;

            var _a = this.find(index),
                startNode = _a[0],
                offset = _a[1];

            var cur,
                curIndex = index - offset,
                next = this.iterator(startNode);

            while ((cur = next()) && curIndex < index + length) {
              var curLength = cur.length();

              if (index > curIndex) {
                callback(cur, index - curIndex, Math.min(length, curIndex + curLength - index));
              } else {
                callback(cur, 0, Math.min(curLength, index + length - curIndex));
              }

              curIndex += curLength;
            }
          };

          LinkedList.prototype.map = function (callback) {
            return this.reduce(function (memo, cur) {
              memo.push(callback(cur));
              return memo;
            }, []);
          };

          LinkedList.prototype.reduce = function (callback, memo) {
            var cur,
                next = this.iterator();

            while (cur = next()) {
              memo = callback(memo, cur);
            }

            return memo;
          };

          return LinkedList;
        }();

        exports["default"] = LinkedList;
        /***/
      },
      /* 45 */

      /***/
      function (module, exports, __webpack_require__) {

        var __extends = this && this.__extends || function () {
          var extendStatics = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function (d, b) {
            d.__proto__ = b;
          } || function (d, b) {
            for (var p in b) {
              if (b.hasOwnProperty(p)) d[p] = b[p];
            }
          };

          return function (d, b) {
            extendStatics(d, b);

            function __() {
              this.constructor = d;
            }

            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();

        Object.defineProperty(exports, "__esModule", {
          value: true
        });

        var container_1 = __webpack_require__(17);

        var Registry = __webpack_require__(1);

        var OBSERVER_CONFIG = {
          attributes: true,
          characterData: true,
          characterDataOldValue: true,
          childList: true,
          subtree: true
        };
        var MAX_OPTIMIZE_ITERATIONS = 100;

        var ScrollBlot =
        /** @class */
        function (_super) {
          __extends(ScrollBlot, _super);

          function ScrollBlot(node) {
            var _this = _super.call(this, node) || this;

            _this.scroll = _this;
            _this.observer = new MutationObserver(function (mutations) {
              _this.update(mutations);
            });

            _this.observer.observe(_this.domNode, OBSERVER_CONFIG);

            _this.attach();

            return _this;
          }

          ScrollBlot.prototype.detach = function () {
            _super.prototype.detach.call(this);

            this.observer.disconnect();
          };

          ScrollBlot.prototype.deleteAt = function (index, length) {
            this.update();

            if (index === 0 && length === this.length()) {
              this.children.forEach(function (child) {
                child.remove();
              });
            } else {
              _super.prototype.deleteAt.call(this, index, length);
            }
          };

          ScrollBlot.prototype.formatAt = function (index, length, name, value) {
            this.update();

            _super.prototype.formatAt.call(this, index, length, name, value);
          };

          ScrollBlot.prototype.insertAt = function (index, value, def) {
            this.update();

            _super.prototype.insertAt.call(this, index, value, def);
          };

          ScrollBlot.prototype.optimize = function (mutations, context) {
            var _this = this;

            if (mutations === void 0) {
              mutations = [];
            }

            if (context === void 0) {
              context = {};
            }

            _super.prototype.optimize.call(this, context); // We must modify mutations directly, cannot make copy and then modify


            var records = [].slice.call(this.observer.takeRecords()); // Array.push currently seems to be implemented by a non-tail recursive function
            // so we cannot just mutations.push.apply(mutations, this.observer.takeRecords());

            while (records.length > 0) {
              mutations.push(records.pop());
            } // TODO use WeakMap


            var mark = function mark(blot, markParent) {
              if (markParent === void 0) {
                markParent = true;
              }

              if (blot == null || blot === _this) return;
              if (blot.domNode.parentNode == null) return; // @ts-ignore

              if (blot.domNode[Registry.DATA_KEY].mutations == null) {
                // @ts-ignore
                blot.domNode[Registry.DATA_KEY].mutations = [];
              }

              if (markParent) mark(blot.parent);
            };

            var optimize = function optimize(blot) {
              // Post-order traversal
              if ( // @ts-ignore
              blot.domNode[Registry.DATA_KEY] == null || // @ts-ignore
              blot.domNode[Registry.DATA_KEY].mutations == null) {
                return;
              }

              if (blot instanceof container_1["default"]) {
                blot.children.forEach(optimize);
              }

              blot.optimize(context);
            };

            var remaining = mutations;

            for (var i = 0; remaining.length > 0; i += 1) {
              if (i >= MAX_OPTIMIZE_ITERATIONS) {
                throw new Error('[Parchment] Maximum optimize iterations reached');
              }

              remaining.forEach(function (mutation) {
                var blot = Registry.find(mutation.target, true);
                if (blot == null) return;

                if (blot.domNode === mutation.target) {
                  if (mutation.type === 'childList') {
                    mark(Registry.find(mutation.previousSibling, false));
                    [].forEach.call(mutation.addedNodes, function (node) {
                      var child = Registry.find(node, false);
                      mark(child, false);

                      if (child instanceof container_1["default"]) {
                        child.children.forEach(function (grandChild) {
                          mark(grandChild, false);
                        });
                      }
                    });
                  } else if (mutation.type === 'attributes') {
                    mark(blot.prev);
                  }
                }

                mark(blot);
              });
              this.children.forEach(optimize);
              remaining = [].slice.call(this.observer.takeRecords());
              records = remaining.slice();

              while (records.length > 0) {
                mutations.push(records.pop());
              }
            }
          };

          ScrollBlot.prototype.update = function (mutations, context) {
            var _this = this;

            if (context === void 0) {
              context = {};
            }

            mutations = mutations || this.observer.takeRecords(); // TODO use WeakMap

            mutations.map(function (mutation) {
              var blot = Registry.find(mutation.target, true);
              if (blot == null) return null; // @ts-ignore

              if (blot.domNode[Registry.DATA_KEY].mutations == null) {
                // @ts-ignore
                blot.domNode[Registry.DATA_KEY].mutations = [mutation];
                return blot;
              } else {
                // @ts-ignore
                blot.domNode[Registry.DATA_KEY].mutations.push(mutation);
                return null;
              }
            }).forEach(function (blot) {
              if (blot == null || blot === _this || //@ts-ignore
              blot.domNode[Registry.DATA_KEY] == null) return; // @ts-ignore

              blot.update(blot.domNode[Registry.DATA_KEY].mutations || [], context);
            }); // @ts-ignore

            if (this.domNode[Registry.DATA_KEY].mutations != null) {
              // @ts-ignore
              _super.prototype.update.call(this, this.domNode[Registry.DATA_KEY].mutations, context);
            }

            this.optimize(mutations, context);
          };

          ScrollBlot.blotName = 'scroll';
          ScrollBlot.defaultChild = 'block';
          ScrollBlot.scope = Registry.Scope.BLOCK_BLOT;
          ScrollBlot.tagName = 'DIV';
          return ScrollBlot;
        }(container_1["default"]);

        exports["default"] = ScrollBlot;
        /***/
      },
      /* 46 */

      /***/
      function (module, exports, __webpack_require__) {

        var __extends = this && this.__extends || function () {
          var extendStatics = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function (d, b) {
            d.__proto__ = b;
          } || function (d, b) {
            for (var p in b) {
              if (b.hasOwnProperty(p)) d[p] = b[p];
            }
          };

          return function (d, b) {
            extendStatics(d, b);

            function __() {
              this.constructor = d;
            }

            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();

        Object.defineProperty(exports, "__esModule", {
          value: true
        });

        var format_1 = __webpack_require__(18);

        var Registry = __webpack_require__(1); // Shallow object comparison


        function isEqual(obj1, obj2) {
          if (Object.keys(obj1).length !== Object.keys(obj2).length) return false; // @ts-ignore

          for (var prop in obj1) {
            // @ts-ignore
            if (obj1[prop] !== obj2[prop]) return false;
          }

          return true;
        }

        var InlineBlot =
        /** @class */
        function (_super) {
          __extends(InlineBlot, _super);

          function InlineBlot() {
            return _super !== null && _super.apply(this, arguments) || this;
          }

          InlineBlot.formats = function (domNode) {
            if (domNode.tagName === InlineBlot.tagName) return undefined;
            return _super.formats.call(this, domNode);
          };

          InlineBlot.prototype.format = function (name, value) {
            var _this = this;

            if (name === this.statics.blotName && !value) {
              this.children.forEach(function (child) {
                if (!(child instanceof format_1["default"])) {
                  child = child.wrap(InlineBlot.blotName, true);
                }

                _this.attributes.copy(child);
              });
              this.unwrap();
            } else {
              _super.prototype.format.call(this, name, value);
            }
          };

          InlineBlot.prototype.formatAt = function (index, length, name, value) {
            if (this.formats()[name] != null || Registry.query(name, Registry.Scope.ATTRIBUTE)) {
              var blot = this.isolate(index, length);
              blot.format(name, value);
            } else {
              _super.prototype.formatAt.call(this, index, length, name, value);
            }
          };

          InlineBlot.prototype.optimize = function (context) {
            _super.prototype.optimize.call(this, context);

            var formats = this.formats();

            if (Object.keys(formats).length === 0) {
              return this.unwrap(); // unformatted span
            }

            var next = this.next;

            if (next instanceof InlineBlot && next.prev === this && isEqual(formats, next.formats())) {
              next.moveChildren(this);
              next.remove();
            }
          };

          InlineBlot.blotName = 'inline';
          InlineBlot.scope = Registry.Scope.INLINE_BLOT;
          InlineBlot.tagName = 'SPAN';
          return InlineBlot;
        }(format_1["default"]);

        exports["default"] = InlineBlot;
        /***/
      },
      /* 47 */

      /***/
      function (module, exports, __webpack_require__) {

        var __extends = this && this.__extends || function () {
          var extendStatics = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function (d, b) {
            d.__proto__ = b;
          } || function (d, b) {
            for (var p in b) {
              if (b.hasOwnProperty(p)) d[p] = b[p];
            }
          };

          return function (d, b) {
            extendStatics(d, b);

            function __() {
              this.constructor = d;
            }

            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();

        Object.defineProperty(exports, "__esModule", {
          value: true
        });

        var format_1 = __webpack_require__(18);

        var Registry = __webpack_require__(1);

        var BlockBlot =
        /** @class */
        function (_super) {
          __extends(BlockBlot, _super);

          function BlockBlot() {
            return _super !== null && _super.apply(this, arguments) || this;
          }

          BlockBlot.formats = function (domNode) {
            var tagName = Registry.query(BlockBlot.blotName).tagName;
            if (domNode.tagName === tagName) return undefined;
            return _super.formats.call(this, domNode);
          };

          BlockBlot.prototype.format = function (name, value) {
            if (Registry.query(name, Registry.Scope.BLOCK) == null) {
              return;
            } else if (name === this.statics.blotName && !value) {
              this.replaceWith(BlockBlot.blotName);
            } else {
              _super.prototype.format.call(this, name, value);
            }
          };

          BlockBlot.prototype.formatAt = function (index, length, name, value) {
            if (Registry.query(name, Registry.Scope.BLOCK) != null) {
              this.format(name, value);
            } else {
              _super.prototype.formatAt.call(this, index, length, name, value);
            }
          };

          BlockBlot.prototype.insertAt = function (index, value, def) {
            if (def == null || Registry.query(value, Registry.Scope.INLINE) != null) {
              // Insert text or inline
              _super.prototype.insertAt.call(this, index, value, def);
            } else {
              var after = this.split(index);
              var blot = Registry.create(value, def);
              after.parent.insertBefore(blot, after);
            }
          };

          BlockBlot.prototype.update = function (mutations, context) {
            if (navigator.userAgent.match(/Trident/)) {
              this.build();
            } else {
              _super.prototype.update.call(this, mutations, context);
            }
          };

          BlockBlot.blotName = 'block';
          BlockBlot.scope = Registry.Scope.BLOCK_BLOT;
          BlockBlot.tagName = 'P';
          return BlockBlot;
        }(format_1["default"]);

        exports["default"] = BlockBlot;
        /***/
      },
      /* 48 */

      /***/
      function (module, exports, __webpack_require__) {

        var __extends = this && this.__extends || function () {
          var extendStatics = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function (d, b) {
            d.__proto__ = b;
          } || function (d, b) {
            for (var p in b) {
              if (b.hasOwnProperty(p)) d[p] = b[p];
            }
          };

          return function (d, b) {
            extendStatics(d, b);

            function __() {
              this.constructor = d;
            }

            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();

        Object.defineProperty(exports, "__esModule", {
          value: true
        });

        var leaf_1 = __webpack_require__(19);

        var EmbedBlot =
        /** @class */
        function (_super) {
          __extends(EmbedBlot, _super);

          function EmbedBlot() {
            return _super !== null && _super.apply(this, arguments) || this;
          }

          EmbedBlot.formats = function (domNode) {
            return undefined;
          };

          EmbedBlot.prototype.format = function (name, value) {
            // super.formatAt wraps, which is what we want in general,
            // but this allows subclasses to overwrite for formats
            // that just apply to particular embeds
            _super.prototype.formatAt.call(this, 0, this.length(), name, value);
          };

          EmbedBlot.prototype.formatAt = function (index, length, name, value) {
            if (index === 0 && length === this.length()) {
              this.format(name, value);
            } else {
              _super.prototype.formatAt.call(this, index, length, name, value);
            }
          };

          EmbedBlot.prototype.formats = function () {
            return this.statics.formats(this.domNode);
          };

          return EmbedBlot;
        }(leaf_1["default"]);

        exports["default"] = EmbedBlot;
        /***/
      },
      /* 49 */

      /***/
      function (module, exports, __webpack_require__) {

        var __extends = this && this.__extends || function () {
          var extendStatics = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function (d, b) {
            d.__proto__ = b;
          } || function (d, b) {
            for (var p in b) {
              if (b.hasOwnProperty(p)) d[p] = b[p];
            }
          };

          return function (d, b) {
            extendStatics(d, b);

            function __() {
              this.constructor = d;
            }

            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();

        Object.defineProperty(exports, "__esModule", {
          value: true
        });

        var leaf_1 = __webpack_require__(19);

        var Registry = __webpack_require__(1);

        var TextBlot =
        /** @class */
        function (_super) {
          __extends(TextBlot, _super);

          function TextBlot(node) {
            var _this = _super.call(this, node) || this;

            _this.text = _this.statics.value(_this.domNode);
            return _this;
          }

          TextBlot.create = function (value) {
            return document.createTextNode(value);
          };

          TextBlot.value = function (domNode) {
            var text = domNode.data; // @ts-ignore

            if (text['normalize']) text = text['normalize']();
            return text;
          };

          TextBlot.prototype.deleteAt = function (index, length) {
            this.domNode.data = this.text = this.text.slice(0, index) + this.text.slice(index + length);
          };

          TextBlot.prototype.index = function (node, offset) {
            if (this.domNode === node) {
              return offset;
            }

            return -1;
          };

          TextBlot.prototype.insertAt = function (index, value, def) {
            if (def == null) {
              this.text = this.text.slice(0, index) + value + this.text.slice(index);
              this.domNode.data = this.text;
            } else {
              _super.prototype.insertAt.call(this, index, value, def);
            }
          };

          TextBlot.prototype.length = function () {
            return this.text.length;
          };

          TextBlot.prototype.optimize = function (context) {
            _super.prototype.optimize.call(this, context);

            this.text = this.statics.value(this.domNode);

            if (this.text.length === 0) {
              this.remove();
            } else if (this.next instanceof TextBlot && this.next.prev === this) {
              this.insertAt(this.length(), this.next.value());
              this.next.remove();
            }
          };

          TextBlot.prototype.position = function (index, inclusive) {

            return [this.domNode, index];
          };

          TextBlot.prototype.split = function (index, force) {
            if (force === void 0) {
              force = false;
            }

            if (!force) {
              if (index === 0) return this;
              if (index === this.length()) return this.next;
            }

            var after = Registry.create(this.domNode.splitText(index));
            this.parent.insertBefore(after, this.next);
            this.text = this.statics.value(this.domNode);
            return after;
          };

          TextBlot.prototype.update = function (mutations, context) {
            var _this = this;

            if (mutations.some(function (mutation) {
              return mutation.type === 'characterData' && mutation.target === _this.domNode;
            })) {
              this.text = this.statics.value(this.domNode);
            }
          };

          TextBlot.prototype.value = function () {
            return this.text;
          };

          TextBlot.blotName = 'text';
          TextBlot.scope = Registry.Scope.INLINE_BLOT;
          return TextBlot;
        }(leaf_1["default"]);

        exports["default"] = TextBlot;
        /***/
      },
      /* 50 */

      /***/
      function (module, exports, __webpack_require__) {

        var elem = document.createElement('div');
        elem.classList.toggle('test-class', false);

        if (elem.classList.contains('test-class')) {
          var _toggle = DOMTokenList.prototype.toggle;

          DOMTokenList.prototype.toggle = function (token, force) {
            if (arguments.length > 1 && !this.contains(token) === !force) {
              return force;
            } else {
              return _toggle.call(this, token);
            }
          };
        }

        if (!String.prototype.startsWith) {
          String.prototype.startsWith = function (searchString, position) {
            position = position || 0;
            return this.substr(position, searchString.length) === searchString;
          };
        }

        if (!String.prototype.endsWith) {
          String.prototype.endsWith = function (searchString, position) {
            var subjectString = this.toString();

            if (typeof position !== 'number' || !isFinite(position) || Math.floor(position) !== position || position > subjectString.length) {
              position = subjectString.length;
            }

            position -= searchString.length;
            var lastIndex = subjectString.indexOf(searchString, position);
            return lastIndex !== -1 && lastIndex === position;
          };
        }

        if (!Array.prototype.find) {
          Object.defineProperty(Array.prototype, "find", {
            value: function value(predicate) {
              if (this === null) {
                throw new TypeError('Array.prototype.find called on null or undefined');
              }

              if (typeof predicate !== 'function') {
                throw new TypeError('predicate must be a function');
              }

              var list = Object(this);
              var length = list.length >>> 0;
              var thisArg = arguments[1];
              var value;

              for (var i = 0; i < length; i++) {
                value = list[i];

                if (predicate.call(thisArg, value, i, list)) {
                  return value;
                }
              }

              return undefined;
            }
          });
        }

        document.addEventListener("DOMContentLoaded", function () {
          // Disable resizing in Firefox
          document.execCommand("enableObjectResizing", false, false); // Disable automatic linkifying in IE11

          document.execCommand("autoUrlDetect", false, false);
        });
        /***/
      },
      /* 51 */

      /***/
      function (module, exports) {
        /**
         * This library modifies the diff-patch-match library by Neil Fraser
         * by removing the patch and match functionality and certain advanced
         * options in the diff function. The original license is as follows:
         *
         * ===
         *
         * Diff Match and Patch
         *
         * Copyright 2006 Google Inc.
         * http://code.google.com/p/google-diff-match-patch/
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *   http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        /**
         * The data structure representing a diff is an array of tuples:
         * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]
         * which means: delete 'Hello', add 'Goodbye' and keep ' world.'
         */
        var DIFF_DELETE = -1;
        var DIFF_INSERT = 1;
        var DIFF_EQUAL = 0;
        /**
         * Find the differences between two texts.  Simplifies the problem by stripping
         * any common prefix or suffix off the texts before diffing.
         * @param {string} text1 Old string to be diffed.
         * @param {string} text2 New string to be diffed.
         * @param {Int} cursor_pos Expected edit position in text1 (optional)
         * @return {Array} Array of diff tuples.
         */

        function diff_main(text1, text2, cursor_pos) {
          // Check for equality (speedup).
          if (text1 == text2) {
            if (text1) {
              return [[DIFF_EQUAL, text1]];
            }

            return [];
          } // Check cursor_pos within bounds


          if (cursor_pos < 0 || text1.length < cursor_pos) {
            cursor_pos = null;
          } // Trim off common prefix (speedup).


          var commonlength = diff_commonPrefix(text1, text2);
          var commonprefix = text1.substring(0, commonlength);
          text1 = text1.substring(commonlength);
          text2 = text2.substring(commonlength); // Trim off common suffix (speedup).

          commonlength = diff_commonSuffix(text1, text2);
          var commonsuffix = text1.substring(text1.length - commonlength);
          text1 = text1.substring(0, text1.length - commonlength);
          text2 = text2.substring(0, text2.length - commonlength); // Compute the diff on the middle block.

          var diffs = diff_compute_(text1, text2); // Restore the prefix and suffix.

          if (commonprefix) {
            diffs.unshift([DIFF_EQUAL, commonprefix]);
          }

          if (commonsuffix) {
            diffs.push([DIFF_EQUAL, commonsuffix]);
          }

          diff_cleanupMerge(diffs);

          if (cursor_pos != null) {
            diffs = fix_cursor(diffs, cursor_pos);
          }

          diffs = fix_emoji(diffs);
          return diffs;
        }
        /**
         * Find the differences between two texts.  Assumes that the texts do not
         * have any common prefix or suffix.
         * @param {string} text1 Old string to be diffed.
         * @param {string} text2 New string to be diffed.
         * @return {Array} Array of diff tuples.
         */

        function diff_compute_(text1, text2) {
          var diffs;

          if (!text1) {
            // Just add some text (speedup).
            return [[DIFF_INSERT, text2]];
          }

          if (!text2) {
            // Just delete some text (speedup).
            return [[DIFF_DELETE, text1]];
          }

          var longtext = text1.length > text2.length ? text1 : text2;
          var shorttext = text1.length > text2.length ? text2 : text1;
          var i = longtext.indexOf(shorttext);

          if (i != -1) {
            // Shorter text is inside the longer text (speedup).
            diffs = [[DIFF_INSERT, longtext.substring(0, i)], [DIFF_EQUAL, shorttext], [DIFF_INSERT, longtext.substring(i + shorttext.length)]]; // Swap insertions for deletions if diff is reversed.

            if (text1.length > text2.length) {
              diffs[0][0] = diffs[2][0] = DIFF_DELETE;
            }

            return diffs;
          }

          if (shorttext.length == 1) {
            // Single character string.
            // After the previous speedup, the character can't be an equality.
            return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];
          } // Check to see if the problem can be split in two.


          var hm = diff_halfMatch_(text1, text2);

          if (hm) {
            // A half-match was found, sort out the return data.
            var text1_a = hm[0];
            var text1_b = hm[1];
            var text2_a = hm[2];
            var text2_b = hm[3];
            var mid_common = hm[4]; // Send both pairs off for separate processing.

            var diffs_a = diff_main(text1_a, text2_a);
            var diffs_b = diff_main(text1_b, text2_b); // Merge the results.

            return diffs_a.concat([[DIFF_EQUAL, mid_common]], diffs_b);
          }

          return diff_bisect_(text1, text2);
        }
        /**
         * Find the 'middle snake' of a diff, split the problem in two
         * and return the recursively constructed diff.
         * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.
         * @param {string} text1 Old string to be diffed.
         * @param {string} text2 New string to be diffed.
         * @return {Array} Array of diff tuples.
         * @private
         */

        function diff_bisect_(text1, text2) {
          // Cache the text lengths to prevent multiple calls.
          var text1_length = text1.length;
          var text2_length = text2.length;
          var max_d = Math.ceil((text1_length + text2_length) / 2);
          var v_offset = max_d;
          var v_length = 2 * max_d;
          var v1 = new Array(v_length);
          var v2 = new Array(v_length); // Setting all elements to -1 is faster in Chrome & Firefox than mixing
          // integers and undefined.

          for (var x = 0; x < v_length; x++) {
            v1[x] = -1;
            v2[x] = -1;
          }

          v1[v_offset + 1] = 0;
          v2[v_offset + 1] = 0;
          var delta = text1_length - text2_length; // If the total number of characters is odd, then the front path will collide
          // with the reverse path.

          var front = delta % 2 != 0; // Offsets for start and end of k loop.
          // Prevents mapping of space beyond the grid.

          var k1start = 0;
          var k1end = 0;
          var k2start = 0;
          var k2end = 0;

          for (var d = 0; d < max_d; d++) {
            // Walk the front path one step.
            for (var k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {
              var k1_offset = v_offset + k1;
              var x1;

              if (k1 == -d || k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1]) {
                x1 = v1[k1_offset + 1];
              } else {
                x1 = v1[k1_offset - 1] + 1;
              }

              var y1 = x1 - k1;

              while (x1 < text1_length && y1 < text2_length && text1.charAt(x1) == text2.charAt(y1)) {
                x1++;
                y1++;
              }

              v1[k1_offset] = x1;

              if (x1 > text1_length) {
                // Ran off the right of the graph.
                k1end += 2;
              } else if (y1 > text2_length) {
                // Ran off the bottom of the graph.
                k1start += 2;
              } else if (front) {
                var k2_offset = v_offset + delta - k1;

                if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {
                  // Mirror x2 onto top-left coordinate system.
                  var x2 = text1_length - v2[k2_offset];

                  if (x1 >= x2) {
                    // Overlap detected.
                    return diff_bisectSplit_(text1, text2, x1, y1);
                  }
                }
              }
            } // Walk the reverse path one step.


            for (var k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {
              var k2_offset = v_offset + k2;
              var x2;

              if (k2 == -d || k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1]) {
                x2 = v2[k2_offset + 1];
              } else {
                x2 = v2[k2_offset - 1] + 1;
              }

              var y2 = x2 - k2;

              while (x2 < text1_length && y2 < text2_length && text1.charAt(text1_length - x2 - 1) == text2.charAt(text2_length - y2 - 1)) {
                x2++;
                y2++;
              }

              v2[k2_offset] = x2;

              if (x2 > text1_length) {
                // Ran off the left of the graph.
                k2end += 2;
              } else if (y2 > text2_length) {
                // Ran off the top of the graph.
                k2start += 2;
              } else if (!front) {
                var k1_offset = v_offset + delta - k2;

                if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {
                  var x1 = v1[k1_offset];
                  var y1 = v_offset + x1 - k1_offset; // Mirror x2 onto top-left coordinate system.

                  x2 = text1_length - x2;

                  if (x1 >= x2) {
                    // Overlap detected.
                    return diff_bisectSplit_(text1, text2, x1, y1);
                  }
                }
              }
            }
          } // Diff took too long and hit the deadline or
          // number of diffs equals number of characters, no commonality at all.


          return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];
        }
        /**
         * Given the location of the 'middle snake', split the diff in two parts
         * and recurse.
         * @param {string} text1 Old string to be diffed.
         * @param {string} text2 New string to be diffed.
         * @param {number} x Index of split point in text1.
         * @param {number} y Index of split point in text2.
         * @return {Array} Array of diff tuples.
         */

        function diff_bisectSplit_(text1, text2, x, y) {
          var text1a = text1.substring(0, x);
          var text2a = text2.substring(0, y);
          var text1b = text1.substring(x);
          var text2b = text2.substring(y); // Compute both diffs serially.

          var diffs = diff_main(text1a, text2a);
          var diffsb = diff_main(text1b, text2b);
          return diffs.concat(diffsb);
        }
        /**
         * Determine the common prefix of two strings.
         * @param {string} text1 First string.
         * @param {string} text2 Second string.
         * @return {number} The number of characters common to the start of each
         *     string.
         */

        function diff_commonPrefix(text1, text2) {
          // Quick check for common null cases.
          if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {
            return 0;
          } // Binary search.
          // Performance analysis: http://neil.fraser.name/news/2007/10/09/


          var pointermin = 0;
          var pointermax = Math.min(text1.length, text2.length);
          var pointermid = pointermax;
          var pointerstart = 0;

          while (pointermin < pointermid) {
            if (text1.substring(pointerstart, pointermid) == text2.substring(pointerstart, pointermid)) {
              pointermin = pointermid;
              pointerstart = pointermin;
            } else {
              pointermax = pointermid;
            }

            pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
          }

          return pointermid;
        }
        /**
         * Determine the common suffix of two strings.
         * @param {string} text1 First string.
         * @param {string} text2 Second string.
         * @return {number} The number of characters common to the end of each string.
         */

        function diff_commonSuffix(text1, text2) {
          // Quick check for common null cases.
          if (!text1 || !text2 || text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)) {
            return 0;
          } // Binary search.
          // Performance analysis: http://neil.fraser.name/news/2007/10/09/


          var pointermin = 0;
          var pointermax = Math.min(text1.length, text2.length);
          var pointermid = pointermax;
          var pointerend = 0;

          while (pointermin < pointermid) {
            if (text1.substring(text1.length - pointermid, text1.length - pointerend) == text2.substring(text2.length - pointermid, text2.length - pointerend)) {
              pointermin = pointermid;
              pointerend = pointermin;
            } else {
              pointermax = pointermid;
            }

            pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
          }

          return pointermid;
        }
        /**
         * Do the two texts share a substring which is at least half the length of the
         * longer text?
         * This speedup can produce non-minimal diffs.
         * @param {string} text1 First string.
         * @param {string} text2 Second string.
         * @return {Array.<string>} Five element Array, containing the prefix of
         *     text1, the suffix of text1, the prefix of text2, the suffix of
         *     text2 and the common middle.  Or null if there was no match.
         */

        function diff_halfMatch_(text1, text2) {
          var longtext = text1.length > text2.length ? text1 : text2;
          var shorttext = text1.length > text2.length ? text2 : text1;

          if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {
            return null; // Pointless.
          }
          /**
           * Does a substring of shorttext exist within longtext such that the substring
           * is at least half the length of longtext?
           * Closure, but does not reference any external variables.
           * @param {string} longtext Longer string.
           * @param {string} shorttext Shorter string.
           * @param {number} i Start index of quarter length substring within longtext.
           * @return {Array.<string>} Five element Array, containing the prefix of
           *     longtext, the suffix of longtext, the prefix of shorttext, the suffix
           *     of shorttext and the common middle.  Or null if there was no match.
           * @private
           */


          function diff_halfMatchI_(longtext, shorttext, i) {
            // Start with a 1/4 length substring at position i as a seed.
            var seed = longtext.substring(i, i + Math.floor(longtext.length / 4));
            var j = -1;
            var best_common = '';
            var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;

            while ((j = shorttext.indexOf(seed, j + 1)) != -1) {
              var prefixLength = diff_commonPrefix(longtext.substring(i), shorttext.substring(j));
              var suffixLength = diff_commonSuffix(longtext.substring(0, i), shorttext.substring(0, j));

              if (best_common.length < suffixLength + prefixLength) {
                best_common = shorttext.substring(j - suffixLength, j) + shorttext.substring(j, j + prefixLength);
                best_longtext_a = longtext.substring(0, i - suffixLength);
                best_longtext_b = longtext.substring(i + prefixLength);
                best_shorttext_a = shorttext.substring(0, j - suffixLength);
                best_shorttext_b = shorttext.substring(j + prefixLength);
              }
            }

            if (best_common.length * 2 >= longtext.length) {
              return [best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b, best_common];
            } else {
              return null;
            }
          } // First check if the second quarter is the seed for a half-match.


          var hm1 = diff_halfMatchI_(longtext, shorttext, Math.ceil(longtext.length / 4)); // Check again based on the third quarter.

          var hm2 = diff_halfMatchI_(longtext, shorttext, Math.ceil(longtext.length / 2));
          var hm;

          if (!hm1 && !hm2) {
            return null;
          } else if (!hm2) {
            hm = hm1;
          } else if (!hm1) {
            hm = hm2;
          } else {
            // Both matched.  Select the longest.
            hm = hm1[4].length > hm2[4].length ? hm1 : hm2;
          } // A half-match was found, sort out the return data.


          var text1_a, text1_b, text2_a, text2_b;

          if (text1.length > text2.length) {
            text1_a = hm[0];
            text1_b = hm[1];
            text2_a = hm[2];
            text2_b = hm[3];
          } else {
            text2_a = hm[0];
            text2_b = hm[1];
            text1_a = hm[2];
            text1_b = hm[3];
          }

          var mid_common = hm[4];
          return [text1_a, text1_b, text2_a, text2_b, mid_common];
        }
        /**
         * Reorder and merge like edit sections.  Merge equalities.
         * Any edit section can move as long as it doesn't cross an equality.
         * @param {Array} diffs Array of diff tuples.
         */

        function diff_cleanupMerge(diffs) {
          diffs.push([DIFF_EQUAL, '']); // Add a dummy entry at the end.

          var pointer = 0;
          var count_delete = 0;
          var count_insert = 0;
          var text_delete = '';
          var text_insert = '';
          var commonlength;

          while (pointer < diffs.length) {
            switch (diffs[pointer][0]) {
              case DIFF_INSERT:
                count_insert++;
                text_insert += diffs[pointer][1];
                pointer++;
                break;

              case DIFF_DELETE:
                count_delete++;
                text_delete += diffs[pointer][1];
                pointer++;
                break;

              case DIFF_EQUAL:
                // Upon reaching an equality, check for prior redundancies.
                if (count_delete + count_insert > 1) {
                  if (count_delete !== 0 && count_insert !== 0) {
                    // Factor out any common prefixies.
                    commonlength = diff_commonPrefix(text_insert, text_delete);

                    if (commonlength !== 0) {
                      if (pointer - count_delete - count_insert > 0 && diffs[pointer - count_delete - count_insert - 1][0] == DIFF_EQUAL) {
                        diffs[pointer - count_delete - count_insert - 1][1] += text_insert.substring(0, commonlength);
                      } else {
                        diffs.splice(0, 0, [DIFF_EQUAL, text_insert.substring(0, commonlength)]);
                        pointer++;
                      }

                      text_insert = text_insert.substring(commonlength);
                      text_delete = text_delete.substring(commonlength);
                    } // Factor out any common suffixies.


                    commonlength = diff_commonSuffix(text_insert, text_delete);

                    if (commonlength !== 0) {
                      diffs[pointer][1] = text_insert.substring(text_insert.length - commonlength) + diffs[pointer][1];
                      text_insert = text_insert.substring(0, text_insert.length - commonlength);
                      text_delete = text_delete.substring(0, text_delete.length - commonlength);
                    }
                  } // Delete the offending records and add the merged ones.


                  if (count_delete === 0) {
                    diffs.splice(pointer - count_insert, count_delete + count_insert, [DIFF_INSERT, text_insert]);
                  } else if (count_insert === 0) {
                    diffs.splice(pointer - count_delete, count_delete + count_insert, [DIFF_DELETE, text_delete]);
                  } else {
                    diffs.splice(pointer - count_delete - count_insert, count_delete + count_insert, [DIFF_DELETE, text_delete], [DIFF_INSERT, text_insert]);
                  }

                  pointer = pointer - count_delete - count_insert + (count_delete ? 1 : 0) + (count_insert ? 1 : 0) + 1;
                } else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL) {
                  // Merge this equality with the previous one.
                  diffs[pointer - 1][1] += diffs[pointer][1];
                  diffs.splice(pointer, 1);
                } else {
                  pointer++;
                }

                count_insert = 0;
                count_delete = 0;
                text_delete = '';
                text_insert = '';
                break;
            }
          }

          if (diffs[diffs.length - 1][1] === '') {
            diffs.pop(); // Remove the dummy entry at the end.
          } // Second pass: look for single edits surrounded on both sides by equalities
          // which can be shifted sideways to eliminate an equality.
          // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC


          var changes = false;
          pointer = 1; // Intentionally ignore the first and last element (don't need checking).

          while (pointer < diffs.length - 1) {
            if (diffs[pointer - 1][0] == DIFF_EQUAL && diffs[pointer + 1][0] == DIFF_EQUAL) {
              // This is a single edit surrounded by equalities.
              if (diffs[pointer][1].substring(diffs[pointer][1].length - diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {
                // Shift the edit over the previous equality.
                diffs[pointer][1] = diffs[pointer - 1][1] + diffs[pointer][1].substring(0, diffs[pointer][1].length - diffs[pointer - 1][1].length);
                diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
                diffs.splice(pointer - 1, 1);
                changes = true;
              } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) == diffs[pointer + 1][1]) {
                // Shift the edit over the next equality.
                diffs[pointer - 1][1] += diffs[pointer + 1][1];
                diffs[pointer][1] = diffs[pointer][1].substring(diffs[pointer + 1][1].length) + diffs[pointer + 1][1];
                diffs.splice(pointer + 1, 1);
                changes = true;
              }
            }

            pointer++;
          } // If shifts were made, the diff needs reordering and another shift sweep.


          if (changes) {
            diff_cleanupMerge(diffs);
          }
        }
        var diff = diff_main;
        diff.INSERT = DIFF_INSERT;
        diff.DELETE = DIFF_DELETE;
        diff.EQUAL = DIFF_EQUAL;
        module.exports = diff;
        /*
         * Modify a diff such that the cursor position points to the start of a change:
         * E.g.
         *   cursor_normalize_diff([[DIFF_EQUAL, 'abc']], 1)
         *     => [1, [[DIFF_EQUAL, 'a'], [DIFF_EQUAL, 'bc']]]
         *   cursor_normalize_diff([[DIFF_INSERT, 'new'], [DIFF_DELETE, 'xyz']], 2)
         *     => [2, [[DIFF_INSERT, 'new'], [DIFF_DELETE, 'xy'], [DIFF_DELETE, 'z']]]
         *
         * @param {Array} diffs Array of diff tuples
         * @param {Int} cursor_pos Suggested edit position. Must not be out of bounds!
         * @return {Array} A tuple [cursor location in the modified diff, modified diff]
         */

        function cursor_normalize_diff(diffs, cursor_pos) {
          if (cursor_pos === 0) {
            return [DIFF_EQUAL, diffs];
          }

          for (var current_pos = 0, i = 0; i < diffs.length; i++) {
            var d = diffs[i];

            if (d[0] === DIFF_DELETE || d[0] === DIFF_EQUAL) {
              var next_pos = current_pos + d[1].length;

              if (cursor_pos === next_pos) {
                return [i + 1, diffs];
              } else if (cursor_pos < next_pos) {
                // copy to prevent side effects
                diffs = diffs.slice(); // split d into two diff changes

                var split_pos = cursor_pos - current_pos;
                var d_left = [d[0], d[1].slice(0, split_pos)];
                var d_right = [d[0], d[1].slice(split_pos)];
                diffs.splice(i, 1, d_left, d_right);
                return [i + 1, diffs];
              } else {
                current_pos = next_pos;
              }
            }
          }

          throw new Error('cursor_pos is out of bounds!');
        }
        /*
         * Modify a diff such that the edit position is "shifted" to the proposed edit location (cursor_position).
         *
         * Case 1)
         *   Check if a naive shift is possible:
         *     [0, X], [ 1, Y] -> [ 1, Y], [0, X]    (if X + Y === Y + X)
         *     [0, X], [-1, Y] -> [-1, Y], [0, X]    (if X + Y === Y + X) - holds same result
         * Case 2)
         *   Check if the following shifts are possible:
         *     [0, 'pre'], [ 1, 'prefix'] -> [ 1, 'pre'], [0, 'pre'], [ 1, 'fix']
         *     [0, 'pre'], [-1, 'prefix'] -> [-1, 'pre'], [0, 'pre'], [-1, 'fix']
         *         ^            ^
         *         d          d_next
         *
         * @param {Array} diffs Array of diff tuples
         * @param {Int} cursor_pos Suggested edit position. Must not be out of bounds!
         * @return {Array} Array of diff tuples
         */


        function fix_cursor(diffs, cursor_pos) {
          var norm = cursor_normalize_diff(diffs, cursor_pos);
          var ndiffs = norm[1];
          var cursor_pointer = norm[0];
          var d = ndiffs[cursor_pointer];
          var d_next = ndiffs[cursor_pointer + 1];

          if (d == null) {
            // Text was deleted from end of original string,
            // cursor is now out of bounds in new string
            return diffs;
          } else if (d[0] !== DIFF_EQUAL) {
            // A modification happened at the cursor location.
            // This is the expected outcome, so we can return the original diff.
            return diffs;
          } else {
            if (d_next != null && d[1] + d_next[1] === d_next[1] + d[1]) {
              // Case 1)
              // It is possible to perform a naive shift
              ndiffs.splice(cursor_pointer, 2, d_next, d);
              return merge_tuples(ndiffs, cursor_pointer, 2);
            } else if (d_next != null && d_next[1].indexOf(d[1]) === 0) {
              // Case 2)
              // d[1] is a prefix of d_next[1]
              // We can assume that d_next[0] !== 0, since d[0] === 0
              // Shift edit locations..
              ndiffs.splice(cursor_pointer, 2, [d_next[0], d[1]], [0, d[1]]);
              var suffix = d_next[1].slice(d[1].length);

              if (suffix.length > 0) {
                ndiffs.splice(cursor_pointer + 2, 0, [d_next[0], suffix]);
              }

              return merge_tuples(ndiffs, cursor_pointer, 3);
            } else {
              // Not possible to perform any modification
              return diffs;
            }
          }
        }
        /*
         * Check diff did not split surrogate pairs.
         * Ex. [0, '\uD83D'], [-1, '\uDC36'], [1, '\uDC2F'] -> [-1, '\uD83D\uDC36'], [1, '\uD83D\uDC2F']
         *     '\uD83D\uDC36' === '🐶', '\uD83D\uDC2F' === '🐯'
         *
         * @param {Array} diffs Array of diff tuples
         * @return {Array} Array of diff tuples
         */


        function fix_emoji(diffs) {
          var compact = false;

          var starts_with_pair_end = function starts_with_pair_end(str) {
            return str.charCodeAt(0) >= 0xDC00 && str.charCodeAt(0) <= 0xDFFF;
          };

          var ends_with_pair_start = function ends_with_pair_start(str) {
            return str.charCodeAt(str.length - 1) >= 0xD800 && str.charCodeAt(str.length - 1) <= 0xDBFF;
          };

          for (var i = 2; i < diffs.length; i += 1) {
            if (diffs[i - 2][0] === DIFF_EQUAL && ends_with_pair_start(diffs[i - 2][1]) && diffs[i - 1][0] === DIFF_DELETE && starts_with_pair_end(diffs[i - 1][1]) && diffs[i][0] === DIFF_INSERT && starts_with_pair_end(diffs[i][1])) {
              compact = true;
              diffs[i - 1][1] = diffs[i - 2][1].slice(-1) + diffs[i - 1][1];
              diffs[i][1] = diffs[i - 2][1].slice(-1) + diffs[i][1];
              diffs[i - 2][1] = diffs[i - 2][1].slice(0, -1);
            }
          }

          if (!compact) {
            return diffs;
          }

          var fixed_diffs = [];

          for (var i = 0; i < diffs.length; i += 1) {
            if (diffs[i][1].length > 0) {
              fixed_diffs.push(diffs[i]);
            }
          }

          return fixed_diffs;
        }
        /*
         * Try to merge tuples with their neigbors in a given range.
         * E.g. [0, 'a'], [0, 'b'] -> [0, 'ab']
         *
         * @param {Array} diffs Array of diff tuples.
         * @param {Int} start Position of the first element to merge (diffs[start] is also merged with diffs[start - 1]).
         * @param {Int} length Number of consecutive elements to check.
         * @return {Array} Array of merged diff tuples.
         */


        function merge_tuples(diffs, start, length) {
          // Check from (start-1) to (start+length).
          for (var i = start + length - 1; i >= 0 && i >= start - 1; i--) {
            if (i + 1 < diffs.length) {
              var left_d = diffs[i];
              var right_d = diffs[i + 1];

              if (left_d[0] === right_d[1]) {
                diffs.splice(i, 2, [left_d[0], left_d[1] + right_d[1]]);
              }
            }
          }

          return diffs;
        }
        /***/

      },
      /* 52 */

      /***/
      function (module, exports) {
        exports = module.exports = typeof Object.keys === 'function' ? Object.keys : shim;
        exports.shim = shim;

        function shim(obj) {
          var keys = [];

          for (var key in obj) {
            keys.push(key);
          }

          return keys;
        }
        /***/

      },
      /* 53 */

      /***/
      function (module, exports) {
        var supportsArgumentsClass = function () {
          return Object.prototype.toString.call(arguments);
        }() == '[object Arguments]';

        exports = module.exports = supportsArgumentsClass ? supported : unsupported;
        exports.supported = supported;

        function supported(object) {
          return Object.prototype.toString.call(object) == '[object Arguments]';
        }
        exports.unsupported = unsupported;

        function unsupported(object) {
          return object && _typeof(object) == 'object' && typeof object.length == 'number' && Object.prototype.hasOwnProperty.call(object, 'callee') && !Object.prototype.propertyIsEnumerable.call(object, 'callee') || false;
        }
        /***/
      },
      /* 54 */

      /***/
      function (module, exports) {

        var has = Object.prototype.hasOwnProperty,
            prefix = '~';
        /**
         * Constructor to create a storage for our `EE` objects.
         * An `Events` instance is a plain object whose properties are event names.
         *
         * @constructor
         * @api private
         */

        function Events() {} //
        // We try to not inherit from `Object.prototype`. In some engines creating an
        // instance in this way is faster than calling `Object.create(null)` directly.
        // If `Object.create(null)` is not supported we prefix the event names with a
        // character to make sure that the built-in object properties are not
        // overridden or used as an attack vector.
        //


        if (Object.create) {
          Events.prototype = Object.create(null); //
          // This hack is needed because the `__proto__` property is still inherited in
          // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
          //

          if (!new Events().__proto__) prefix = false;
        }
        /**
         * Representation of a single event listener.
         *
         * @param {Function} fn The listener function.
         * @param {Mixed} context The context to invoke the listener with.
         * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
         * @constructor
         * @api private
         */


        function EE(fn, context, once) {
          this.fn = fn;
          this.context = context;
          this.once = once || false;
        }
        /**
         * Minimal `EventEmitter` interface that is molded against the Node.js
         * `EventEmitter` interface.
         *
         * @constructor
         * @api public
         */


        function EventEmitter() {
          this._events = new Events();
          this._eventsCount = 0;
        }
        /**
         * Return an array listing the events for which the emitter has registered
         * listeners.
         *
         * @returns {Array}
         * @api public
         */


        EventEmitter.prototype.eventNames = function eventNames() {
          var names = [],
              events,
              name;
          if (this._eventsCount === 0) return names;

          for (name in events = this._events) {
            if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
          }

          if (Object.getOwnPropertySymbols) {
            return names.concat(Object.getOwnPropertySymbols(events));
          }

          return names;
        };
        /**
         * Return the listeners registered for a given event.
         *
         * @param {String|Symbol} event The event name.
         * @param {Boolean} exists Only check if there are listeners.
         * @returns {Array|Boolean}
         * @api public
         */


        EventEmitter.prototype.listeners = function listeners(event, exists) {
          var evt = prefix ? prefix + event : event,
              available = this._events[evt];
          if (exists) return !!available;
          if (!available) return [];
          if (available.fn) return [available.fn];

          for (var i = 0, l = available.length, ee = new Array(l); i < l; i++) {
            ee[i] = available[i].fn;
          }

          return ee;
        };
        /**
         * Calls each of the listeners registered for a given event.
         *
         * @param {String|Symbol} event The event name.
         * @returns {Boolean} `true` if the event had listeners, else `false`.
         * @api public
         */


        EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
          var evt = prefix ? prefix + event : event;
          if (!this._events[evt]) return false;
          var listeners = this._events[evt],
              len = arguments.length,
              args,
              i;

          if (listeners.fn) {
            if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);

            switch (len) {
              case 1:
                return listeners.fn.call(listeners.context), true;

              case 2:
                return listeners.fn.call(listeners.context, a1), true;

              case 3:
                return listeners.fn.call(listeners.context, a1, a2), true;

              case 4:
                return listeners.fn.call(listeners.context, a1, a2, a3), true;

              case 5:
                return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;

              case 6:
                return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
            }

            for (i = 1, args = new Array(len - 1); i < len; i++) {
              args[i - 1] = arguments[i];
            }

            listeners.fn.apply(listeners.context, args);
          } else {
            var length = listeners.length,
                j;

            for (i = 0; i < length; i++) {
              if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);

              switch (len) {
                case 1:
                  listeners[i].fn.call(listeners[i].context);
                  break;

                case 2:
                  listeners[i].fn.call(listeners[i].context, a1);
                  break;

                case 3:
                  listeners[i].fn.call(listeners[i].context, a1, a2);
                  break;

                case 4:
                  listeners[i].fn.call(listeners[i].context, a1, a2, a3);
                  break;

                default:
                  if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {
                    args[j - 1] = arguments[j];
                  }
                  listeners[i].fn.apply(listeners[i].context, args);
              }
            }
          }

          return true;
        };
        /**
         * Add a listener for a given event.
         *
         * @param {String|Symbol} event The event name.
         * @param {Function} fn The listener function.
         * @param {Mixed} [context=this] The context to invoke the listener with.
         * @returns {EventEmitter} `this`.
         * @api public
         */


        EventEmitter.prototype.on = function on(event, fn, context) {
          var listener = new EE(fn, context || this),
              evt = prefix ? prefix + event : event;
          if (!this._events[evt]) this._events[evt] = listener, this._eventsCount++;else if (!this._events[evt].fn) this._events[evt].push(listener);else this._events[evt] = [this._events[evt], listener];
          return this;
        };
        /**
         * Add a one-time listener for a given event.
         *
         * @param {String|Symbol} event The event name.
         * @param {Function} fn The listener function.
         * @param {Mixed} [context=this] The context to invoke the listener with.
         * @returns {EventEmitter} `this`.
         * @api public
         */


        EventEmitter.prototype.once = function once(event, fn, context) {
          var listener = new EE(fn, context || this, true),
              evt = prefix ? prefix + event : event;
          if (!this._events[evt]) this._events[evt] = listener, this._eventsCount++;else if (!this._events[evt].fn) this._events[evt].push(listener);else this._events[evt] = [this._events[evt], listener];
          return this;
        };
        /**
         * Remove the listeners of a given event.
         *
         * @param {String|Symbol} event The event name.
         * @param {Function} fn Only remove the listeners that match this function.
         * @param {Mixed} context Only remove the listeners that have this context.
         * @param {Boolean} once Only remove one-time listeners.
         * @returns {EventEmitter} `this`.
         * @api public
         */


        EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
          var evt = prefix ? prefix + event : event;
          if (!this._events[evt]) return this;

          if (!fn) {
            if (--this._eventsCount === 0) this._events = new Events();else delete this._events[evt];
            return this;
          }

          var listeners = this._events[evt];

          if (listeners.fn) {
            if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
              if (--this._eventsCount === 0) this._events = new Events();else delete this._events[evt];
            }
          } else {
            for (var i = 0, events = [], length = listeners.length; i < length; i++) {
              if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
                events.push(listeners[i]);
              }
            } //
            // Reset the array, or remove it completely if we have no more listeners.
            //


            if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;else if (--this._eventsCount === 0) this._events = new Events();else delete this._events[evt];
          }

          return this;
        };
        /**
         * Remove all listeners, or those of the specified event.
         *
         * @param {String|Symbol} [event] The event name.
         * @returns {EventEmitter} `this`.
         * @api public
         */


        EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
          var evt;

          if (event) {
            evt = prefix ? prefix + event : event;

            if (this._events[evt]) {
              if (--this._eventsCount === 0) this._events = new Events();else delete this._events[evt];
            }
          } else {
            this._events = new Events();
            this._eventsCount = 0;
          }

          return this;
        }; //
        // Alias methods names because people roll like that.
        //


        EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
        EventEmitter.prototype.addListener = EventEmitter.prototype.on; //
        // This function doesn't apply anymore.
        //

        EventEmitter.prototype.setMaxListeners = function setMaxListeners() {
          return this;
        }; //
        // Expose the prefix.
        //


        EventEmitter.prefixed = prefix; //
        // Allow `EventEmitter` to be imported as module namespace.
        //

        EventEmitter.EventEmitter = EventEmitter; //
        // Expose the module.
        //

        if ('undefined' !== typeof module) {
          module.exports = EventEmitter;
        }
        /***/

      },
      /* 55 */

      /***/
      function (module, exports, __webpack_require__) {

        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.matchText = exports.matchSpacing = exports.matchNewline = exports.matchBlot = exports.matchAttributor = exports["default"] = undefined;

        var _typeof$1 = typeof Symbol === "function" && _typeof(Symbol.iterator) === "symbol" ? function (obj) {
          return _typeof(obj);
        } : function (obj) {
          return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof(obj);
        };

        var _slicedToArray = function () {
          function sliceIterator(arr, i) {
            var _arr = [];
            var _n = true;
            var _d = false;
            var _e = undefined;

            try {
              for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                _arr.push(_s.value);

                if (i && _arr.length === i) break;
              }
            } catch (err) {
              _d = true;
              _e = err;
            } finally {
              try {
                if (!_n && _i["return"]) _i["return"]();
              } finally {
                if (_d) throw _e;
              }
            }

            return _arr;
          }

          return function (arr, i) {
            if (Array.isArray(arr)) {
              return arr;
            } else if (Symbol.iterator in Object(arr)) {
              return sliceIterator(arr, i);
            } else {
              throw new TypeError("Invalid attempt to destructure non-iterable instance");
            }
          };
        }();

        var _createClass = function () {
          function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor) descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
          };
        }();

        var _extend2 = __webpack_require__(3);

        var _extend3 = _interopRequireDefault(_extend2);

        var _quillDelta = __webpack_require__(2);

        var _quillDelta2 = _interopRequireDefault(_quillDelta);

        var _parchment = __webpack_require__(0);

        var _parchment2 = _interopRequireDefault(_parchment);

        var _quill = __webpack_require__(5);

        var _quill2 = _interopRequireDefault(_quill);

        var _logger = __webpack_require__(10);

        var _logger2 = _interopRequireDefault(_logger);

        var _module = __webpack_require__(9);

        var _module2 = _interopRequireDefault(_module);

        var _align = __webpack_require__(36);

        var _background = __webpack_require__(37);

        var _code = __webpack_require__(13);

        var _code2 = _interopRequireDefault(_code);

        var _color = __webpack_require__(26);

        var _direction = __webpack_require__(38);

        var _font = __webpack_require__(39);

        var _size = __webpack_require__(40);

        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : {
            "default": obj
          };
        }

        function _defineProperty(obj, key, value) {
          if (key in obj) {
            Object.defineProperty(obj, key, {
              value: value,
              enumerable: true,
              configurable: true,
              writable: true
            });
          } else {
            obj[key] = value;
          }

          return obj;
        }

        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }

        function _possibleConstructorReturn(self, call) {
          if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }

          return call && (_typeof(call) === "object" || typeof call === "function") ? call : self;
        }

        function _inherits(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + _typeof(superClass));
          }

          subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
              value: subClass,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }

        var debug = (0, _logger2["default"])('quill:clipboard');
        var DOM_KEY = '__ql-matcher';
        var CLIPBOARD_CONFIG = [[Node.TEXT_NODE, matchText], [Node.TEXT_NODE, matchNewline], ['br', matchBreak], [Node.ELEMENT_NODE, matchNewline], [Node.ELEMENT_NODE, matchBlot], [Node.ELEMENT_NODE, matchSpacing], [Node.ELEMENT_NODE, matchAttributor], [Node.ELEMENT_NODE, matchStyles], ['li', matchIndent], ['b', matchAlias.bind(matchAlias, 'bold')], ['i', matchAlias.bind(matchAlias, 'italic')], ['style', matchIgnore]];
        var ATTRIBUTE_ATTRIBUTORS = [_align.AlignAttribute, _direction.DirectionAttribute].reduce(function (memo, attr) {
          memo[attr.keyName] = attr;
          return memo;
        }, {});
        var STYLE_ATTRIBUTORS = [_align.AlignStyle, _background.BackgroundStyle, _color.ColorStyle, _direction.DirectionStyle, _font.FontStyle, _size.SizeStyle].reduce(function (memo, attr) {
          memo[attr.keyName] = attr;
          return memo;
        }, {});

        var Clipboard = function (_Module) {
          _inherits(Clipboard, _Module);

          function Clipboard(quill, options) {
            _classCallCheck(this, Clipboard);

            var _this = _possibleConstructorReturn(this, (Clipboard.__proto__ || Object.getPrototypeOf(Clipboard)).call(this, quill, options));

            _this.quill.root.addEventListener('paste', _this.onPaste.bind(_this));

            _this.container = _this.quill.addContainer('ql-clipboard');

            _this.container.setAttribute('contenteditable', true);

            _this.container.setAttribute('tabindex', -1);

            _this.matchers = [];
            CLIPBOARD_CONFIG.concat(_this.options.matchers).forEach(function (_ref) {
              var _ref2 = _slicedToArray(_ref, 2),
                  selector = _ref2[0],
                  matcher = _ref2[1];

              if (!options.matchVisual && matcher === matchSpacing) return;

              _this.addMatcher(selector, matcher);
            });
            return _this;
          }

          _createClass(Clipboard, [{
            key: 'addMatcher',
            value: function addMatcher(selector, matcher) {
              this.matchers.push([selector, matcher]);
            }
          }, {
            key: 'convert',
            value: function convert(html) {
              if (typeof html === 'string') {
                this.container.innerHTML = html.replace(/\>\r?\n +\</g, '><'); // Remove spaces between tags

                return this.convert();
              }

              var formats = this.quill.getFormat(this.quill.selection.savedRange.index);

              if (formats[_code2["default"].blotName]) {
                var text = this.container.innerText;
                this.container.innerHTML = '';
                return new _quillDelta2["default"]().insert(text, _defineProperty({}, _code2["default"].blotName, formats[_code2["default"].blotName]));
              }

              var _prepareMatching = this.prepareMatching(),
                  _prepareMatching2 = _slicedToArray(_prepareMatching, 2),
                  elementMatchers = _prepareMatching2[0],
                  textMatchers = _prepareMatching2[1];

              var delta = traverse(this.container, elementMatchers, textMatchers); // Remove trailing newline

              if (deltaEndsWith(delta, '\n') && delta.ops[delta.ops.length - 1].attributes == null) {
                delta = delta.compose(new _quillDelta2["default"]().retain(delta.length() - 1)["delete"](1));
              }

              debug.log('convert', this.container.innerHTML, delta);
              this.container.innerHTML = '';
              return delta;
            }
          }, {
            key: 'dangerouslyPasteHTML',
            value: function dangerouslyPasteHTML(index, html) {
              var source = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _quill2["default"].sources.API;

              if (typeof index === 'string') {
                this.quill.setContents(this.convert(index), html);
                this.quill.setSelection(0, _quill2["default"].sources.SILENT);
              } else {
                var paste = this.convert(html);
                this.quill.updateContents(new _quillDelta2["default"]().retain(index).concat(paste), source);
                this.quill.setSelection(index + paste.length(), _quill2["default"].sources.SILENT);
              }
            }
          }, {
            key: 'onPaste',
            value: function onPaste(e) {
              var _this2 = this;

              if (e.defaultPrevented || !this.quill.isEnabled()) return;
              var range = this.quill.getSelection();
              var delta = new _quillDelta2["default"]().retain(range.index);
              var scrollTop = this.quill.scrollingContainer.scrollTop;
              this.container.focus();
              this.quill.selection.update(_quill2["default"].sources.SILENT);
              setTimeout(function () {
                delta = delta.concat(_this2.convert())["delete"](range.length);

                _this2.quill.updateContents(delta, _quill2["default"].sources.USER); // range.length contributes to delta.length()


                _this2.quill.setSelection(delta.length() - range.length, _quill2["default"].sources.SILENT);

                _this2.quill.scrollingContainer.scrollTop = scrollTop;

                _this2.quill.focus();
              }, 1);
            }
          }, {
            key: 'prepareMatching',
            value: function prepareMatching() {
              var _this3 = this;

              var elementMatchers = [],
                  textMatchers = [];
              this.matchers.forEach(function (pair) {
                var _pair = _slicedToArray(pair, 2),
                    selector = _pair[0],
                    matcher = _pair[1];

                switch (selector) {
                  case Node.TEXT_NODE:
                    textMatchers.push(matcher);
                    break;

                  case Node.ELEMENT_NODE:
                    elementMatchers.push(matcher);
                    break;

                  default:
                    [].forEach.call(_this3.container.querySelectorAll(selector), function (node) {
                      // TODO use weakmap
                      node[DOM_KEY] = node[DOM_KEY] || [];
                      node[DOM_KEY].push(matcher);
                    });
                    break;
                }
              });
              return [elementMatchers, textMatchers];
            }
          }]);

          return Clipboard;
        }(_module2["default"]);

        Clipboard.DEFAULTS = {
          matchers: [],
          matchVisual: true
        };

        function applyFormat(delta, format, value) {
          if ((typeof format === 'undefined' ? 'undefined' : _typeof$1(format)) === 'object') {
            return Object.keys(format).reduce(function (delta, key) {
              return applyFormat(delta, key, format[key]);
            }, delta);
          } else {
            return delta.reduce(function (delta, op) {
              if (op.attributes && op.attributes[format]) {
                return delta.push(op);
              } else {
                return delta.insert(op.insert, (0, _extend3["default"])({}, _defineProperty({}, format, value), op.attributes));
              }
            }, new _quillDelta2["default"]());
          }
        }

        function computeStyle(node) {
          if (node.nodeType !== Node.ELEMENT_NODE) return {};
          var DOM_KEY = '__ql-computed-style';
          return node[DOM_KEY] || (node[DOM_KEY] = window.getComputedStyle(node));
        }

        function deltaEndsWith(delta, text) {
          var endText = "";

          for (var i = delta.ops.length - 1; i >= 0 && endText.length < text.length; --i) {
            var op = delta.ops[i];
            if (typeof op.insert !== 'string') break;
            endText = op.insert + endText;
          }

          return endText.slice(-1 * text.length) === text;
        }

        function isLine(node) {
          if (node.childNodes.length === 0) return false; // Exclude embed blocks

          var style = computeStyle(node);
          return ['block', 'list-item'].indexOf(style.display) > -1;
        }

        function traverse(node, elementMatchers, textMatchers) {
          // Post-order
          if (node.nodeType === node.TEXT_NODE) {
            return textMatchers.reduce(function (delta, matcher) {
              return matcher(node, delta);
            }, new _quillDelta2["default"]());
          } else if (node.nodeType === node.ELEMENT_NODE) {
            return [].reduce.call(node.childNodes || [], function (delta, childNode) {
              var childrenDelta = traverse(childNode, elementMatchers, textMatchers);

              if (childNode.nodeType === node.ELEMENT_NODE) {
                childrenDelta = elementMatchers.reduce(function (childrenDelta, matcher) {
                  return matcher(childNode, childrenDelta);
                }, childrenDelta);
                childrenDelta = (childNode[DOM_KEY] || []).reduce(function (childrenDelta, matcher) {
                  return matcher(childNode, childrenDelta);
                }, childrenDelta);
              }

              return delta.concat(childrenDelta);
            }, new _quillDelta2["default"]());
          } else {
            return new _quillDelta2["default"]();
          }
        }

        function matchAlias(format, node, delta) {
          return applyFormat(delta, format, true);
        }

        function matchAttributor(node, delta) {
          var attributes = _parchment2["default"].Attributor.Attribute.keys(node);

          var classes = _parchment2["default"].Attributor.Class.keys(node);

          var styles = _parchment2["default"].Attributor.Style.keys(node);

          var formats = {};
          attributes.concat(classes).concat(styles).forEach(function (name) {
            var attr = _parchment2["default"].query(name, _parchment2["default"].Scope.ATTRIBUTE);

            if (attr != null) {
              formats[attr.attrName] = attr.value(node);
              if (formats[attr.attrName]) return;
            }

            attr = ATTRIBUTE_ATTRIBUTORS[name];

            if (attr != null && (attr.attrName === name || attr.keyName === name)) {
              formats[attr.attrName] = attr.value(node) || undefined;
            }

            attr = STYLE_ATTRIBUTORS[name];

            if (attr != null && (attr.attrName === name || attr.keyName === name)) {
              attr = STYLE_ATTRIBUTORS[name];
              formats[attr.attrName] = attr.value(node) || undefined;
            }
          });

          if (Object.keys(formats).length > 0) {
            delta = applyFormat(delta, formats);
          }

          return delta;
        }

        function matchBlot(node, delta) {
          var match = _parchment2["default"].query(node);

          if (match == null) return delta;

          if (match.prototype instanceof _parchment2["default"].Embed) {
            var embed = {};
            var value = match.value(node);

            if (value != null) {
              embed[match.blotName] = value;
              delta = new _quillDelta2["default"]().insert(embed, match.formats(node));
            }
          } else if (typeof match.formats === 'function') {
            delta = applyFormat(delta, match.blotName, match.formats(node));
          }

          return delta;
        }

        function matchBreak(node, delta) {
          if (!deltaEndsWith(delta, '\n')) {
            delta.insert('\n');
          }

          return delta;
        }

        function matchIgnore() {
          return new _quillDelta2["default"]();
        }

        function matchIndent(node, delta) {
          var match = _parchment2["default"].query(node);

          if (match == null || match.blotName !== 'list-item' || !deltaEndsWith(delta, '\n')) {
            return delta;
          }

          var indent = -1,
              parent = node.parentNode;

          while (!parent.classList.contains('ql-clipboard')) {
            if ((_parchment2["default"].query(parent) || {}).blotName === 'list') {
              indent += 1;
            }

            parent = parent.parentNode;
          }

          if (indent <= 0) return delta;
          return delta.compose(new _quillDelta2["default"]().retain(delta.length() - 1).retain(1, {
            indent: indent
          }));
        }

        function matchNewline(node, delta) {
          if (!deltaEndsWith(delta, '\n')) {
            if (isLine(node) || delta.length() > 0 && node.nextSibling && isLine(node.nextSibling)) {
              delta.insert('\n');
            }
          }

          return delta;
        }

        function matchSpacing(node, delta) {
          if (isLine(node) && node.nextElementSibling != null && !deltaEndsWith(delta, '\n\n')) {
            var nodeHeight = node.offsetHeight + parseFloat(computeStyle(node).marginTop) + parseFloat(computeStyle(node).marginBottom);

            if (node.nextElementSibling.offsetTop > node.offsetTop + nodeHeight * 1.5) {
              delta.insert('\n');
            }
          }

          return delta;
        }

        function matchStyles(node, delta) {
          var formats = {};
          var style = node.style || {};

          if (style.fontStyle && computeStyle(node).fontStyle === 'italic') {
            formats.italic = true;
          }

          if (style.fontWeight && (computeStyle(node).fontWeight.startsWith('bold') || parseInt(computeStyle(node).fontWeight) >= 700)) {
            formats.bold = true;
          }

          if (Object.keys(formats).length > 0) {
            delta = applyFormat(delta, formats);
          }

          if (parseFloat(style.textIndent || 0) > 0) {
            // Could be 0.5in
            delta = new _quillDelta2["default"]().insert('\t').concat(delta);
          }

          return delta;
        }

        function matchText(node, delta) {
          var text = node.data; // Word represents empty line with <o:p>&nbsp;</o:p>

          if (node.parentNode.tagName === 'O:P') {
            return delta.insert(text.trim());
          }

          if (text.trim().length === 0 && node.parentNode.classList.contains('ql-clipboard')) {
            return delta;
          }

          if (!computeStyle(node.parentNode).whiteSpace.startsWith('pre')) {
            // eslint-disable-next-line func-style
            var replacer = function replacer(collapse, match) {
              match = match.replace(/[^\u00a0]/g, ''); // \u00a0 is nbsp;

              return match.length < 1 && collapse ? ' ' : match;
            };

            text = text.replace(/\r\n/g, ' ').replace(/\n/g, ' ');
            text = text.replace(/\s\s+/g, replacer.bind(replacer, true)); // collapse whitespace

            if (node.previousSibling == null && isLine(node.parentNode) || node.previousSibling != null && isLine(node.previousSibling)) {
              text = text.replace(/^\s+/, replacer.bind(replacer, false));
            }

            if (node.nextSibling == null && isLine(node.parentNode) || node.nextSibling != null && isLine(node.nextSibling)) {
              text = text.replace(/\s+$/, replacer.bind(replacer, false));
            }
          }

          return delta.insert(text);
        }

        exports["default"] = Clipboard;
        exports.matchAttributor = matchAttributor;
        exports.matchBlot = matchBlot;
        exports.matchNewline = matchNewline;
        exports.matchSpacing = matchSpacing;
        exports.matchText = matchText;
        /***/
      },
      /* 56 */

      /***/
      function (module, exports, __webpack_require__) {

        Object.defineProperty(exports, "__esModule", {
          value: true
        });

        var _createClass = function () {
          function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor) descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
          };
        }();

        var _get = function get(object, property, receiver) {
          if (object === null) object = Function.prototype;
          var desc = Object.getOwnPropertyDescriptor(object, property);

          if (desc === undefined) {
            var parent = Object.getPrototypeOf(object);

            if (parent === null) {
              return undefined;
            } else {
              return get(parent, property, receiver);
            }
          } else if ("value" in desc) {
            return desc.value;
          } else {
            var getter = desc.get;

            if (getter === undefined) {
              return undefined;
            }

            return getter.call(receiver);
          }
        };

        var _inline = __webpack_require__(6);

        var _inline2 = _interopRequireDefault(_inline);

        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : {
            "default": obj
          };
        }

        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }

        function _possibleConstructorReturn(self, call) {
          if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }

          return call && (_typeof(call) === "object" || typeof call === "function") ? call : self;
        }

        function _inherits(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + _typeof(superClass));
          }

          subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
              value: subClass,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }

        var Bold = function (_Inline) {
          _inherits(Bold, _Inline);

          function Bold() {
            _classCallCheck(this, Bold);

            return _possibleConstructorReturn(this, (Bold.__proto__ || Object.getPrototypeOf(Bold)).apply(this, arguments));
          }

          _createClass(Bold, [{
            key: 'optimize',
            value: function optimize(context) {
              _get(Bold.prototype.__proto__ || Object.getPrototypeOf(Bold.prototype), 'optimize', this).call(this, context);

              if (this.domNode.tagName !== this.statics.tagName[0]) {
                this.replaceWith(this.statics.blotName);
              }
            }
          }], [{
            key: 'create',
            value: function create() {
              return _get(Bold.__proto__ || Object.getPrototypeOf(Bold), 'create', this).call(this);
            }
          }, {
            key: 'formats',
            value: function formats() {
              return true;
            }
          }]);

          return Bold;
        }(_inline2["default"]);

        Bold.blotName = 'bold';
        Bold.tagName = ['STRONG', 'B'];
        exports["default"] = Bold;
        /***/
      },
      /* 57 */

      /***/
      function (module, exports, __webpack_require__) {

        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.addControls = exports["default"] = undefined;

        var _slicedToArray = function () {
          function sliceIterator(arr, i) {
            var _arr = [];
            var _n = true;
            var _d = false;
            var _e = undefined;

            try {
              for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                _arr.push(_s.value);

                if (i && _arr.length === i) break;
              }
            } catch (err) {
              _d = true;
              _e = err;
            } finally {
              try {
                if (!_n && _i["return"]) _i["return"]();
              } finally {
                if (_d) throw _e;
              }
            }

            return _arr;
          }

          return function (arr, i) {
            if (Array.isArray(arr)) {
              return arr;
            } else if (Symbol.iterator in Object(arr)) {
              return sliceIterator(arr, i);
            } else {
              throw new TypeError("Invalid attempt to destructure non-iterable instance");
            }
          };
        }();

        var _createClass = function () {
          function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor) descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
          };
        }();

        var _quillDelta = __webpack_require__(2);

        var _quillDelta2 = _interopRequireDefault(_quillDelta);

        var _parchment = __webpack_require__(0);

        var _parchment2 = _interopRequireDefault(_parchment);

        var _quill = __webpack_require__(5);

        var _quill2 = _interopRequireDefault(_quill);

        var _logger = __webpack_require__(10);

        var _logger2 = _interopRequireDefault(_logger);

        var _module = __webpack_require__(9);

        var _module2 = _interopRequireDefault(_module);

        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : {
            "default": obj
          };
        }

        function _defineProperty(obj, key, value) {
          if (key in obj) {
            Object.defineProperty(obj, key, {
              value: value,
              enumerable: true,
              configurable: true,
              writable: true
            });
          } else {
            obj[key] = value;
          }

          return obj;
        }

        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }

        function _possibleConstructorReturn(self, call) {
          if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }

          return call && (_typeof(call) === "object" || typeof call === "function") ? call : self;
        }

        function _inherits(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + _typeof(superClass));
          }

          subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
              value: subClass,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }

        var debug = (0, _logger2["default"])('quill:toolbar');

        var Toolbar = function (_Module) {
          _inherits(Toolbar, _Module);

          function Toolbar(quill, options) {
            _classCallCheck(this, Toolbar);

            var _this = _possibleConstructorReturn(this, (Toolbar.__proto__ || Object.getPrototypeOf(Toolbar)).call(this, quill, options));

            if (Array.isArray(_this.options.container)) {
              var container = document.createElement('div');
              addControls(container, _this.options.container);
              quill.container.parentNode.insertBefore(container, quill.container);
              _this.container = container;
            } else if (typeof _this.options.container === 'string') {
              _this.container = document.querySelector(_this.options.container);
            } else {
              _this.container = _this.options.container;
            }

            if (!(_this.container instanceof HTMLElement)) {
              var _ret;

              return _ret = debug.error('Container required for toolbar', _this.options), _possibleConstructorReturn(_this, _ret);
            }

            _this.container.classList.add('ql-toolbar');

            _this.controls = [];
            _this.handlers = {};
            Object.keys(_this.options.handlers).forEach(function (format) {
              _this.addHandler(format, _this.options.handlers[format]);
            });
            [].forEach.call(_this.container.querySelectorAll('button, select'), function (input) {
              _this.attach(input);
            });

            _this.quill.on(_quill2["default"].events.EDITOR_CHANGE, function (type, range) {
              if (type === _quill2["default"].events.SELECTION_CHANGE) {
                _this.update(range);
              }
            });

            _this.quill.on(_quill2["default"].events.SCROLL_OPTIMIZE, function () {
              var _this$quill$selection = _this.quill.selection.getRange(),
                  _this$quill$selection2 = _slicedToArray(_this$quill$selection, 1),
                  range = _this$quill$selection2[0]; // quill.getSelection triggers update


              _this.update(range);
            });

            return _this;
          }

          _createClass(Toolbar, [{
            key: 'addHandler',
            value: function addHandler(format, handler) {
              this.handlers[format] = handler;
            }
          }, {
            key: 'attach',
            value: function attach(input) {
              var _this2 = this;

              var format = [].find.call(input.classList, function (className) {
                return className.indexOf('ql-') === 0;
              });
              if (!format) return;
              format = format.slice('ql-'.length);

              if (input.tagName === 'BUTTON') {
                input.setAttribute('type', 'button');
              }

              if (this.handlers[format] == null) {
                if (this.quill.scroll.whitelist != null && this.quill.scroll.whitelist[format] == null) {
                  debug.warn('ignoring attaching to disabled format', format, input);
                  return;
                }

                if (_parchment2["default"].query(format) == null) {
                  debug.warn('ignoring attaching to nonexistent format', format, input);
                  return;
                }
              }

              var eventName = input.tagName === 'SELECT' ? 'change' : 'click';
              input.addEventListener(eventName, function (e) {
                var value = void 0;

                if (input.tagName === 'SELECT') {
                  if (input.selectedIndex < 0) return;
                  var selected = input.options[input.selectedIndex];

                  if (selected.hasAttribute('selected')) {
                    value = false;
                  } else {
                    value = selected.value || false;
                  }
                } else {
                  if (input.classList.contains('ql-active')) {
                    value = false;
                  } else {
                    value = input.value || !input.hasAttribute('value');
                  }

                  e.preventDefault();
                }

                _this2.quill.focus();

                var _quill$selection$getR = _this2.quill.selection.getRange(),
                    _quill$selection$getR2 = _slicedToArray(_quill$selection$getR, 1),
                    range = _quill$selection$getR2[0];

                if (_this2.handlers[format] != null) {
                  _this2.handlers[format].call(_this2, value);
                } else if (_parchment2["default"].query(format).prototype instanceof _parchment2["default"].Embed) {
                  value = prompt('Enter ' + format);
                  if (!value) return;

                  _this2.quill.updateContents(new _quillDelta2["default"]().retain(range.index)["delete"](range.length).insert(_defineProperty({}, format, value)), _quill2["default"].sources.USER);
                } else {
                  _this2.quill.format(format, value, _quill2["default"].sources.USER);
                }

                _this2.update(range);
              }); // TODO use weakmap

              this.controls.push([format, input]);
            }
          }, {
            key: 'update',
            value: function update(range) {
              var formats = range == null ? {} : this.quill.getFormat(range);
              this.controls.forEach(function (pair) {
                var _pair = _slicedToArray(pair, 2),
                    format = _pair[0],
                    input = _pair[1];

                if (input.tagName === 'SELECT') {
                  var option = void 0;

                  if (range == null) {
                    option = null;
                  } else if (formats[format] == null) {
                    option = input.querySelector('option[selected]');
                  } else if (!Array.isArray(formats[format])) {
                    var value = formats[format];

                    if (typeof value === 'string') {
                      value = value.replace(/\"/g, '\\"');
                    }

                    option = input.querySelector('option[value="' + value + '"]');
                  }

                  if (option == null) {
                    input.value = ''; // TODO make configurable?

                    input.selectedIndex = -1;
                  } else {
                    option.selected = true;
                  }
                } else {
                  if (range == null) {
                    input.classList.remove('ql-active');
                  } else if (input.hasAttribute('value')) {
                    // both being null should match (default values)
                    // '1' should match with 1 (headers)
                    var isActive = formats[format] === input.getAttribute('value') || formats[format] != null && formats[format].toString() === input.getAttribute('value') || formats[format] == null && !input.getAttribute('value');
                    input.classList.toggle('ql-active', isActive);
                  } else {
                    input.classList.toggle('ql-active', formats[format] != null);
                  }
                }
              });
            }
          }]);

          return Toolbar;
        }(_module2["default"]);

        Toolbar.DEFAULTS = {};

        function addButton(container, format, value) {
          var input = document.createElement('button');
          input.setAttribute('type', 'button');
          input.classList.add('ql-' + format);

          if (value != null) {
            input.value = value;
          }

          container.appendChild(input);
        }

        function addControls(container, groups) {
          if (!Array.isArray(groups[0])) {
            groups = [groups];
          }

          groups.forEach(function (controls) {
            var group = document.createElement('span');
            group.classList.add('ql-formats');
            controls.forEach(function (control) {
              if (typeof control === 'string') {
                addButton(group, control);
              } else {
                var format = Object.keys(control)[0];
                var value = control[format];

                if (Array.isArray(value)) {
                  addSelect(group, format, value);
                } else {
                  addButton(group, format, value);
                }
              }
            });
            container.appendChild(group);
          });
        }

        function addSelect(container, format, values) {
          var input = document.createElement('select');
          input.classList.add('ql-' + format);
          values.forEach(function (value) {
            var option = document.createElement('option');

            if (value !== false) {
              option.setAttribute('value', value);
            } else {
              option.setAttribute('selected', 'selected');
            }

            input.appendChild(option);
          });
          container.appendChild(input);
        }

        Toolbar.DEFAULTS = {
          container: null,
          handlers: {
            clean: function clean() {
              var _this3 = this;

              var range = this.quill.getSelection();
              if (range == null) return;

              if (range.length == 0) {
                var formats = this.quill.getFormat();
                Object.keys(formats).forEach(function (name) {
                  // Clean functionality in existing apps only clean inline formats
                  if (_parchment2["default"].query(name, _parchment2["default"].Scope.INLINE) != null) {
                    _this3.quill.format(name, false);
                  }
                });
              } else {
                this.quill.removeFormat(range, _quill2["default"].sources.USER);
              }
            },
            direction: function direction(value) {
              var align = this.quill.getFormat()['align'];

              if (value === 'rtl' && align == null) {
                this.quill.format('align', 'right', _quill2["default"].sources.USER);
              } else if (!value && align === 'right') {
                this.quill.format('align', false, _quill2["default"].sources.USER);
              }

              this.quill.format('direction', value, _quill2["default"].sources.USER);
            },
            indent: function indent(value) {
              var range = this.quill.getSelection();
              var formats = this.quill.getFormat(range);
              var indent = parseInt(formats.indent || 0);

              if (value === '+1' || value === '-1') {
                var modifier = value === '+1' ? 1 : -1;
                if (formats.direction === 'rtl') modifier *= -1;
                this.quill.format('indent', indent + modifier, _quill2["default"].sources.USER);
              }
            },
            link: function link(value) {
              if (value === true) {
                value = prompt('Enter link URL:');
              }

              this.quill.format('link', value, _quill2["default"].sources.USER);
            },
            list: function list(value) {
              var range = this.quill.getSelection();
              var formats = this.quill.getFormat(range);

              if (value === 'check') {
                if (formats['list'] === 'checked' || formats['list'] === 'unchecked') {
                  this.quill.format('list', false, _quill2["default"].sources.USER);
                } else {
                  this.quill.format('list', 'unchecked', _quill2["default"].sources.USER);
                }
              } else {
                this.quill.format('list', value, _quill2["default"].sources.USER);
              }
            }
          }
        };
        exports["default"] = Toolbar;
        exports.addControls = addControls;
        /***/
      },
      /* 58 */

      /***/
      function (module, exports) {
        module.exports = "<svg viewbox=\"0 0 18 18\"> <polyline class=\"ql-even ql-stroke\" points=\"5 7 3 9 5 11\"></polyline> <polyline class=\"ql-even ql-stroke\" points=\"13 7 15 9 13 11\"></polyline> <line class=ql-stroke x1=10 x2=8 y1=5 y2=13></line> </svg>";
        /***/
      },
      /* 59 */

      /***/
      function (module, exports, __webpack_require__) {

        Object.defineProperty(exports, "__esModule", {
          value: true
        });

        var _createClass = function () {
          function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor) descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
          };
        }();

        var _get = function get(object, property, receiver) {
          if (object === null) object = Function.prototype;
          var desc = Object.getOwnPropertyDescriptor(object, property);

          if (desc === undefined) {
            var parent = Object.getPrototypeOf(object);

            if (parent === null) {
              return undefined;
            } else {
              return get(parent, property, receiver);
            }
          } else if ("value" in desc) {
            return desc.value;
          } else {
            var getter = desc.get;

            if (getter === undefined) {
              return undefined;
            }

            return getter.call(receiver);
          }
        };

        var _picker = __webpack_require__(28);

        var _picker2 = _interopRequireDefault(_picker);

        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : {
            "default": obj
          };
        }

        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }

        function _possibleConstructorReturn(self, call) {
          if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }

          return call && (_typeof(call) === "object" || typeof call === "function") ? call : self;
        }

        function _inherits(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + _typeof(superClass));
          }

          subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
              value: subClass,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }

        var ColorPicker = function (_Picker) {
          _inherits(ColorPicker, _Picker);

          function ColorPicker(select, label) {
            _classCallCheck(this, ColorPicker);

            var _this = _possibleConstructorReturn(this, (ColorPicker.__proto__ || Object.getPrototypeOf(ColorPicker)).call(this, select));

            _this.label.innerHTML = label;

            _this.container.classList.add('ql-color-picker');

            [].slice.call(_this.container.querySelectorAll('.ql-picker-item'), 0, 7).forEach(function (item) {
              item.classList.add('ql-primary');
            });
            return _this;
          }

          _createClass(ColorPicker, [{
            key: 'buildItem',
            value: function buildItem(option) {
              var item = _get(ColorPicker.prototype.__proto__ || Object.getPrototypeOf(ColorPicker.prototype), 'buildItem', this).call(this, option);

              item.style.backgroundColor = option.getAttribute('value') || '';
              return item;
            }
          }, {
            key: 'selectItem',
            value: function selectItem(item, trigger) {
              _get(ColorPicker.prototype.__proto__ || Object.getPrototypeOf(ColorPicker.prototype), 'selectItem', this).call(this, item, trigger);

              var colorLabel = this.label.querySelector('.ql-color-label');
              var value = item ? item.getAttribute('data-value') || '' : '';

              if (colorLabel) {
                if (colorLabel.tagName === 'line') {
                  colorLabel.style.stroke = value;
                } else {
                  colorLabel.style.fill = value;
                }
              }
            }
          }]);

          return ColorPicker;
        }(_picker2["default"]);

        exports["default"] = ColorPicker;
        /***/
      },
      /* 60 */

      /***/
      function (module, exports, __webpack_require__) {

        Object.defineProperty(exports, "__esModule", {
          value: true
        });

        var _createClass = function () {
          function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor) descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
          };
        }();

        var _get = function get(object, property, receiver) {
          if (object === null) object = Function.prototype;
          var desc = Object.getOwnPropertyDescriptor(object, property);

          if (desc === undefined) {
            var parent = Object.getPrototypeOf(object);

            if (parent === null) {
              return undefined;
            } else {
              return get(parent, property, receiver);
            }
          } else if ("value" in desc) {
            return desc.value;
          } else {
            var getter = desc.get;

            if (getter === undefined) {
              return undefined;
            }

            return getter.call(receiver);
          }
        };

        var _picker = __webpack_require__(28);

        var _picker2 = _interopRequireDefault(_picker);

        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : {
            "default": obj
          };
        }

        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }

        function _possibleConstructorReturn(self, call) {
          if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }

          return call && (_typeof(call) === "object" || typeof call === "function") ? call : self;
        }

        function _inherits(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + _typeof(superClass));
          }

          subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
              value: subClass,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }

        var IconPicker = function (_Picker) {
          _inherits(IconPicker, _Picker);

          function IconPicker(select, icons) {
            _classCallCheck(this, IconPicker);

            var _this = _possibleConstructorReturn(this, (IconPicker.__proto__ || Object.getPrototypeOf(IconPicker)).call(this, select));

            _this.container.classList.add('ql-icon-picker');

            [].forEach.call(_this.container.querySelectorAll('.ql-picker-item'), function (item) {
              item.innerHTML = icons[item.getAttribute('data-value') || ''];
            });
            _this.defaultItem = _this.container.querySelector('.ql-selected');

            _this.selectItem(_this.defaultItem);

            return _this;
          }

          _createClass(IconPicker, [{
            key: 'selectItem',
            value: function selectItem(item, trigger) {
              _get(IconPicker.prototype.__proto__ || Object.getPrototypeOf(IconPicker.prototype), 'selectItem', this).call(this, item, trigger);

              item = item || this.defaultItem;
              this.label.innerHTML = item.innerHTML;
            }
          }]);

          return IconPicker;
        }(_picker2["default"]);

        exports["default"] = IconPicker;
        /***/
      },
      /* 61 */

      /***/
      function (module, exports, __webpack_require__) {

        Object.defineProperty(exports, "__esModule", {
          value: true
        });

        var _createClass = function () {
          function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor) descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
          };
        }();

        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }

        var Tooltip = function () {
          function Tooltip(quill, boundsContainer) {
            var _this = this;

            _classCallCheck(this, Tooltip);

            this.quill = quill;
            this.boundsContainer = boundsContainer || document.body;
            this.root = quill.addContainer('ql-tooltip');
            this.root.innerHTML = this.constructor.TEMPLATE;

            if (this.quill.root === this.quill.scrollingContainer) {
              this.quill.root.addEventListener('scroll', function () {
                _this.root.style.marginTop = -1 * _this.quill.root.scrollTop + 'px';
              });
            }

            this.hide();
          }

          _createClass(Tooltip, [{
            key: 'hide',
            value: function hide() {
              this.root.classList.add('ql-hidden');
            }
          }, {
            key: 'position',
            value: function position(reference) {
              var left = reference.left + reference.width / 2 - this.root.offsetWidth / 2; // root.scrollTop should be 0 if scrollContainer !== root

              var top = reference.bottom + this.quill.root.scrollTop;
              this.root.style.left = left + 'px';
              this.root.style.top = top + 'px';
              this.root.classList.remove('ql-flip');
              var containerBounds = this.boundsContainer.getBoundingClientRect();
              var rootBounds = this.root.getBoundingClientRect();
              var shift = 0;

              if (rootBounds.right > containerBounds.right) {
                shift = containerBounds.right - rootBounds.right;
                this.root.style.left = left + shift + 'px';
              }

              if (rootBounds.left < containerBounds.left) {
                shift = containerBounds.left - rootBounds.left;
                this.root.style.left = left + shift + 'px';
              }

              if (rootBounds.bottom > containerBounds.bottom) {
                var height = rootBounds.bottom - rootBounds.top;
                var verticalShift = reference.bottom - reference.top + height;
                this.root.style.top = top - verticalShift + 'px';
                this.root.classList.add('ql-flip');
              }

              return shift;
            }
          }, {
            key: 'show',
            value: function show() {
              this.root.classList.remove('ql-editing');
              this.root.classList.remove('ql-hidden');
            }
          }]);

          return Tooltip;
        }();

        exports["default"] = Tooltip;
        /***/
      },
      /* 62 */

      /***/
      function (module, exports, __webpack_require__) {

        Object.defineProperty(exports, "__esModule", {
          value: true
        });

        var _slicedToArray = function () {
          function sliceIterator(arr, i) {
            var _arr = [];
            var _n = true;
            var _d = false;
            var _e = undefined;

            try {
              for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                _arr.push(_s.value);

                if (i && _arr.length === i) break;
              }
            } catch (err) {
              _d = true;
              _e = err;
            } finally {
              try {
                if (!_n && _i["return"]) _i["return"]();
              } finally {
                if (_d) throw _e;
              }
            }

            return _arr;
          }

          return function (arr, i) {
            if (Array.isArray(arr)) {
              return arr;
            } else if (Symbol.iterator in Object(arr)) {
              return sliceIterator(arr, i);
            } else {
              throw new TypeError("Invalid attempt to destructure non-iterable instance");
            }
          };
        }();

        var _get = function get(object, property, receiver) {
          if (object === null) object = Function.prototype;
          var desc = Object.getOwnPropertyDescriptor(object, property);

          if (desc === undefined) {
            var parent = Object.getPrototypeOf(object);

            if (parent === null) {
              return undefined;
            } else {
              return get(parent, property, receiver);
            }
          } else if ("value" in desc) {
            return desc.value;
          } else {
            var getter = desc.get;

            if (getter === undefined) {
              return undefined;
            }

            return getter.call(receiver);
          }
        };

        var _createClass = function () {
          function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor) descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
          };
        }();

        var _extend = __webpack_require__(3);

        var _extend2 = _interopRequireDefault(_extend);

        var _emitter = __webpack_require__(8);

        var _emitter2 = _interopRequireDefault(_emitter);

        var _base = __webpack_require__(43);

        var _base2 = _interopRequireDefault(_base);

        var _link = __webpack_require__(27);

        var _link2 = _interopRequireDefault(_link);

        var _selection = __webpack_require__(15);

        var _icons = __webpack_require__(41);

        var _icons2 = _interopRequireDefault(_icons);

        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : {
            "default": obj
          };
        }

        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }

        function _possibleConstructorReturn(self, call) {
          if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }

          return call && (_typeof(call) === "object" || typeof call === "function") ? call : self;
        }

        function _inherits(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + _typeof(superClass));
          }

          subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
              value: subClass,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }

        var TOOLBAR_CONFIG = [[{
          header: ['1', '2', '3', false]
        }], ['bold', 'italic', 'underline', 'link'], [{
          list: 'ordered'
        }, {
          list: 'bullet'
        }], ['clean']];

        var SnowTheme = function (_BaseTheme) {
          _inherits(SnowTheme, _BaseTheme);

          function SnowTheme(quill, options) {
            _classCallCheck(this, SnowTheme);

            if (options.modules.toolbar != null && options.modules.toolbar.container == null) {
              options.modules.toolbar.container = TOOLBAR_CONFIG;
            }

            var _this = _possibleConstructorReturn(this, (SnowTheme.__proto__ || Object.getPrototypeOf(SnowTheme)).call(this, quill, options));

            _this.quill.container.classList.add('ql-snow');

            return _this;
          }

          _createClass(SnowTheme, [{
            key: 'extendToolbar',
            value: function extendToolbar(toolbar) {
              toolbar.container.classList.add('ql-snow');
              this.buildButtons([].slice.call(toolbar.container.querySelectorAll('button')), _icons2["default"]);
              this.buildPickers([].slice.call(toolbar.container.querySelectorAll('select')), _icons2["default"]);
              this.tooltip = new SnowTooltip(this.quill, this.options.bounds);

              if (toolbar.container.querySelector('.ql-link')) {
                this.quill.keyboard.addBinding({
                  key: 'K',
                  shortKey: true
                }, function (range, context) {
                  toolbar.handlers['link'].call(toolbar, !context.format.link);
                });
              }
            }
          }]);

          return SnowTheme;
        }(_base2["default"]);

        SnowTheme.DEFAULTS = (0, _extend2["default"])(true, {}, _base2["default"].DEFAULTS, {
          modules: {
            toolbar: {
              handlers: {
                link: function link(value) {
                  if (value) {
                    var range = this.quill.getSelection();
                    if (range == null || range.length == 0) return;
                    var preview = this.quill.getText(range);

                    if (/^\S+@\S+\.\S+$/.test(preview) && preview.indexOf('mailto:') !== 0) {
                      preview = 'mailto:' + preview;
                    }

                    var tooltip = this.quill.theme.tooltip;
                    tooltip.edit('link', preview);
                  } else {
                    this.quill.format('link', false);
                  }
                }
              }
            }
          }
        });

        var SnowTooltip = function (_BaseTooltip) {
          _inherits(SnowTooltip, _BaseTooltip);

          function SnowTooltip(quill, bounds) {
            _classCallCheck(this, SnowTooltip);

            var _this2 = _possibleConstructorReturn(this, (SnowTooltip.__proto__ || Object.getPrototypeOf(SnowTooltip)).call(this, quill, bounds));

            _this2.preview = _this2.root.querySelector('a.ql-preview');
            return _this2;
          }

          _createClass(SnowTooltip, [{
            key: 'listen',
            value: function listen() {
              var _this3 = this;

              _get(SnowTooltip.prototype.__proto__ || Object.getPrototypeOf(SnowTooltip.prototype), 'listen', this).call(this);

              this.root.querySelector('a.ql-action').addEventListener('click', function (event) {
                if (_this3.root.classList.contains('ql-editing')) {
                  _this3.save();
                } else {
                  _this3.edit('link', _this3.preview.textContent);
                }

                event.preventDefault();
              });
              this.root.querySelector('a.ql-remove').addEventListener('click', function (event) {
                if (_this3.linkRange != null) {
                  var range = _this3.linkRange;

                  _this3.restoreFocus();

                  _this3.quill.formatText(range, 'link', false, _emitter2["default"].sources.USER);

                  delete _this3.linkRange;
                }

                event.preventDefault();

                _this3.hide();
              });
              this.quill.on(_emitter2["default"].events.SELECTION_CHANGE, function (range, oldRange, source) {
                if (range == null) return;

                if (range.length === 0 && source === _emitter2["default"].sources.USER) {
                  var _quill$scroll$descend = _this3.quill.scroll.descendant(_link2["default"], range.index),
                      _quill$scroll$descend2 = _slicedToArray(_quill$scroll$descend, 2),
                      link = _quill$scroll$descend2[0],
                      offset = _quill$scroll$descend2[1];

                  if (link != null) {
                    _this3.linkRange = new _selection.Range(range.index - offset, link.length());

                    var preview = _link2["default"].formats(link.domNode);

                    _this3.preview.textContent = preview;

                    _this3.preview.setAttribute('href', preview);

                    _this3.show();

                    _this3.position(_this3.quill.getBounds(_this3.linkRange));

                    return;
                  }
                } else {
                  delete _this3.linkRange;
                }

                _this3.hide();
              });
            }
          }, {
            key: 'show',
            value: function show() {
              _get(SnowTooltip.prototype.__proto__ || Object.getPrototypeOf(SnowTooltip.prototype), 'show', this).call(this);

              this.root.removeAttribute('data-mode');
            }
          }]);

          return SnowTooltip;
        }(_base.BaseTooltip);

        SnowTooltip.TEMPLATE = ['<a class="ql-preview" rel="noopener noreferrer" target="_blank" href="about:blank"></a>', '<input type="text" data-formula="e=mc^2" data-link="https://quilljs.com" data-video="Embed URL">', '<a class="ql-action"></a>', '<a class="ql-remove"></a>'].join('');
        exports["default"] = SnowTheme;
        /***/
      },
      /* 63 */

      /***/
      function (module, exports, __webpack_require__) {

        Object.defineProperty(exports, "__esModule", {
          value: true
        });

        var _core = __webpack_require__(29);

        var _core2 = _interopRequireDefault(_core);

        var _align = __webpack_require__(36);

        var _direction = __webpack_require__(38);

        var _indent = __webpack_require__(64);

        var _blockquote = __webpack_require__(65);

        var _blockquote2 = _interopRequireDefault(_blockquote);

        var _header = __webpack_require__(66);

        var _header2 = _interopRequireDefault(_header);

        var _list = __webpack_require__(67);

        var _list2 = _interopRequireDefault(_list);

        var _background = __webpack_require__(37);

        var _color = __webpack_require__(26);

        var _font = __webpack_require__(39);

        var _size = __webpack_require__(40);

        var _bold = __webpack_require__(56);

        var _bold2 = _interopRequireDefault(_bold);

        var _italic = __webpack_require__(68);

        var _italic2 = _interopRequireDefault(_italic);

        var _link = __webpack_require__(27);

        var _link2 = _interopRequireDefault(_link);

        var _script = __webpack_require__(69);

        var _script2 = _interopRequireDefault(_script);

        var _strike = __webpack_require__(70);

        var _strike2 = _interopRequireDefault(_strike);

        var _underline = __webpack_require__(71);

        var _underline2 = _interopRequireDefault(_underline);

        var _image = __webpack_require__(72);

        var _image2 = _interopRequireDefault(_image);

        var _video = __webpack_require__(73);

        var _video2 = _interopRequireDefault(_video);

        var _code = __webpack_require__(13);

        var _code2 = _interopRequireDefault(_code);

        var _formula = __webpack_require__(74);

        var _formula2 = _interopRequireDefault(_formula);

        var _syntax = __webpack_require__(75);

        var _syntax2 = _interopRequireDefault(_syntax);

        var _toolbar = __webpack_require__(57);

        var _toolbar2 = _interopRequireDefault(_toolbar);

        var _icons = __webpack_require__(41);

        var _icons2 = _interopRequireDefault(_icons);

        var _picker = __webpack_require__(28);

        var _picker2 = _interopRequireDefault(_picker);

        var _colorPicker = __webpack_require__(59);

        var _colorPicker2 = _interopRequireDefault(_colorPicker);

        var _iconPicker = __webpack_require__(60);

        var _iconPicker2 = _interopRequireDefault(_iconPicker);

        var _tooltip = __webpack_require__(61);

        var _tooltip2 = _interopRequireDefault(_tooltip);

        var _bubble = __webpack_require__(108);

        var _bubble2 = _interopRequireDefault(_bubble);

        var _snow = __webpack_require__(62);

        var _snow2 = _interopRequireDefault(_snow);

        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : {
            "default": obj
          };
        }

        _core2["default"].register({
          'attributors/attribute/direction': _direction.DirectionAttribute,
          'attributors/class/align': _align.AlignClass,
          'attributors/class/background': _background.BackgroundClass,
          'attributors/class/color': _color.ColorClass,
          'attributors/class/direction': _direction.DirectionClass,
          'attributors/class/font': _font.FontClass,
          'attributors/class/size': _size.SizeClass,
          'attributors/style/align': _align.AlignStyle,
          'attributors/style/background': _background.BackgroundStyle,
          'attributors/style/color': _color.ColorStyle,
          'attributors/style/direction': _direction.DirectionStyle,
          'attributors/style/font': _font.FontStyle,
          'attributors/style/size': _size.SizeStyle
        }, true);

        _core2["default"].register({
          'formats/align': _align.AlignClass,
          'formats/direction': _direction.DirectionClass,
          'formats/indent': _indent.IndentClass,
          'formats/background': _background.BackgroundStyle,
          'formats/color': _color.ColorStyle,
          'formats/font': _font.FontClass,
          'formats/size': _size.SizeClass,
          'formats/blockquote': _blockquote2["default"],
          'formats/code-block': _code2["default"],
          'formats/header': _header2["default"],
          'formats/list': _list2["default"],
          'formats/bold': _bold2["default"],
          'formats/code': _code.Code,
          'formats/italic': _italic2["default"],
          'formats/link': _link2["default"],
          'formats/script': _script2["default"],
          'formats/strike': _strike2["default"],
          'formats/underline': _underline2["default"],
          'formats/image': _image2["default"],
          'formats/video': _video2["default"],
          'formats/list/item': _list.ListItem,
          'modules/formula': _formula2["default"],
          'modules/syntax': _syntax2["default"],
          'modules/toolbar': _toolbar2["default"],
          'themes/bubble': _bubble2["default"],
          'themes/snow': _snow2["default"],
          'ui/icons': _icons2["default"],
          'ui/picker': _picker2["default"],
          'ui/icon-picker': _iconPicker2["default"],
          'ui/color-picker': _colorPicker2["default"],
          'ui/tooltip': _tooltip2["default"]
        }, true);

        exports["default"] = _core2["default"];
        /***/
      },
      /* 64 */

      /***/
      function (module, exports, __webpack_require__) {

        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.IndentClass = undefined;

        var _createClass = function () {
          function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor) descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
          };
        }();

        var _get = function get(object, property, receiver) {
          if (object === null) object = Function.prototype;
          var desc = Object.getOwnPropertyDescriptor(object, property);

          if (desc === undefined) {
            var parent = Object.getPrototypeOf(object);

            if (parent === null) {
              return undefined;
            } else {
              return get(parent, property, receiver);
            }
          } else if ("value" in desc) {
            return desc.value;
          } else {
            var getter = desc.get;

            if (getter === undefined) {
              return undefined;
            }

            return getter.call(receiver);
          }
        };

        var _parchment = __webpack_require__(0);

        var _parchment2 = _interopRequireDefault(_parchment);

        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : {
            "default": obj
          };
        }

        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }

        function _possibleConstructorReturn(self, call) {
          if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }

          return call && (_typeof(call) === "object" || typeof call === "function") ? call : self;
        }

        function _inherits(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + _typeof(superClass));
          }

          subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
              value: subClass,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }

        var IdentAttributor = function (_Parchment$Attributor) {
          _inherits(IdentAttributor, _Parchment$Attributor);

          function IdentAttributor() {
            _classCallCheck(this, IdentAttributor);

            return _possibleConstructorReturn(this, (IdentAttributor.__proto__ || Object.getPrototypeOf(IdentAttributor)).apply(this, arguments));
          }

          _createClass(IdentAttributor, [{
            key: 'add',
            value: function add(node, value) {
              if (value === '+1' || value === '-1') {
                var indent = this.value(node) || 0;
                value = value === '+1' ? indent + 1 : indent - 1;
              }

              if (value === 0) {
                this.remove(node);
                return true;
              } else {
                return _get(IdentAttributor.prototype.__proto__ || Object.getPrototypeOf(IdentAttributor.prototype), 'add', this).call(this, node, value);
              }
            }
          }, {
            key: 'canAdd',
            value: function canAdd(node, value) {
              return _get(IdentAttributor.prototype.__proto__ || Object.getPrototypeOf(IdentAttributor.prototype), 'canAdd', this).call(this, node, value) || _get(IdentAttributor.prototype.__proto__ || Object.getPrototypeOf(IdentAttributor.prototype), 'canAdd', this).call(this, node, parseInt(value));
            }
          }, {
            key: 'value',
            value: function value(node) {
              return parseInt(_get(IdentAttributor.prototype.__proto__ || Object.getPrototypeOf(IdentAttributor.prototype), 'value', this).call(this, node)) || undefined; // Don't return NaN
            }
          }]);

          return IdentAttributor;
        }(_parchment2["default"].Attributor.Class);

        var IndentClass = new IdentAttributor('indent', 'ql-indent', {
          scope: _parchment2["default"].Scope.BLOCK,
          whitelist: [1, 2, 3, 4, 5, 6, 7, 8]
        });
        exports.IndentClass = IndentClass;
        /***/
      },
      /* 65 */

      /***/
      function (module, exports, __webpack_require__) {

        Object.defineProperty(exports, "__esModule", {
          value: true
        });

        var _block = __webpack_require__(4);

        var _block2 = _interopRequireDefault(_block);

        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : {
            "default": obj
          };
        }

        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }

        function _possibleConstructorReturn(self, call) {
          if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }

          return call && (_typeof(call) === "object" || typeof call === "function") ? call : self;
        }

        function _inherits(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + _typeof(superClass));
          }

          subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
              value: subClass,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }

        var Blockquote = function (_Block) {
          _inherits(Blockquote, _Block);

          function Blockquote() {
            _classCallCheck(this, Blockquote);

            return _possibleConstructorReturn(this, (Blockquote.__proto__ || Object.getPrototypeOf(Blockquote)).apply(this, arguments));
          }

          return Blockquote;
        }(_block2["default"]);

        Blockquote.blotName = 'blockquote';
        Blockquote.tagName = 'blockquote';
        exports["default"] = Blockquote;
        /***/
      },
      /* 66 */

      /***/
      function (module, exports, __webpack_require__) {

        Object.defineProperty(exports, "__esModule", {
          value: true
        });

        var _createClass = function () {
          function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor) descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
          };
        }();

        var _block = __webpack_require__(4);

        var _block2 = _interopRequireDefault(_block);

        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : {
            "default": obj
          };
        }

        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }

        function _possibleConstructorReturn(self, call) {
          if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }

          return call && (_typeof(call) === "object" || typeof call === "function") ? call : self;
        }

        function _inherits(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + _typeof(superClass));
          }

          subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
              value: subClass,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }

        var Header = function (_Block) {
          _inherits(Header, _Block);

          function Header() {
            _classCallCheck(this, Header);

            return _possibleConstructorReturn(this, (Header.__proto__ || Object.getPrototypeOf(Header)).apply(this, arguments));
          }

          _createClass(Header, null, [{
            key: 'formats',
            value: function formats(domNode) {
              return this.tagName.indexOf(domNode.tagName) + 1;
            }
          }]);

          return Header;
        }(_block2["default"]);

        Header.blotName = 'header';
        Header.tagName = ['H1', 'H2', 'H3', 'H4', 'H5', 'H6'];
        exports["default"] = Header;
        /***/
      },
      /* 67 */

      /***/
      function (module, exports, __webpack_require__) {

        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports["default"] = exports.ListItem = undefined;

        var _createClass = function () {
          function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor) descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
          };
        }();

        var _get = function get(object, property, receiver) {
          if (object === null) object = Function.prototype;
          var desc = Object.getOwnPropertyDescriptor(object, property);

          if (desc === undefined) {
            var parent = Object.getPrototypeOf(object);

            if (parent === null) {
              return undefined;
            } else {
              return get(parent, property, receiver);
            }
          } else if ("value" in desc) {
            return desc.value;
          } else {
            var getter = desc.get;

            if (getter === undefined) {
              return undefined;
            }

            return getter.call(receiver);
          }
        };

        var _parchment = __webpack_require__(0);

        var _parchment2 = _interopRequireDefault(_parchment);

        var _block = __webpack_require__(4);

        var _block2 = _interopRequireDefault(_block);

        var _container = __webpack_require__(25);

        var _container2 = _interopRequireDefault(_container);

        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : {
            "default": obj
          };
        }

        function _defineProperty(obj, key, value) {
          if (key in obj) {
            Object.defineProperty(obj, key, {
              value: value,
              enumerable: true,
              configurable: true,
              writable: true
            });
          } else {
            obj[key] = value;
          }

          return obj;
        }

        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }

        function _possibleConstructorReturn(self, call) {
          if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }

          return call && (_typeof(call) === "object" || typeof call === "function") ? call : self;
        }

        function _inherits(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + _typeof(superClass));
          }

          subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
              value: subClass,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }

        var ListItem = function (_Block) {
          _inherits(ListItem, _Block);

          function ListItem() {
            _classCallCheck(this, ListItem);

            return _possibleConstructorReturn(this, (ListItem.__proto__ || Object.getPrototypeOf(ListItem)).apply(this, arguments));
          }

          _createClass(ListItem, [{
            key: 'format',
            value: function format(name, value) {
              if (name === List.blotName && !value) {
                this.replaceWith(_parchment2["default"].create(this.statics.scope));
              } else {
                _get(ListItem.prototype.__proto__ || Object.getPrototypeOf(ListItem.prototype), 'format', this).call(this, name, value);
              }
            }
          }, {
            key: 'remove',
            value: function remove() {
              if (this.prev == null && this.next == null) {
                this.parent.remove();
              } else {
                _get(ListItem.prototype.__proto__ || Object.getPrototypeOf(ListItem.prototype), 'remove', this).call(this);
              }
            }
          }, {
            key: 'replaceWith',
            value: function replaceWith(name, value) {
              this.parent.isolate(this.offset(this.parent), this.length());

              if (name === this.parent.statics.blotName) {
                this.parent.replaceWith(name, value);
                return this;
              } else {
                this.parent.unwrap();
                return _get(ListItem.prototype.__proto__ || Object.getPrototypeOf(ListItem.prototype), 'replaceWith', this).call(this, name, value);
              }
            }
          }], [{
            key: 'formats',
            value: function formats(domNode) {
              return domNode.tagName === this.tagName ? undefined : _get(ListItem.__proto__ || Object.getPrototypeOf(ListItem), 'formats', this).call(this, domNode);
            }
          }]);

          return ListItem;
        }(_block2["default"]);

        ListItem.blotName = 'list-item';
        ListItem.tagName = 'LI';

        var List = function (_Container) {
          _inherits(List, _Container);

          _createClass(List, null, [{
            key: 'create',
            value: function create(value) {
              var tagName = value === 'ordered' ? 'OL' : 'UL';

              var node = _get(List.__proto__ || Object.getPrototypeOf(List), 'create', this).call(this, tagName);

              if (value === 'checked' || value === 'unchecked') {
                node.setAttribute('data-checked', value === 'checked');
              }

              return node;
            }
          }, {
            key: 'formats',
            value: function formats(domNode) {
              if (domNode.tagName === 'OL') return 'ordered';

              if (domNode.tagName === 'UL') {
                if (domNode.hasAttribute('data-checked')) {
                  return domNode.getAttribute('data-checked') === 'true' ? 'checked' : 'unchecked';
                } else {
                  return 'bullet';
                }
              }

              return undefined;
            }
          }]);

          function List(domNode) {
            _classCallCheck(this, List);

            var _this2 = _possibleConstructorReturn(this, (List.__proto__ || Object.getPrototypeOf(List)).call(this, domNode));

            var listEventHandler = function listEventHandler(e) {
              if (e.target.parentNode !== domNode) return;

              var format = _this2.statics.formats(domNode);

              var blot = _parchment2["default"].find(e.target);

              if (format === 'checked') {
                blot.format('list', 'unchecked');
              } else if (format === 'unchecked') {
                blot.format('list', 'checked');
              }
            };

            domNode.addEventListener('touchstart', listEventHandler);
            domNode.addEventListener('mousedown', listEventHandler);
            return _this2;
          }

          _createClass(List, [{
            key: 'format',
            value: function format(name, value) {
              if (this.children.length > 0) {
                this.children.tail.format(name, value);
              }
            }
          }, {
            key: 'formats',
            value: function formats() {
              // We don't inherit from FormatBlot
              return _defineProperty({}, this.statics.blotName, this.statics.formats(this.domNode));
            }
          }, {
            key: 'insertBefore',
            value: function insertBefore(blot, ref) {
              if (blot instanceof ListItem) {
                _get(List.prototype.__proto__ || Object.getPrototypeOf(List.prototype), 'insertBefore', this).call(this, blot, ref);
              } else {
                var index = ref == null ? this.length() : ref.offset(this);
                var after = this.split(index);
                after.parent.insertBefore(blot, after);
              }
            }
          }, {
            key: 'optimize',
            value: function optimize(context) {
              _get(List.prototype.__proto__ || Object.getPrototypeOf(List.prototype), 'optimize', this).call(this, context);

              var next = this.next;

              if (next != null && next.prev === this && next.statics.blotName === this.statics.blotName && next.domNode.tagName === this.domNode.tagName && next.domNode.getAttribute('data-checked') === this.domNode.getAttribute('data-checked')) {
                next.moveChildren(this);
                next.remove();
              }
            }
          }, {
            key: 'replace',
            value: function replace(target) {
              if (target.statics.blotName !== this.statics.blotName) {
                var item = _parchment2["default"].create(this.statics.defaultChild);

                target.moveChildren(item);
                this.appendChild(item);
              }

              _get(List.prototype.__proto__ || Object.getPrototypeOf(List.prototype), 'replace', this).call(this, target);
            }
          }]);

          return List;
        }(_container2["default"]);

        List.blotName = 'list';
        List.scope = _parchment2["default"].Scope.BLOCK_BLOT;
        List.tagName = ['OL', 'UL'];
        List.defaultChild = 'list-item';
        List.allowedChildren = [ListItem];
        exports.ListItem = ListItem;
        exports["default"] = List;
        /***/
      },
      /* 68 */

      /***/
      function (module, exports, __webpack_require__) {

        Object.defineProperty(exports, "__esModule", {
          value: true
        });

        var _bold = __webpack_require__(56);

        var _bold2 = _interopRequireDefault(_bold);

        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : {
            "default": obj
          };
        }

        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }

        function _possibleConstructorReturn(self, call) {
          if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }

          return call && (_typeof(call) === "object" || typeof call === "function") ? call : self;
        }

        function _inherits(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + _typeof(superClass));
          }

          subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
              value: subClass,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }

        var Italic = function (_Bold) {
          _inherits(Italic, _Bold);

          function Italic() {
            _classCallCheck(this, Italic);

            return _possibleConstructorReturn(this, (Italic.__proto__ || Object.getPrototypeOf(Italic)).apply(this, arguments));
          }

          return Italic;
        }(_bold2["default"]);

        Italic.blotName = 'italic';
        Italic.tagName = ['EM', 'I'];
        exports["default"] = Italic;
        /***/
      },
      /* 69 */

      /***/
      function (module, exports, __webpack_require__) {

        Object.defineProperty(exports, "__esModule", {
          value: true
        });

        var _createClass = function () {
          function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor) descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
          };
        }();

        var _get = function get(object, property, receiver) {
          if (object === null) object = Function.prototype;
          var desc = Object.getOwnPropertyDescriptor(object, property);

          if (desc === undefined) {
            var parent = Object.getPrototypeOf(object);

            if (parent === null) {
              return undefined;
            } else {
              return get(parent, property, receiver);
            }
          } else if ("value" in desc) {
            return desc.value;
          } else {
            var getter = desc.get;

            if (getter === undefined) {
              return undefined;
            }

            return getter.call(receiver);
          }
        };

        var _inline = __webpack_require__(6);

        var _inline2 = _interopRequireDefault(_inline);

        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : {
            "default": obj
          };
        }

        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }

        function _possibleConstructorReturn(self, call) {
          if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }

          return call && (_typeof(call) === "object" || typeof call === "function") ? call : self;
        }

        function _inherits(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + _typeof(superClass));
          }

          subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
              value: subClass,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }

        var Script = function (_Inline) {
          _inherits(Script, _Inline);

          function Script() {
            _classCallCheck(this, Script);

            return _possibleConstructorReturn(this, (Script.__proto__ || Object.getPrototypeOf(Script)).apply(this, arguments));
          }

          _createClass(Script, null, [{
            key: 'create',
            value: function create(value) {
              if (value === 'super') {
                return document.createElement('sup');
              } else if (value === 'sub') {
                return document.createElement('sub');
              } else {
                return _get(Script.__proto__ || Object.getPrototypeOf(Script), 'create', this).call(this, value);
              }
            }
          }, {
            key: 'formats',
            value: function formats(domNode) {
              if (domNode.tagName === 'SUB') return 'sub';
              if (domNode.tagName === 'SUP') return 'super';
              return undefined;
            }
          }]);

          return Script;
        }(_inline2["default"]);

        Script.blotName = 'script';
        Script.tagName = ['SUB', 'SUP'];
        exports["default"] = Script;
        /***/
      },
      /* 70 */

      /***/
      function (module, exports, __webpack_require__) {

        Object.defineProperty(exports, "__esModule", {
          value: true
        });

        var _inline = __webpack_require__(6);

        var _inline2 = _interopRequireDefault(_inline);

        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : {
            "default": obj
          };
        }

        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }

        function _possibleConstructorReturn(self, call) {
          if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }

          return call && (_typeof(call) === "object" || typeof call === "function") ? call : self;
        }

        function _inherits(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + _typeof(superClass));
          }

          subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
              value: subClass,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }

        var Strike = function (_Inline) {
          _inherits(Strike, _Inline);

          function Strike() {
            _classCallCheck(this, Strike);

            return _possibleConstructorReturn(this, (Strike.__proto__ || Object.getPrototypeOf(Strike)).apply(this, arguments));
          }

          return Strike;
        }(_inline2["default"]);

        Strike.blotName = 'strike';
        Strike.tagName = 'S';
        exports["default"] = Strike;
        /***/
      },
      /* 71 */

      /***/
      function (module, exports, __webpack_require__) {

        Object.defineProperty(exports, "__esModule", {
          value: true
        });

        var _inline = __webpack_require__(6);

        var _inline2 = _interopRequireDefault(_inline);

        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : {
            "default": obj
          };
        }

        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }

        function _possibleConstructorReturn(self, call) {
          if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }

          return call && (_typeof(call) === "object" || typeof call === "function") ? call : self;
        }

        function _inherits(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + _typeof(superClass));
          }

          subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
              value: subClass,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }

        var Underline = function (_Inline) {
          _inherits(Underline, _Inline);

          function Underline() {
            _classCallCheck(this, Underline);

            return _possibleConstructorReturn(this, (Underline.__proto__ || Object.getPrototypeOf(Underline)).apply(this, arguments));
          }

          return Underline;
        }(_inline2["default"]);

        Underline.blotName = 'underline';
        Underline.tagName = 'U';
        exports["default"] = Underline;
        /***/
      },
      /* 72 */

      /***/
      function (module, exports, __webpack_require__) {

        Object.defineProperty(exports, "__esModule", {
          value: true
        });

        var _createClass = function () {
          function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor) descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
          };
        }();

        var _get = function get(object, property, receiver) {
          if (object === null) object = Function.prototype;
          var desc = Object.getOwnPropertyDescriptor(object, property);

          if (desc === undefined) {
            var parent = Object.getPrototypeOf(object);

            if (parent === null) {
              return undefined;
            } else {
              return get(parent, property, receiver);
            }
          } else if ("value" in desc) {
            return desc.value;
          } else {
            var getter = desc.get;

            if (getter === undefined) {
              return undefined;
            }

            return getter.call(receiver);
          }
        };

        var _parchment = __webpack_require__(0);

        var _parchment2 = _interopRequireDefault(_parchment);

        var _link = __webpack_require__(27);

        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : {
            "default": obj
          };
        }

        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }

        function _possibleConstructorReturn(self, call) {
          if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }

          return call && (_typeof(call) === "object" || typeof call === "function") ? call : self;
        }

        function _inherits(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + _typeof(superClass));
          }

          subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
              value: subClass,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }

        var ATTRIBUTES = ['alt', 'height', 'width'];

        var Image = function (_Parchment$Embed) {
          _inherits(Image, _Parchment$Embed);

          function Image() {
            _classCallCheck(this, Image);

            return _possibleConstructorReturn(this, (Image.__proto__ || Object.getPrototypeOf(Image)).apply(this, arguments));
          }

          _createClass(Image, [{
            key: 'format',
            value: function format(name, value) {
              if (ATTRIBUTES.indexOf(name) > -1) {
                if (value) {
                  this.domNode.setAttribute(name, value);
                } else {
                  this.domNode.removeAttribute(name);
                }
              } else {
                _get(Image.prototype.__proto__ || Object.getPrototypeOf(Image.prototype), 'format', this).call(this, name, value);
              }
            }
          }], [{
            key: 'create',
            value: function create(value) {
              var node = _get(Image.__proto__ || Object.getPrototypeOf(Image), 'create', this).call(this, value);

              if (typeof value === 'string') {
                node.setAttribute('src', this.sanitize(value));
              }

              return node;
            }
          }, {
            key: 'formats',
            value: function formats(domNode) {
              return ATTRIBUTES.reduce(function (formats, attribute) {
                if (domNode.hasAttribute(attribute)) {
                  formats[attribute] = domNode.getAttribute(attribute);
                }

                return formats;
              }, {});
            }
          }, {
            key: 'match',
            value: function match(url) {
              return /\.(jpe?g|gif|png)$/.test(url) || /^data:image\/.+;base64/.test(url);
            }
          }, {
            key: 'sanitize',
            value: function sanitize(url) {
              return (0, _link.sanitize)(url, ['http', 'https', 'data']) ? url : '//:0';
            }
          }, {
            key: 'value',
            value: function value(domNode) {
              return domNode.getAttribute('src');
            }
          }]);

          return Image;
        }(_parchment2["default"].Embed);

        Image.blotName = 'image';
        Image.tagName = 'IMG';
        exports["default"] = Image;
        /***/
      },
      /* 73 */

      /***/
      function (module, exports, __webpack_require__) {

        Object.defineProperty(exports, "__esModule", {
          value: true
        });

        var _createClass = function () {
          function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor) descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
          };
        }();

        var _get = function get(object, property, receiver) {
          if (object === null) object = Function.prototype;
          var desc = Object.getOwnPropertyDescriptor(object, property);

          if (desc === undefined) {
            var parent = Object.getPrototypeOf(object);

            if (parent === null) {
              return undefined;
            } else {
              return get(parent, property, receiver);
            }
          } else if ("value" in desc) {
            return desc.value;
          } else {
            var getter = desc.get;

            if (getter === undefined) {
              return undefined;
            }

            return getter.call(receiver);
          }
        };

        var _block = __webpack_require__(4);

        var _link = __webpack_require__(27);

        var _link2 = _interopRequireDefault(_link);

        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : {
            "default": obj
          };
        }

        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }

        function _possibleConstructorReturn(self, call) {
          if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }

          return call && (_typeof(call) === "object" || typeof call === "function") ? call : self;
        }

        function _inherits(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + _typeof(superClass));
          }

          subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
              value: subClass,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }

        var ATTRIBUTES = ['height', 'width'];

        var Video = function (_BlockEmbed) {
          _inherits(Video, _BlockEmbed);

          function Video() {
            _classCallCheck(this, Video);

            return _possibleConstructorReturn(this, (Video.__proto__ || Object.getPrototypeOf(Video)).apply(this, arguments));
          }

          _createClass(Video, [{
            key: 'format',
            value: function format(name, value) {
              if (ATTRIBUTES.indexOf(name) > -1) {
                if (value) {
                  this.domNode.setAttribute(name, value);
                } else {
                  this.domNode.removeAttribute(name);
                }
              } else {
                _get(Video.prototype.__proto__ || Object.getPrototypeOf(Video.prototype), 'format', this).call(this, name, value);
              }
            }
          }], [{
            key: 'create',
            value: function create(value) {
              var node = _get(Video.__proto__ || Object.getPrototypeOf(Video), 'create', this).call(this, value);

              node.setAttribute('frameborder', '0');
              node.setAttribute('allowfullscreen', true);
              node.setAttribute('src', this.sanitize(value));
              return node;
            }
          }, {
            key: 'formats',
            value: function formats(domNode) {
              return ATTRIBUTES.reduce(function (formats, attribute) {
                if (domNode.hasAttribute(attribute)) {
                  formats[attribute] = domNode.getAttribute(attribute);
                }

                return formats;
              }, {});
            }
          }, {
            key: 'sanitize',
            value: function sanitize(url) {
              return _link2["default"].sanitize(url);
            }
          }, {
            key: 'value',
            value: function value(domNode) {
              return domNode.getAttribute('src');
            }
          }]);

          return Video;
        }(_block.BlockEmbed);

        Video.blotName = 'video';
        Video.className = 'ql-video';
        Video.tagName = 'IFRAME';
        exports["default"] = Video;
        /***/
      },
      /* 74 */

      /***/
      function (module, exports, __webpack_require__) {

        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports["default"] = exports.FormulaBlot = undefined;

        var _createClass = function () {
          function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor) descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
          };
        }();

        var _get = function get(object, property, receiver) {
          if (object === null) object = Function.prototype;
          var desc = Object.getOwnPropertyDescriptor(object, property);

          if (desc === undefined) {
            var parent = Object.getPrototypeOf(object);

            if (parent === null) {
              return undefined;
            } else {
              return get(parent, property, receiver);
            }
          } else if ("value" in desc) {
            return desc.value;
          } else {
            var getter = desc.get;

            if (getter === undefined) {
              return undefined;
            }

            return getter.call(receiver);
          }
        };

        var _embed = __webpack_require__(35);

        var _embed2 = _interopRequireDefault(_embed);

        var _quill = __webpack_require__(5);

        var _quill2 = _interopRequireDefault(_quill);

        var _module = __webpack_require__(9);

        var _module2 = _interopRequireDefault(_module);

        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : {
            "default": obj
          };
        }

        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }

        function _possibleConstructorReturn(self, call) {
          if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }

          return call && (_typeof(call) === "object" || typeof call === "function") ? call : self;
        }

        function _inherits(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + _typeof(superClass));
          }

          subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
              value: subClass,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }

        var FormulaBlot = function (_Embed) {
          _inherits(FormulaBlot, _Embed);

          function FormulaBlot() {
            _classCallCheck(this, FormulaBlot);

            return _possibleConstructorReturn(this, (FormulaBlot.__proto__ || Object.getPrototypeOf(FormulaBlot)).apply(this, arguments));
          }

          _createClass(FormulaBlot, null, [{
            key: 'create',
            value: function create(value) {
              var node = _get(FormulaBlot.__proto__ || Object.getPrototypeOf(FormulaBlot), 'create', this).call(this, value);

              if (typeof value === 'string') {
                window.katex.render(value, node, {
                  throwOnError: false,
                  errorColor: '#f00'
                });
                node.setAttribute('data-value', value);
              }

              return node;
            }
          }, {
            key: 'value',
            value: function value(domNode) {
              return domNode.getAttribute('data-value');
            }
          }]);

          return FormulaBlot;
        }(_embed2["default"]);

        FormulaBlot.blotName = 'formula';
        FormulaBlot.className = 'ql-formula';
        FormulaBlot.tagName = 'SPAN';

        var Formula = function (_Module) {
          _inherits(Formula, _Module);

          _createClass(Formula, null, [{
            key: 'register',
            value: function register() {
              _quill2["default"].register(FormulaBlot, true);
            }
          }]);

          function Formula() {
            _classCallCheck(this, Formula);

            var _this2 = _possibleConstructorReturn(this, (Formula.__proto__ || Object.getPrototypeOf(Formula)).call(this));

            if (window.katex == null) {
              throw new Error('Formula module requires KaTeX.');
            }

            return _this2;
          }

          return Formula;
        }(_module2["default"]);

        exports.FormulaBlot = FormulaBlot;
        exports["default"] = Formula;
        /***/
      },
      /* 75 */

      /***/
      function (module, exports, __webpack_require__) {

        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports["default"] = exports.CodeToken = exports.CodeBlock = undefined;

        var _createClass = function () {
          function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor) descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
          };
        }();

        var _get = function get(object, property, receiver) {
          if (object === null) object = Function.prototype;
          var desc = Object.getOwnPropertyDescriptor(object, property);

          if (desc === undefined) {
            var parent = Object.getPrototypeOf(object);

            if (parent === null) {
              return undefined;
            } else {
              return get(parent, property, receiver);
            }
          } else if ("value" in desc) {
            return desc.value;
          } else {
            var getter = desc.get;

            if (getter === undefined) {
              return undefined;
            }

            return getter.call(receiver);
          }
        };

        var _parchment = __webpack_require__(0);

        var _parchment2 = _interopRequireDefault(_parchment);

        var _quill = __webpack_require__(5);

        var _quill2 = _interopRequireDefault(_quill);

        var _module = __webpack_require__(9);

        var _module2 = _interopRequireDefault(_module);

        var _code = __webpack_require__(13);

        var _code2 = _interopRequireDefault(_code);

        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : {
            "default": obj
          };
        }

        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }

        function _possibleConstructorReturn(self, call) {
          if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }

          return call && (_typeof(call) === "object" || typeof call === "function") ? call : self;
        }

        function _inherits(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + _typeof(superClass));
          }

          subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
              value: subClass,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }

        var SyntaxCodeBlock = function (_CodeBlock) {
          _inherits(SyntaxCodeBlock, _CodeBlock);

          function SyntaxCodeBlock() {
            _classCallCheck(this, SyntaxCodeBlock);

            return _possibleConstructorReturn(this, (SyntaxCodeBlock.__proto__ || Object.getPrototypeOf(SyntaxCodeBlock)).apply(this, arguments));
          }

          _createClass(SyntaxCodeBlock, [{
            key: 'replaceWith',
            value: function replaceWith(block) {
              this.domNode.textContent = this.domNode.textContent;
              this.attach();

              _get(SyntaxCodeBlock.prototype.__proto__ || Object.getPrototypeOf(SyntaxCodeBlock.prototype), 'replaceWith', this).call(this, block);
            }
          }, {
            key: 'highlight',
            value: function highlight(_highlight) {
              var text = this.domNode.textContent;

              if (this.cachedText !== text) {
                if (text.trim().length > 0 || this.cachedText == null) {
                  this.domNode.innerHTML = _highlight(text);
                  this.domNode.normalize();
                  this.attach();
                }

                this.cachedText = text;
              }
            }
          }]);

          return SyntaxCodeBlock;
        }(_code2["default"]);

        SyntaxCodeBlock.className = 'ql-syntax';
        var CodeToken = new _parchment2["default"].Attributor.Class('token', 'hljs', {
          scope: _parchment2["default"].Scope.INLINE
        });

        var Syntax = function (_Module) {
          _inherits(Syntax, _Module);

          _createClass(Syntax, null, [{
            key: 'register',
            value: function register() {
              _quill2["default"].register(CodeToken, true);

              _quill2["default"].register(SyntaxCodeBlock, true);
            }
          }]);

          function Syntax(quill, options) {
            _classCallCheck(this, Syntax);

            var _this2 = _possibleConstructorReturn(this, (Syntax.__proto__ || Object.getPrototypeOf(Syntax)).call(this, quill, options));

            if (typeof _this2.options.highlight !== 'function') {
              throw new Error('Syntax module requires highlight.js. Please include the library on the page before Quill.');
            }

            var timer = null;

            _this2.quill.on(_quill2["default"].events.SCROLL_OPTIMIZE, function () {
              clearTimeout(timer);
              timer = setTimeout(function () {
                _this2.highlight();

                timer = null;
              }, _this2.options.interval);
            });

            _this2.highlight();

            return _this2;
          }

          _createClass(Syntax, [{
            key: 'highlight',
            value: function highlight() {
              var _this3 = this;

              if (this.quill.selection.composing) return;
              this.quill.update(_quill2["default"].sources.USER);
              var range = this.quill.getSelection();
              this.quill.scroll.descendants(SyntaxCodeBlock).forEach(function (code) {
                code.highlight(_this3.options.highlight);
              });
              this.quill.update(_quill2["default"].sources.SILENT);

              if (range != null) {
                this.quill.setSelection(range, _quill2["default"].sources.SILENT);
              }
            }
          }]);

          return Syntax;
        }(_module2["default"]);

        Syntax.DEFAULTS = {
          highlight: function () {
            if (window.hljs == null) return null;
            return function (text) {
              var result = window.hljs.highlightAuto(text);
              return result.value;
            };
          }(),
          interval: 1000
        };
        exports.CodeBlock = SyntaxCodeBlock;
        exports.CodeToken = CodeToken;
        exports["default"] = Syntax;
        /***/
      },
      /* 76 */

      /***/
      function (module, exports) {
        module.exports = "<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=3 x2=15 y1=9 y2=9></line> <line class=ql-stroke x1=3 x2=13 y1=14 y2=14></line> <line class=ql-stroke x1=3 x2=9 y1=4 y2=4></line> </svg>";
        /***/
      },
      /* 77 */

      /***/
      function (module, exports) {
        module.exports = "<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=15 x2=3 y1=9 y2=9></line> <line class=ql-stroke x1=14 x2=4 y1=14 y2=14></line> <line class=ql-stroke x1=12 x2=6 y1=4 y2=4></line> </svg>";
        /***/
      },
      /* 78 */

      /***/
      function (module, exports) {
        module.exports = "<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=15 x2=3 y1=9 y2=9></line> <line class=ql-stroke x1=15 x2=5 y1=14 y2=14></line> <line class=ql-stroke x1=15 x2=9 y1=4 y2=4></line> </svg>";
        /***/
      },
      /* 79 */

      /***/
      function (module, exports) {
        module.exports = "<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=15 x2=3 y1=9 y2=9></line> <line class=ql-stroke x1=15 x2=3 y1=14 y2=14></line> <line class=ql-stroke x1=15 x2=3 y1=4 y2=4></line> </svg>";
        /***/
      },
      /* 80 */

      /***/
      function (module, exports) {
        module.exports = "<svg viewbox=\"0 0 18 18\"> <g class=\"ql-fill ql-color-label\"> <polygon points=\"6 6.868 6 6 5 6 5 7 5.942 7 6 6.868\"></polygon> <rect height=1 width=1 x=4 y=4></rect> <polygon points=\"6.817 5 6 5 6 6 6.38 6 6.817 5\"></polygon> <rect height=1 width=1 x=2 y=6></rect> <rect height=1 width=1 x=3 y=5></rect> <rect height=1 width=1 x=4 y=7></rect> <polygon points=\"4 11.439 4 11 3 11 3 12 3.755 12 4 11.439\"></polygon> <rect height=1 width=1 x=2 y=12></rect> <rect height=1 width=1 x=2 y=9></rect> <rect height=1 width=1 x=2 y=15></rect> <polygon points=\"4.63 10 4 10 4 11 4.192 11 4.63 10\"></polygon> <rect height=1 width=1 x=3 y=8></rect> <path d=M10.832,4.2L11,4.582V4H10.708A1.948,1.948,0,0,1,10.832,4.2Z></path> <path d=M7,4.582L7.168,4.2A1.929,1.929,0,0,1,7.292,4H7V4.582Z></path> <path d=M8,13H7.683l-0.351.8a1.933,1.933,0,0,1-.124.2H8V13Z></path> <rect height=1 width=1 x=12 y=2></rect> <rect height=1 width=1 x=11 y=3></rect> <path d=M9,3H8V3.282A1.985,1.985,0,0,1,9,3Z></path> <rect height=1 width=1 x=2 y=3></rect> <rect height=1 width=1 x=6 y=2></rect> <rect height=1 width=1 x=3 y=2></rect> <rect height=1 width=1 x=5 y=3></rect> <rect height=1 width=1 x=9 y=2></rect> <rect height=1 width=1 x=15 y=14></rect> <polygon points=\"13.447 10.174 13.469 10.225 13.472 10.232 13.808 11 14 11 14 10 13.37 10 13.447 10.174\"></polygon> <rect height=1 width=1 x=13 y=7></rect> <rect height=1 width=1 x=15 y=5></rect> <rect height=1 width=1 x=14 y=6></rect> <rect height=1 width=1 x=15 y=8></rect> <rect height=1 width=1 x=14 y=9></rect> <path d=M3.775,14H3v1H4V14.314A1.97,1.97,0,0,1,3.775,14Z></path> <rect height=1 width=1 x=14 y=3></rect> <polygon points=\"12 6.868 12 6 11.62 6 12 6.868\"></polygon> <rect height=1 width=1 x=15 y=2></rect> <rect height=1 width=1 x=12 y=5></rect> <rect height=1 width=1 x=13 y=4></rect> <polygon points=\"12.933 9 13 9 13 8 12.495 8 12.933 9\"></polygon> <rect height=1 width=1 x=9 y=14></rect> <rect height=1 width=1 x=8 y=15></rect> <path d=M6,14.926V15H7V14.316A1.993,1.993,0,0,1,6,14.926Z></path> <rect height=1 width=1 x=5 y=15></rect> <path d=M10.668,13.8L10.317,13H10v1h0.792A1.947,1.947,0,0,1,10.668,13.8Z></path> <rect height=1 width=1 x=11 y=15></rect> <path d=M14.332,12.2a1.99,1.99,0,0,1,.166.8H15V12H14.245Z></path> <rect height=1 width=1 x=14 y=15></rect> <rect height=1 width=1 x=15 y=11></rect> </g> <polyline class=ql-stroke points=\"5.5 13 9 5 12.5 13\"></polyline> <line class=ql-stroke x1=11.63 x2=6.38 y1=11 y2=11></line> </svg>";
        /***/
      },
      /* 81 */

      /***/
      function (module, exports) {
        module.exports = "<svg viewbox=\"0 0 18 18\"> <rect class=\"ql-fill ql-stroke\" height=3 width=3 x=4 y=5></rect> <rect class=\"ql-fill ql-stroke\" height=3 width=3 x=11 y=5></rect> <path class=\"ql-even ql-fill ql-stroke\" d=M7,8c0,4.031-3,5-3,5></path> <path class=\"ql-even ql-fill ql-stroke\" d=M14,8c0,4.031-3,5-3,5></path> </svg>";
        /***/
      },
      /* 82 */

      /***/
      function (module, exports) {
        module.exports = "<svg viewbox=\"0 0 18 18\"> <path class=ql-stroke d=M5,4H9.5A2.5,2.5,0,0,1,12,6.5v0A2.5,2.5,0,0,1,9.5,9H5A0,0,0,0,1,5,9V4A0,0,0,0,1,5,4Z></path> <path class=ql-stroke d=M5,9h5.5A2.5,2.5,0,0,1,13,11.5v0A2.5,2.5,0,0,1,10.5,14H5a0,0,0,0,1,0,0V9A0,0,0,0,1,5,9Z></path> </svg>";
        /***/
      },
      /* 83 */

      /***/
      function (module, exports) {
        module.exports = "<svg class=\"\" viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=5 x2=13 y1=3 y2=3></line> <line class=ql-stroke x1=6 x2=9.35 y1=12 y2=3></line> <line class=ql-stroke x1=11 x2=15 y1=11 y2=15></line> <line class=ql-stroke x1=15 x2=11 y1=11 y2=15></line> <rect class=ql-fill height=1 rx=0.5 ry=0.5 width=7 x=2 y=14></rect> </svg>";
        /***/
      },
      /* 84 */

      /***/
      function (module, exports) {
        module.exports = "<svg viewbox=\"0 0 18 18\"> <line class=\"ql-color-label ql-stroke ql-transparent\" x1=3 x2=15 y1=15 y2=15></line> <polyline class=ql-stroke points=\"5.5 11 9 3 12.5 11\"></polyline> <line class=ql-stroke x1=11.63 x2=6.38 y1=9 y2=9></line> </svg>";
        /***/
      },
      /* 85 */

      /***/
      function (module, exports) {
        module.exports = "<svg viewbox=\"0 0 18 18\"> <polygon class=\"ql-stroke ql-fill\" points=\"3 11 5 9 3 7 3 11\"></polygon> <line class=\"ql-stroke ql-fill\" x1=15 x2=11 y1=4 y2=4></line> <path class=ql-fill d=M11,3a3,3,0,0,0,0,6h1V3H11Z></path> <rect class=ql-fill height=11 width=1 x=11 y=4></rect> <rect class=ql-fill height=11 width=1 x=13 y=4></rect> </svg>";
        /***/
      },
      /* 86 */

      /***/
      function (module, exports) {
        module.exports = "<svg viewbox=\"0 0 18 18\"> <polygon class=\"ql-stroke ql-fill\" points=\"15 12 13 10 15 8 15 12\"></polygon> <line class=\"ql-stroke ql-fill\" x1=9 x2=5 y1=4 y2=4></line> <path class=ql-fill d=M5,3A3,3,0,0,0,5,9H6V3H5Z></path> <rect class=ql-fill height=11 width=1 x=5 y=4></rect> <rect class=ql-fill height=11 width=1 x=7 y=4></rect> </svg>";
        /***/
      },
      /* 87 */

      /***/
      function (module, exports) {
        module.exports = "<svg viewbox=\"0 0 18 18\"> <path class=ql-fill d=M14,16H4a1,1,0,0,1,0-2H14A1,1,0,0,1,14,16Z /> <path class=ql-fill d=M14,4H4A1,1,0,0,1,4,2H14A1,1,0,0,1,14,4Z /> <rect class=ql-fill x=3 y=6 width=12 height=6 rx=1 ry=1 /> </svg>";
        /***/
      },
      /* 88 */

      /***/
      function (module, exports) {
        module.exports = "<svg viewbox=\"0 0 18 18\"> <path class=ql-fill d=M13,16H5a1,1,0,0,1,0-2h8A1,1,0,0,1,13,16Z /> <path class=ql-fill d=M13,4H5A1,1,0,0,1,5,2h8A1,1,0,0,1,13,4Z /> <rect class=ql-fill x=2 y=6 width=14 height=6 rx=1 ry=1 /> </svg>";
        /***/
      },
      /* 89 */

      /***/
      function (module, exports) {
        module.exports = "<svg viewbox=\"0 0 18 18\"> <path class=ql-fill d=M15,8H13a1,1,0,0,1,0-2h2A1,1,0,0,1,15,8Z /> <path class=ql-fill d=M15,12H13a1,1,0,0,1,0-2h2A1,1,0,0,1,15,12Z /> <path class=ql-fill d=M15,16H5a1,1,0,0,1,0-2H15A1,1,0,0,1,15,16Z /> <path class=ql-fill d=M15,4H5A1,1,0,0,1,5,2H15A1,1,0,0,1,15,4Z /> <rect class=ql-fill x=2 y=6 width=8 height=6 rx=1 ry=1 /> </svg>";
        /***/
      },
      /* 90 */

      /***/
      function (module, exports) {
        module.exports = "<svg viewbox=\"0 0 18 18\"> <path class=ql-fill d=M5,8H3A1,1,0,0,1,3,6H5A1,1,0,0,1,5,8Z /> <path class=ql-fill d=M5,12H3a1,1,0,0,1,0-2H5A1,1,0,0,1,5,12Z /> <path class=ql-fill d=M13,16H3a1,1,0,0,1,0-2H13A1,1,0,0,1,13,16Z /> <path class=ql-fill d=M13,4H3A1,1,0,0,1,3,2H13A1,1,0,0,1,13,4Z /> <rect class=ql-fill x=8 y=6 width=8 height=6 rx=1 ry=1 transform=\"translate(24 18) rotate(-180)\"/> </svg>";
        /***/
      },
      /* 91 */

      /***/
      function (module, exports) {
        module.exports = "<svg viewbox=\"0 0 18 18\"> <path class=ql-fill d=M11.759,2.482a2.561,2.561,0,0,0-3.53.607A7.656,7.656,0,0,0,6.8,6.2C6.109,9.188,5.275,14.677,4.15,14.927a1.545,1.545,0,0,0-1.3-.933A0.922,0.922,0,0,0,2,15.036S1.954,16,4.119,16s3.091-2.691,3.7-5.553c0.177-.826.36-1.726,0.554-2.6L8.775,6.2c0.381-1.421.807-2.521,1.306-2.676a1.014,1.014,0,0,0,1.02.56A0.966,0.966,0,0,0,11.759,2.482Z></path> <rect class=ql-fill height=1.6 rx=0.8 ry=0.8 width=5 x=5.15 y=6.2></rect> <path class=ql-fill d=M13.663,12.027a1.662,1.662,0,0,1,.266-0.276q0.193,0.069.456,0.138a2.1,2.1,0,0,0,.535.069,1.075,1.075,0,0,0,.767-0.3,1.044,1.044,0,0,0,.314-0.8,0.84,0.84,0,0,0-.238-0.619,0.8,0.8,0,0,0-.594-0.239,1.154,1.154,0,0,0-.781.3,4.607,4.607,0,0,0-.781,1q-0.091.15-.218,0.346l-0.246.38c-0.068-.288-0.137-0.582-0.212-0.885-0.459-1.847-2.494-.984-2.941-0.8-0.482.2-.353,0.647-0.094,0.529a0.869,0.869,0,0,1,1.281.585c0.217,0.751.377,1.436,0.527,2.038a5.688,5.688,0,0,1-.362.467,2.69,2.69,0,0,1-.264.271q-0.221-.08-0.471-0.147a2.029,2.029,0,0,0-.522-0.066,1.079,1.079,0,0,0-.768.3A1.058,1.058,0,0,0,9,15.131a0.82,0.82,0,0,0,.832.852,1.134,1.134,0,0,0,.787-0.3,5.11,5.11,0,0,0,.776-0.993q0.141-.219.215-0.34c0.046-.076.122-0.194,0.223-0.346a2.786,2.786,0,0,0,.918,1.726,2.582,2.582,0,0,0,2.376-.185c0.317-.181.212-0.565,0-0.494A0.807,0.807,0,0,1,14.176,15a5.159,5.159,0,0,1-.913-2.446l0,0Q13.487,12.24,13.663,12.027Z></path> </svg>";
        /***/
      },
      /* 92 */

      /***/
      function (module, exports) {
        module.exports = "<svg viewBox=\"0 0 18 18\"> <path class=ql-fill d=M10,4V14a1,1,0,0,1-2,0V10H3v4a1,1,0,0,1-2,0V4A1,1,0,0,1,3,4V8H8V4a1,1,0,0,1,2,0Zm6.06787,9.209H14.98975V7.59863a.54085.54085,0,0,0-.605-.60547h-.62744a1.01119,1.01119,0,0,0-.748.29688L11.645,8.56641a.5435.5435,0,0,0-.022.8584l.28613.30762a.53861.53861,0,0,0,.84717.0332l.09912-.08789a1.2137,1.2137,0,0,0,.2417-.35254h.02246s-.01123.30859-.01123.60547V13.209H12.041a.54085.54085,0,0,0-.605.60547v.43945a.54085.54085,0,0,0,.605.60547h4.02686a.54085.54085,0,0,0,.605-.60547v-.43945A.54085.54085,0,0,0,16.06787,13.209Z /> </svg>";
        /***/
      },
      /* 93 */

      /***/
      function (module, exports) {
        module.exports = "<svg viewBox=\"0 0 18 18\"> <path class=ql-fill d=M16.73975,13.81445v.43945a.54085.54085,0,0,1-.605.60547H11.855a.58392.58392,0,0,1-.64893-.60547V14.0127c0-2.90527,3.39941-3.42187,3.39941-4.55469a.77675.77675,0,0,0-.84717-.78125,1.17684,1.17684,0,0,0-.83594.38477c-.2749.26367-.561.374-.85791.13184l-.4292-.34082c-.30811-.24219-.38525-.51758-.1543-.81445a2.97155,2.97155,0,0,1,2.45361-1.17676,2.45393,2.45393,0,0,1,2.68408,2.40918c0,2.45312-3.1792,2.92676-3.27832,3.93848h2.79443A.54085.54085,0,0,1,16.73975,13.81445ZM9,3A.99974.99974,0,0,0,8,4V8H3V4A1,1,0,0,0,1,4V14a1,1,0,0,0,2,0V10H8v4a1,1,0,0,0,2,0V4A.99974.99974,0,0,0,9,3Z /> </svg>";
        /***/
      },
      /* 94 */

      /***/
      function (module, exports) {
        module.exports = "<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=7 x2=13 y1=4 y2=4></line> <line class=ql-stroke x1=5 x2=11 y1=14 y2=14></line> <line class=ql-stroke x1=8 x2=10 y1=14 y2=4></line> </svg>";
        /***/
      },
      /* 95 */

      /***/
      function (module, exports) {
        module.exports = "<svg viewbox=\"0 0 18 18\"> <rect class=ql-stroke height=10 width=12 x=3 y=4></rect> <circle class=ql-fill cx=6 cy=7 r=1></circle> <polyline class=\"ql-even ql-fill\" points=\"5 12 5 11 7 9 8 10 11 7 13 9 13 12 5 12\"></polyline> </svg>";
        /***/
      },
      /* 96 */

      /***/
      function (module, exports) {
        module.exports = "<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=3 x2=15 y1=14 y2=14></line> <line class=ql-stroke x1=3 x2=15 y1=4 y2=4></line> <line class=ql-stroke x1=9 x2=15 y1=9 y2=9></line> <polyline class=\"ql-fill ql-stroke\" points=\"3 7 3 11 5 9 3 7\"></polyline> </svg>";
        /***/
      },
      /* 97 */

      /***/
      function (module, exports) {
        module.exports = "<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=3 x2=15 y1=14 y2=14></line> <line class=ql-stroke x1=3 x2=15 y1=4 y2=4></line> <line class=ql-stroke x1=9 x2=15 y1=9 y2=9></line> <polyline class=ql-stroke points=\"5 7 5 11 3 9 5 7\"></polyline> </svg>";
        /***/
      },
      /* 98 */

      /***/
      function (module, exports) {
        module.exports = "<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=7 x2=11 y1=7 y2=11></line> <path class=\"ql-even ql-stroke\" d=M8.9,4.577a3.476,3.476,0,0,1,.36,4.679A3.476,3.476,0,0,1,4.577,8.9C3.185,7.5,2.035,6.4,4.217,4.217S7.5,3.185,8.9,4.577Z></path> <path class=\"ql-even ql-stroke\" d=M13.423,9.1a3.476,3.476,0,0,0-4.679-.36,3.476,3.476,0,0,0,.36,4.679c1.392,1.392,2.5,2.542,4.679.36S14.815,10.5,13.423,9.1Z></path> </svg>";
        /***/
      },
      /* 99 */

      /***/
      function (module, exports) {
        module.exports = "<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=7 x2=15 y1=4 y2=4></line> <line class=ql-stroke x1=7 x2=15 y1=9 y2=9></line> <line class=ql-stroke x1=7 x2=15 y1=14 y2=14></line> <line class=\"ql-stroke ql-thin\" x1=2.5 x2=4.5 y1=5.5 y2=5.5></line> <path class=ql-fill d=M3.5,6A0.5,0.5,0,0,1,3,5.5V3.085l-0.276.138A0.5,0.5,0,0,1,2.053,3c-0.124-.247-0.023-0.324.224-0.447l1-.5A0.5,0.5,0,0,1,4,2.5v3A0.5,0.5,0,0,1,3.5,6Z></path> <path class=\"ql-stroke ql-thin\" d=M4.5,10.5h-2c0-.234,1.85-1.076,1.85-2.234A0.959,0.959,0,0,0,2.5,8.156></path> <path class=\"ql-stroke ql-thin\" d=M2.5,14.846a0.959,0.959,0,0,0,1.85-.109A0.7,0.7,0,0,0,3.75,14a0.688,0.688,0,0,0,.6-0.736,0.959,0.959,0,0,0-1.85-.109></path> </svg>";
        /***/
      },
      /* 100 */

      /***/
      function (module, exports) {
        module.exports = "<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=6 x2=15 y1=4 y2=4></line> <line class=ql-stroke x1=6 x2=15 y1=9 y2=9></line> <line class=ql-stroke x1=6 x2=15 y1=14 y2=14></line> <line class=ql-stroke x1=3 x2=3 y1=4 y2=4></line> <line class=ql-stroke x1=3 x2=3 y1=9 y2=9></line> <line class=ql-stroke x1=3 x2=3 y1=14 y2=14></line> </svg>";
        /***/
      },
      /* 101 */

      /***/
      function (module, exports) {
        module.exports = "<svg class=\"\" viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=9 x2=15 y1=4 y2=4></line> <polyline class=ql-stroke points=\"3 4 4 5 6 3\"></polyline> <line class=ql-stroke x1=9 x2=15 y1=14 y2=14></line> <polyline class=ql-stroke points=\"3 14 4 15 6 13\"></polyline> <line class=ql-stroke x1=9 x2=15 y1=9 y2=9></line> <polyline class=ql-stroke points=\"3 9 4 10 6 8\"></polyline> </svg>";
        /***/
      },
      /* 102 */

      /***/
      function (module, exports) {
        module.exports = "<svg viewbox=\"0 0 18 18\"> <path class=ql-fill d=M15.5,15H13.861a3.858,3.858,0,0,0,1.914-2.975,1.8,1.8,0,0,0-1.6-1.751A1.921,1.921,0,0,0,12.021,11.7a0.50013,0.50013,0,1,0,.957.291h0a0.914,0.914,0,0,1,1.053-.725,0.81,0.81,0,0,1,.744.762c0,1.076-1.16971,1.86982-1.93971,2.43082A1.45639,1.45639,0,0,0,12,15.5a0.5,0.5,0,0,0,.5.5h3A0.5,0.5,0,0,0,15.5,15Z /> <path class=ql-fill d=M9.65,5.241a1,1,0,0,0-1.409.108L6,7.964,3.759,5.349A1,1,0,0,0,2.192,6.59178Q2.21541,6.6213,2.241,6.649L4.684,9.5,2.241,12.35A1,1,0,0,0,3.71,13.70722q0.02557-.02768.049-0.05722L6,11.036,8.241,13.65a1,1,0,1,0,1.567-1.24277Q9.78459,12.3777,9.759,12.35L7.316,9.5,9.759,6.651A1,1,0,0,0,9.65,5.241Z /> </svg>";
        /***/
      },
      /* 103 */

      /***/
      function (module, exports) {
        module.exports = "<svg viewbox=\"0 0 18 18\"> <path class=ql-fill d=M15.5,7H13.861a4.015,4.015,0,0,0,1.914-2.975,1.8,1.8,0,0,0-1.6-1.751A1.922,1.922,0,0,0,12.021,3.7a0.5,0.5,0,1,0,.957.291,0.917,0.917,0,0,1,1.053-.725,0.81,0.81,0,0,1,.744.762c0,1.077-1.164,1.925-1.934,2.486A1.423,1.423,0,0,0,12,7.5a0.5,0.5,0,0,0,.5.5h3A0.5,0.5,0,0,0,15.5,7Z /> <path class=ql-fill d=M9.651,5.241a1,1,0,0,0-1.41.108L6,7.964,3.759,5.349a1,1,0,1,0-1.519,1.3L4.683,9.5,2.241,12.35a1,1,0,1,0,1.519,1.3L6,11.036,8.241,13.65a1,1,0,0,0,1.519-1.3L7.317,9.5,9.759,6.651A1,1,0,0,0,9.651,5.241Z /> </svg>";
        /***/
      },
      /* 104 */

      /***/
      function (module, exports) {
        module.exports = "<svg viewbox=\"0 0 18 18\"> <line class=\"ql-stroke ql-thin\" x1=15.5 x2=2.5 y1=8.5 y2=9.5></line> <path class=ql-fill d=M9.007,8C6.542,7.791,6,7.519,6,6.5,6,5.792,7.283,5,9,5c1.571,0,2.765.679,2.969,1.309a1,1,0,0,0,1.9-.617C13.356,4.106,11.354,3,9,3,6.2,3,4,4.538,4,6.5a3.2,3.2,0,0,0,.5,1.843Z></path> <path class=ql-fill d=M8.984,10C11.457,10.208,12,10.479,12,11.5c0,0.708-1.283,1.5-3,1.5-1.571,0-2.765-.679-2.969-1.309a1,1,0,1,0-1.9.617C4.644,13.894,6.646,15,9,15c2.8,0,5-1.538,5-3.5a3.2,3.2,0,0,0-.5-1.843Z></path> </svg>";
        /***/
      },
      /* 105 */

      /***/
      function (module, exports) {
        module.exports = "<svg viewbox=\"0 0 18 18\"> <path class=ql-stroke d=M5,3V9a4.012,4.012,0,0,0,4,4H9a4.012,4.012,0,0,0,4-4V3></path> <rect class=ql-fill height=1 rx=0.5 ry=0.5 width=12 x=3 y=15></rect> </svg>";
        /***/
      },
      /* 106 */

      /***/
      function (module, exports) {
        module.exports = "<svg viewbox=\"0 0 18 18\"> <rect class=ql-stroke height=12 width=12 x=3 y=3></rect> <rect class=ql-fill height=12 width=1 x=5 y=3></rect> <rect class=ql-fill height=12 width=1 x=12 y=3></rect> <rect class=ql-fill height=2 width=8 x=5 y=8></rect> <rect class=ql-fill height=1 width=3 x=3 y=5></rect> <rect class=ql-fill height=1 width=3 x=3 y=7></rect> <rect class=ql-fill height=1 width=3 x=3 y=10></rect> <rect class=ql-fill height=1 width=3 x=3 y=12></rect> <rect class=ql-fill height=1 width=3 x=12 y=5></rect> <rect class=ql-fill height=1 width=3 x=12 y=7></rect> <rect class=ql-fill height=1 width=3 x=12 y=10></rect> <rect class=ql-fill height=1 width=3 x=12 y=12></rect> </svg>";
        /***/
      },
      /* 107 */

      /***/
      function (module, exports) {
        module.exports = "<svg viewbox=\"0 0 18 18\"> <polygon class=ql-stroke points=\"7 11 9 13 11 11 7 11\"></polygon> <polygon class=ql-stroke points=\"7 7 9 5 11 7 7 7\"></polygon> </svg>";
        /***/
      },
      /* 108 */

      /***/
      function (module, exports, __webpack_require__) {

        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports["default"] = exports.BubbleTooltip = undefined;

        var _get = function get(object, property, receiver) {
          if (object === null) object = Function.prototype;
          var desc = Object.getOwnPropertyDescriptor(object, property);

          if (desc === undefined) {
            var parent = Object.getPrototypeOf(object);

            if (parent === null) {
              return undefined;
            } else {
              return get(parent, property, receiver);
            }
          } else if ("value" in desc) {
            return desc.value;
          } else {
            var getter = desc.get;

            if (getter === undefined) {
              return undefined;
            }

            return getter.call(receiver);
          }
        };

        var _createClass = function () {
          function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor) descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
          };
        }();

        var _extend = __webpack_require__(3);

        var _extend2 = _interopRequireDefault(_extend);

        var _emitter = __webpack_require__(8);

        var _emitter2 = _interopRequireDefault(_emitter);

        var _base = __webpack_require__(43);

        var _base2 = _interopRequireDefault(_base);

        var _selection = __webpack_require__(15);

        var _icons = __webpack_require__(41);

        var _icons2 = _interopRequireDefault(_icons);

        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : {
            "default": obj
          };
        }

        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }

        function _possibleConstructorReturn(self, call) {
          if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }

          return call && (_typeof(call) === "object" || typeof call === "function") ? call : self;
        }

        function _inherits(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + _typeof(superClass));
          }

          subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
              value: subClass,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }

        var TOOLBAR_CONFIG = [['bold', 'italic', 'link'], [{
          header: 1
        }, {
          header: 2
        }, 'blockquote']];

        var BubbleTheme = function (_BaseTheme) {
          _inherits(BubbleTheme, _BaseTheme);

          function BubbleTheme(quill, options) {
            _classCallCheck(this, BubbleTheme);

            if (options.modules.toolbar != null && options.modules.toolbar.container == null) {
              options.modules.toolbar.container = TOOLBAR_CONFIG;
            }

            var _this = _possibleConstructorReturn(this, (BubbleTheme.__proto__ || Object.getPrototypeOf(BubbleTheme)).call(this, quill, options));

            _this.quill.container.classList.add('ql-bubble');

            return _this;
          }

          _createClass(BubbleTheme, [{
            key: 'extendToolbar',
            value: function extendToolbar(toolbar) {
              this.tooltip = new BubbleTooltip(this.quill, this.options.bounds);
              this.tooltip.root.appendChild(toolbar.container);
              this.buildButtons([].slice.call(toolbar.container.querySelectorAll('button')), _icons2["default"]);
              this.buildPickers([].slice.call(toolbar.container.querySelectorAll('select')), _icons2["default"]);
            }
          }]);

          return BubbleTheme;
        }(_base2["default"]);

        BubbleTheme.DEFAULTS = (0, _extend2["default"])(true, {}, _base2["default"].DEFAULTS, {
          modules: {
            toolbar: {
              handlers: {
                link: function link(value) {
                  if (!value) {
                    this.quill.format('link', false);
                  } else {
                    this.quill.theme.tooltip.edit();
                  }
                }
              }
            }
          }
        });

        var BubbleTooltip = function (_BaseTooltip) {
          _inherits(BubbleTooltip, _BaseTooltip);

          function BubbleTooltip(quill, bounds) {
            _classCallCheck(this, BubbleTooltip);

            var _this2 = _possibleConstructorReturn(this, (BubbleTooltip.__proto__ || Object.getPrototypeOf(BubbleTooltip)).call(this, quill, bounds));

            _this2.quill.on(_emitter2["default"].events.EDITOR_CHANGE, function (type, range, oldRange, source) {
              if (type !== _emitter2["default"].events.SELECTION_CHANGE) return;

              if (range != null && range.length > 0 && source === _emitter2["default"].sources.USER) {
                _this2.show(); // Lock our width so we will expand beyond our offsetParent boundaries


                _this2.root.style.left = '0px';
                _this2.root.style.width = '';
                _this2.root.style.width = _this2.root.offsetWidth + 'px';

                var lines = _this2.quill.getLines(range.index, range.length);

                if (lines.length === 1) {
                  _this2.position(_this2.quill.getBounds(range));
                } else {
                  var lastLine = lines[lines.length - 1];

                  var index = _this2.quill.getIndex(lastLine);

                  var length = Math.min(lastLine.length() - 1, range.index + range.length - index);

                  var _bounds = _this2.quill.getBounds(new _selection.Range(index, length));

                  _this2.position(_bounds);
                }
              } else if (document.activeElement !== _this2.textbox && _this2.quill.hasFocus()) {
                _this2.hide();
              }
            });

            return _this2;
          }

          _createClass(BubbleTooltip, [{
            key: 'listen',
            value: function listen() {
              var _this3 = this;

              _get(BubbleTooltip.prototype.__proto__ || Object.getPrototypeOf(BubbleTooltip.prototype), 'listen', this).call(this);

              this.root.querySelector('.ql-close').addEventListener('click', function () {
                _this3.root.classList.remove('ql-editing');
              });
              this.quill.on(_emitter2["default"].events.SCROLL_OPTIMIZE, function () {
                // Let selection be restored by toolbar handlers before repositioning
                setTimeout(function () {
                  if (_this3.root.classList.contains('ql-hidden')) return;

                  var range = _this3.quill.getSelection();

                  if (range != null) {
                    _this3.position(_this3.quill.getBounds(range));
                  }
                }, 1);
              });
            }
          }, {
            key: 'cancel',
            value: function cancel() {
              this.show();
            }
          }, {
            key: 'position',
            value: function position(reference) {
              var shift = _get(BubbleTooltip.prototype.__proto__ || Object.getPrototypeOf(BubbleTooltip.prototype), 'position', this).call(this, reference);

              var arrow = this.root.querySelector('.ql-tooltip-arrow');
              arrow.style.marginLeft = '';
              if (shift === 0) return shift;
              arrow.style.marginLeft = -1 * shift - arrow.offsetWidth / 2 + 'px';
            }
          }]);

          return BubbleTooltip;
        }(_base.BaseTooltip);

        BubbleTooltip.TEMPLATE = ['<span class="ql-tooltip-arrow"></span>', '<div class="ql-tooltip-editor">', '<input type="text" data-formula="e=mc^2" data-link="https://quilljs.com" data-video="Embed URL">', '<a class="ql-close"></a>', '</div>'].join('');
        exports.BubbleTooltip = BubbleTooltip;
        exports["default"] = BubbleTheme;
        /***/
      },
      /* 109 */

      /***/
      function (module, exports, __webpack_require__) {
        module.exports = __webpack_require__(63);
        /***/
      }
      /******/
      ])["default"]
    );
  });

  var quill = /*#__PURE__*/Object.freeze({
    __proto__: null
  });

  //
  //
  //
  //
  //
  //
  //
  require('quill/dist/quill.snow.css');

  require('quill/dist/quill.bubble.css');

  require('quill/dist/quill.core.css');

  if (!window.Quill) {
    window.Quill = require('quill/dist/quill.js');
  }

  var script$O = {
    name: 'quill-editor',
    data: function data() {
      return {
        _content: '',
        defaultModules: {
          toolbar: [['bold', 'italic', 'underline', 'strike'], ['blockquote', 'code-block'], [{
            'header': 1
          }, {
            'header': 2
          }], [{
            'list': 'ordered'
          }, {
            'list': 'bullet'
          }], [{
            'script': 'sub'
          }, {
            'script': 'super'
          }], [{
            'indent': '-1'
          }, {
            'indent': '+1'
          }], [{
            'direction': 'rtl'
          }], [{
            'size': ['small', false, 'large', 'huge']
          }], [{
            'header': [1, 2, 3, 4, 5, 6, false]
          }], [{
            'color': []
          }, {
            'background': []
          }], [{
            'font': []
          }], [{
            'align': []
          }], ['clean'], ['link', 'image', 'video']]
        }
      };
    },
    props: {
      content: String,
      value: String,
      disabled: Boolean,
      options: {
        type: Object,
        required: false,
        "default": function _default() {
          return {};
        }
      }
    },
    mounted: function mounted() {
      this.initialize();
    },
    beforeDestroy: function beforeDestroy() {
      this.quill = null;
    },
    methods: {
      initialize: function initialize() {
        if (this.$el) {
          // options and instance
          var self = this;
          self.options.theme = self.options.theme || 'snow';
          self.options.boundary = self.options.boundary || document.body;
          self.options.modules = self.options.modules || self.defaultModules;
          self.options.modules.toolbar = self.options.modules.toolbar !== undefined ? self.options.modules.toolbar : self.defaultModules.toolbar;
          self.options.placeholder = self.options.placeholder || 'Insert text here ...';
          self.options.readOnly = self.options.readOnly !== undefined ? self.options.readOnly : false;
          self.quill = new Quill(self.$refs.editor, self.options); // set editor content

          if (self.value || self.content) {
            self.quill.pasteHTML(self.value || self.content);
          } // mark model as touched if editor lost focus


          self.quill.on('selection-change', function (range) {
            if (!range) {
              self.$emit('blur', self.quill);
            } else {
              self.$emit('focus', self.quill);
            }
          }); // update model if text changes

          self.quill.on('text-change', function (delta, oldDelta, source) {
            var html = self.$refs.editor.children[0].innerHTML;
            var text = self.quill.getText();
            if (html === '<p><br></p>') html = '';
            self._content = html;
            self.$emit('input', self._content);
            self.$emit('change', {
              editor: self.quill,
              html: html,
              text: text
            });
          }); // disabled

          if (this.disabled) {
            this.quill.enable(false);
          } // emit ready


          self.$emit('ready', self.quill);
        }
      }
    },
    watch: {
      content: function content(newVal, oldVal) {
        if (this.quill) {
          if (!!newVal && newVal !== this._content) {
            this._content = newVal;
            this.quill.pasteHTML(newVal);
          } else if (!newVal) {
            this.quill.setText('');
          }
        }
      },
      value: function value(newVal, oldVal) {
        if (this.quill) {
          if (!!newVal && newVal !== this._content) {
            this._content = newVal;
            this.quill.pasteHTML(newVal);
          } else if (!newVal) {
            this.quill.setText('');
          }
        }
      },
      disabled: function disabled(newVal, oldVal) {
        if (this.quill) {
          this.quill.enable(!newVal);
        }
      }
    }
  };

  /* script */
  var __vue_script__$O = script$O;
  /* template */

  var __vue_render__$O = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      staticClass: "quill-editor"
    }, [_vm._t("toolbar"), _vm._v(" "), _c('div', {
      ref: "editor"
    })], 2);
  };

  var __vue_staticRenderFns__$O = [];
  /* style */

  var __vue_inject_styles__$O = function __vue_inject_styles__(inject) {
    if (!inject) return;
    inject("data-v-dfc14f92_0", {
      source: ".quill-editor img{max-width:100%}",
      map: undefined,
      media: undefined
    });
  };
  /* scoped */


  var __vue_scope_id__$O = undefined;
  /* module identifier */

  var __vue_module_identifier__$y = undefined;
  /* functional template */

  var __vue_is_functional_template__$O = false;
  /* component normalizer */

  function __vue_normalize__$O(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "editor.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    {
      var hook;

      if (style) {
        hook = function hook(context) {
          style.call(this, createInjector(context));
        };
      }

      if (hook !== undefined) {
        if (component.functional) {
          // register for functional component in vue file
          var originalRender = component.render;

          component.render = function renderWithStyleInjection(h, context) {
            hook.call(context);
            return originalRender(h, context);
          };
        } else {
          // inject component registration as beforeCreate hook
          var existing = component.beforeCreate;
          component.beforeCreate = existing ? [].concat(existing, hook) : [hook];
        }
      }
    }

    return component;
  }
  /* style inject */


  function __vue_create_injector__$y() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$y.styles || (__vue_create_injector__$y.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());
    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = {
        ids: [],
        parts: [],
        element: undefined
      });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;
        style.ids.push(id);

        if (css.map) {
          // https://developer.chrome.com/devtools/docs/javascript-debugging
          // this makes source maps inside style tags work properly in Chrome
          code += '\n/*# sourceURL=' + css.map.sources[0] + ' */'; // http://stackoverflow.com/a/26603875

          code += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(css.map)))) + ' */';
        }

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';
          if (css.media) el.setAttribute('media', css.media);

          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */


  var editor = __vue_normalize__$O({
    render: __vue_render__$O,
    staticRenderFns: __vue_staticRenderFns__$O
  }, __vue_inject_styles__$O, __vue_script__$O, __vue_scope_id__$O, __vue_is_functional_template__$O, __vue_module_identifier__$y, __vue_create_injector__$y);

  var editor$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': editor
  });

  var require$$0 = getCjsExportFromNamespace(editor$1);

  /**
   * Vue-Quill-Editor
   * @author Surmon.me
   */


  var quillEditor = require$$0;

  quillEditor = quillEditor["default"] || quillEditor;
  var VueQuillEditor = {
    Quill: quill,
    quillEditor: quillEditor,
    install: function install(Vue) {
      Vue.component(quillEditor.name, quillEditor);
    }
  };
  var vueQuillEditor = VueQuillEditor;

  var QUILL_OPTIONS$1 = {
    modules: {
      toolbar: [['bold', 'italic', 'underline', 'strike'], ['blockquote', 'code-block'], [{
        list: 'ordered'
      }, {
        list: 'bullet'
      }], [{
        script: 'sub'
      }, {
        script: 'super'
      }], [{
        color: []
      }, {
        background: []
      }], ['link']]
    }
  };

  var getAnswerType$1 = function getAnswerType(isGraded) {
    return isGraded ? 'Answer' : 'Option';
  };

  var getButtonLabel$1 = function getButtonLabel(isExpanded) {
    return isExpanded ? 'hide' : 'show';
  };

  var script$N = {
    name: 'feedback',
    props: {
      answers: {
        type: [Array, Boolean],
        "default": null
      },
      feedback: {
        type: Object,
        "default": function _default() {
          return {};
        }
      },
      isEditing: {
        type: Boolean,
        "default": false
      },
      isGraded: {
        type: Boolean,
        "default": false
      }
    },
    data: function data(vm) {
      return {
        isExpanded: some__default['default'](vm.feedback)
      };
    },
    computed: {
      quillOptions: function quillOptions() {
        return QUILL_OPTIONS$1;
      },
      answerType: function answerType(vm) {
        return getAnswerType$1(vm.isGraded);
      },
      buttonLabel: function buttonLabel(vm) {
        return getButtonLabel$1(vm.isExpanded);
      },
      processedAnswers: function processedAnswers(vm) {
        return isArray__default['default'](vm.answers) ? vm.answers : ['True', 'False'];
      }
    },
    methods: {
      updateFeedback: function updateFeedback(_ref, index) {
        var html = _ref.html;
        this.$emit('update', _defineProperty$1({}, index, html));
      },
      toggleExpand: function toggleExpand() {
        this.isExpanded = !this.isExpanded;
      }
    },
    watch: {
      isEditing: function isEditing(val) {
        if (!some__default['default'](this.feedback)) return;
        if (val) this.isExpanded = true;
      }
    },
    components: {
      QuillEditor: vueQuillEditor.quillEditor
    }
  };

  /* script */
  var __vue_script__$N = script$N;
  /* template */

  var __vue_render__$N = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      staticClass: "px-1"
    }, [_c('div', [_c('span', {
      staticClass: "subtitle-2"
    }, [_vm._v("Feedback")]), _vm._v(" "), _c('v-btn', {
      staticClass: "ml-1",
      attrs: {
        "text": "",
        "small": ""
      },
      on: {
        "click": _vm.toggleExpand
      }
    }, [_vm._v("\n      " + _vm._s(_vm.buttonLabel) + "\n    ")])], 1), _vm._v(" "), _c('transition', {
      attrs: {
        "name": "fade"
      }
    }, [_vm.isExpanded ? _c('div', {
      staticClass: "feedback-content"
    }, _vm._l(_vm.processedAnswers, function (answer, i) {
      return _c('v-row', {
        key: i
      }, [_c('v-col', [_c('div', {
        staticClass: "feedback-info mb-4"
      }, [_c('span', {
        staticClass: "answer-type subtitle-2"
      }, [_vm._v(_vm._s(_vm.answerType) + " " + _vm._s(i + 1) + ":")]), _vm._v(" "), _c('span', [_vm._v(_vm._s(answer || 'Answer not added.'))])]), _vm._v(" "), _vm.isEditing ? _c('quill-editor', {
        staticClass: "grey lighten-3",
        attrs: {
          "options": _vm.quillOptions,
          "content": _vm.feedback[i]
        },
        on: {
          "change": function change($event) {
            return _vm.updateFeedback($event, i);
          }
        }
      }) : _c('div', {
        staticClass: "feedback-preview"
      }, [_vm.feedback[i] ? _c('div', {
        domProps: {
          "innerHTML": _vm._s(_vm.feedback[i])
        }
      }) : _c('i', [_vm._v("Feedback not added.")])])], 1)], 1);
    }), 1) : _vm._e()])], 1);
  };

  var __vue_staticRenderFns__$N = [];
  /* style */

  var __vue_inject_styles__$N = undefined;
  /* scoped */

  var __vue_scope_id__$N = undefined;
  /* functional template */

  var __vue_is_functional_template__$N = false;
  /* component normalizer */

  function __vue_normalize__$N(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "Feedback.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */

  /* style inject SSR */


  var Feedback$1 = __vue_normalize__$N({
    render: __vue_render__$N,
    staticRenderFns: __vue_staticRenderFns__$N
  }, __vue_inject_styles__$N, __vue_script__$N, __vue_scope_id__$N, __vue_is_functional_template__$N);

  //
  var script$M = {
    name: 'tailor-contained-content',
    inheritAttrs: false,
    props: {
      element: {
        type: Object,
        required: true
      },
      isDisabled: {
        type: Boolean,
        "default": false
      },
      isDragged: {
        type: Boolean,
        "default": false
      },
      setWidth: {
        type: Boolean,
        "default": true
      },
      dense: {
        type: Boolean,
        "default": false
      }
    },
    data: function data() {
      return {
        isHovered: false
      };
    },
    computed: {
      bindings: function bindings() {
        var element = this.element,
            isDisabled = this.isDisabled,
            isDragged = this.isDragged,
            isHovered = this.isHovered,
            dense = this.dense,
            attrs = this.$attrs;
        return Object.assign({
          element: element,
          isDisabled: isDisabled,
          isDragged: isDragged,
          isHovered: isHovered,
          dense: dense
        }, attrs);
      },
      widthClass: function widthClass() {
        var element = this.element,
            setWidth = this.setWidth;
        return setWidth ? "col-xs-".concat(get__default['default'](element, 'data.width', 12)) : '';
      }
    },
    methods: {
      scrollContainer: throttle__default['default'](function (e) {
        var scrollUp = e.y < 200;
        var scrollDown = e.y > window.innerHeight - 200;
        if (scrollUp || scrollDown) window.scrollBy(0, scrollUp ? -30 : 30);
      }, 20)
    },
    components: {
      ContentElement: ContentElement$3
    }
  };

  /* script */
  var __vue_script__$M = script$M;
  /* template */

  var __vue_render__$M = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      staticClass: "contained-content",
      "class": [_vm.widthClass, {
        disabled: _vm.isDisabled,
        hovered: _vm.isHovered
      }],
      on: {
        "mouseover": function mouseover($event) {
          _vm.isHovered = true;
        },
        "mouseleave": function mouseleave($event) {
          _vm.isHovered = false;
        },
        "dragstart": function dragstart($event) {
          return _vm.$emit('dragstart');
        },
        "dragend": function dragend($event) {
          return _vm.$emit('dragend');
        },
        "dragover": _vm.scrollContainer
      }
    }, [!_vm.isDisabled ? _c('span', {
      staticClass: "drag-handle"
    }, [_c('span', {
      staticClass: "mdi mdi-drag-vertical"
    })]) : _vm._e(), _vm._v(" "), _c('content-element', _vm._b({
      on: {
        "add": function add($event) {
          return _vm.$emit('add', $event);
        },
        "save": function save($event) {
          return _vm.$emit('save', $event);
        },
        "save:meta": function saveMeta($event) {
          return _vm.$emit('save:meta', $event);
        },
        "delete": function _delete($event) {
          return _vm.$emit('delete');
        }
      }
    }, 'content-element', _vm.bindings, false))], 1);
  };

  var __vue_staticRenderFns__$M = [];
  /* style */

  var __vue_inject_styles__$M = function __vue_inject_styles__(inject) {
    if (!inject) return;
    inject("data-v-cb586726_0", {
      source: ".drag-handle[data-v-cb586726]{position:absolute;left:-3px;z-index:2;width:26px;opacity:0}.drag-handle .mdi[data-v-cb586726]{color:#888;font-size:28px}.hovered .drag-handle[data-v-cb586726]{opacity:1;transition:opacity .6s ease-in-out;cursor:pointer}.disabled .drag-handle[data-v-cb586726]{display:none}.contained-content[data-v-cb586726]{position:relative;margin:7px 0;padding:0}",
      map: undefined,
      media: undefined
    });
  };
  /* scoped */


  var __vue_scope_id__$M = "data-v-cb586726";
  /* module identifier */

  var __vue_module_identifier__$x = undefined;
  /* functional template */

  var __vue_is_functional_template__$M = false;
  /* component normalizer */

  function __vue_normalize__$M(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "ContainedContent.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    {
      var hook;

      if (style) {
        hook = function hook(context) {
          style.call(this, createInjector(context));
        };
      }

      if (hook !== undefined) {
        if (component.functional) {
          // register for functional component in vue file
          var originalRender = component.render;

          component.render = function renderWithStyleInjection(h, context) {
            hook.call(context);
            return originalRender(h, context);
          };
        } else {
          // inject component registration as beforeCreate hook
          var existing = component.beforeCreate;
          component.beforeCreate = existing ? [].concat(existing, hook) : [hook];
        }
      }
    }

    return component;
  }
  /* style inject */


  function __vue_create_injector__$x() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$x.styles || (__vue_create_injector__$x.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());
    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = {
        ids: [],
        parts: [],
        element: undefined
      });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;
        style.ids.push(id);

        if (css.map) {
          // https://developer.chrome.com/devtools/docs/javascript-debugging
          // this makes source maps inside style tags work properly in Chrome
          code += '\n/*# sourceURL=' + css.map.sources[0] + ' */'; // http://stackoverflow.com/a/26603875

          code += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(css.map)))) + ' */';
        }

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';
          if (css.media) el.setAttribute('media', css.media);

          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */


  var ContainedContent$1 = __vue_normalize__$M({
    render: __vue_render__$M,
    staticRenderFns: __vue_staticRenderFns__$M
  }, __vue_inject_styles__$M, __vue_script__$M, __vue_scope_id__$M, __vue_is_functional_template__$M, __vue_module_identifier__$x, __vue_create_injector__$x);

  //
  //
  //
  //
  //
  //
  //
  //
  var script$L = {
    name: 'tailor-input-error',
    props: {
      error: {
        type: String,
        "default": ''
      }
    }
  };

  /* script */
  var __vue_script__$L = script$L;
  /* template */

  var __vue_render__$L = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('transition', {
      attrs: {
        "name": "message-transition"
      }
    }, [!!_vm.error ? _c('div', {
      staticClass: "input-error"
    }, [_vm._v("\n    " + _vm._s(_vm.error) + "\n  ")]) : _vm._e()]);
  };

  var __vue_staticRenderFns__$L = [];
  /* style */

  var __vue_inject_styles__$L = function __vue_inject_styles__(inject) {
    if (!inject) return;
    inject("data-v-ff8d03d8_0", {
      source: ".input-error[data-v-ff8d03d8]{color:var(--v-error-base);font-size:.75rem}",
      map: undefined,
      media: undefined
    });
  };
  /* scoped */


  var __vue_scope_id__$L = "data-v-ff8d03d8";
  /* module identifier */

  var __vue_module_identifier__$w = undefined;
  /* functional template */

  var __vue_is_functional_template__$L = false;
  /* component normalizer */

  function __vue_normalize__$L(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "InputError.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    {
      var hook;

      if (style) {
        hook = function hook(context) {
          style.call(this, createInjector(context));
        };
      }

      if (hook !== undefined) {
        if (component.functional) {
          // register for functional component in vue file
          var originalRender = component.render;

          component.render = function renderWithStyleInjection(h, context) {
            hook.call(context);
            return originalRender(h, context);
          };
        } else {
          // inject component registration as beforeCreate hook
          var existing = component.beforeCreate;
          component.beforeCreate = existing ? [].concat(existing, hook) : [hook];
        }
      }
    }

    return component;
  }
  /* style inject */


  function __vue_create_injector__$w() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$w.styles || (__vue_create_injector__$w.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());
    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = {
        ids: [],
        parts: [],
        element: undefined
      });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;
        style.ids.push(id);

        if (css.map) {
          // https://developer.chrome.com/devtools/docs/javascript-debugging
          // this makes source maps inside style tags work properly in Chrome
          code += '\n/*# sourceURL=' + css.map.sources[0] + ' */'; // http://stackoverflow.com/a/26603875

          code += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(css.map)))) + ' */';
        }

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';
          if (css.media) el.setAttribute('media', css.media);

          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */


  var InputError$1 = __vue_normalize__$L({
    render: __vue_render__$L,
    staticRenderFns: __vue_staticRenderFns__$L
  }, __vue_inject_styles__$L, __vue_script__$L, __vue_scope_id__$L, __vue_is_functional_template__$L, __vue_module_identifier__$w, __vue_create_injector__$w);

  //
  var DRAG_OPTIONS$1 = {
    handle: '.drag-handle',
    scrollSensitivity: 125,
    scrollSpeed: 15
  };
  var script$K = {
    name: 'question',
    props: {
      assessment: {
        type: Object,
        required: true
      },
      errors: {
        type: Array,
        "default": function _default() {
          return [];
        }
      },
      isEditing: {
        type: Boolean,
        "default": false
      }
    },
    data: function data() {
      return {
        isFocused: false
      };
    },
    computed: Object.assign({}, vueRadio.mapChannels({
      editorChannel: 'editor'
    }), {
      question: {
        get: function get() {
          return cloneDeep__default['default'](this.assessment.data.question);
        },
        set: function set(question) {
          this.$emit('update', {
            question: question
          });
        }
      },
      questionError: function questionError(vm) {
        return head__default['default'](utils.assessment.getErrorMessages(vm.errors, 'question'));
      },
      dragOptions: function dragOptions() {
        return DRAG_OPTIONS$1;
      }
    }),
    methods: {
      addQuestionElements: function addQuestionElements(elements) {
        var question = cloneDeep__default['default'](this.assessment.data.question);
        this.$emit('update', {
          question: question.concat(elements)
        });
      },
      updateElement: function updateElement(element, data) {
        if (!this.isEditing) return;
        var question = cloneDeep__default['default'](this.assessment.data.question);
        var index = findIndex__default['default'](question, {
          id: element.id
        });
        if (index === -1) return;
        element = Object.assign({}, question[index], {
          data: data
        });
        this.$emit('update', {
          question: set__default['default'](question, index, element)
        });
      },
      deleteElement: function deleteElement(element) {
        var question = cloneDeep__default['default'](this.assessment.data.question);
        var index = findIndex__default['default'](question, {
          id: element.id
        });
        if (index === -1) return;
        pullAt__default['default'](question, index);
        this.$emit('update', {
          question: question
        });
      }
    },
    created: function created() {
      var _this = this;

      this.editorChannel.on('element:focus', function () {
        var element = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        _this.isFocused = !!find__default['default'](_this.question, {
          id: element.id
        });
      });
    },
    components: {
      AddElement: AddElement$1,
      ContainedContent: ContainedContent$1,
      Draggable: Draggable__default['default'],
      InputError: InputError$1
    }
  };

  /* script */
  var __vue_script__$K = script$K;
  /* template */

  var __vue_render__$K = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', [_c('div', {
      staticClass: "subtitle-2 mb-2"
    }, [_vm._v("Question")]), _vm._v(" "), _c('div', {
      "class": ['question-container', {
        focused: _vm.isFocused,
        disabled: !_vm.isEditing,
        incorrect: !!_vm.questionError
      }]
    }, [_c('draggable', _vm._b({
      staticClass: "row",
      model: {
        value: _vm.question,
        callback: function callback($$v) {
          _vm.question = $$v;
        },
        expression: "question"
      }
    }, 'draggable', _vm.dragOptions, false), _vm._l(_vm.question, function (element) {
      return _c('contained-content', {
        key: element.id,
        staticClass: "mb-4",
        attrs: {
          "element": element,
          "is-disabled": !_vm.isEditing,
          "dense": ""
        },
        on: {
          "save": function save($event) {
            return _vm.updateElement(element, $event);
          },
          "delete": function _delete($event) {
            return _vm.deleteElement(element);
          }
        }
      });
    }), 1)], 1), _vm._v(" "), _c('add-element', {
      "class": {
        invisible: !_vm.isEditing
      },
      attrs: {
        "items": _vm.question,
        "layout": false,
        "position": _vm.question.length,
        "disabled": !_vm.isEditing,
        "include": ['JODIT_HTML', 'IMAGE', 'EMBED', 'HTML']
      },
      on: {
        "add": _vm.addQuestionElements
      },
      scopedSlots: _vm._u([{
        key: "default",
        fn: function fn(ref) {
          var addElement = ref.addElement;
          return [_c('div', {
            staticClass: "d-flex justify-space-between mt-2 pl-3"
          }, [_c('input-error', {
            attrs: {
              "error": _vm.questionError
            }
          }), _vm._v(" "), _c('v-btn', {
            staticClass: "mt-2 ml-auto px-2",
            attrs: {
              "text": ""
            },
            on: {
              "click": addElement
            }
          }, [_c('v-icon', {
            staticClass: "mr-1",
            attrs: {
              "dense": ""
            }
          }, [_vm._v("mdi-plus")]), _vm._v("\n        Add question element\n      ")], 1)], 1)];
        }
      }])
    })], 1);
  };

  var __vue_staticRenderFns__$K = [];
  /* style */

  var __vue_inject_styles__$K = function __vue_inject_styles__(inject) {
    if (!inject) return;
    inject("data-v-28708166_0", {
      source: ".question-container[data-v-28708166]{position:relative;min-height:8.75rem;padding:1rem 3rem 0 2.5rem;text-align:center;background:#ebebeb;border-radius:.125rem;transition:.3s cubic-bezier(.25,.8,.5,1)}.question-container[data-v-28708166]::after,.question-container[data-v-28708166]::before{content:'';position:absolute;bottom:-1px;left:0;width:100%;transition:.3s cubic-bezier(.25,.8,.5,1)}.question-container[data-v-28708166]::before{border-style:solid;border-width:thin 0 0 0}.question-container[data-v-28708166]::after{border-style:solid;border-width:thin 0 thin 0;transform:scaleX(0)}.question-container[data-v-28708166]:not(.focused):not(.disabled):not(.incorrect):hover{background:#dcdcdc}.question-container[data-v-28708166]:not(.focused):not(.disabled):not(.incorrect):hover  .content-element{border-color:#bbb}.focused[data-v-28708166]::after{transform:scaleX(1)}.disabled[data-v-28708166]{color:rgba(0,0,0,.38)}.disabled[data-v-28708166]::before{border-image:repeating-linear-gradient(to right,rgba(0,0,0,.38) 0,rgba(0,0,0,.38) .125rem,transparent .125rem,transparent .25rem) 1 repeat}.incorrect[data-v-28708166]::after,.incorrect[data-v-28708166]::before{border-color:var(--v-error-base)}.invisible[data-v-28708166]{visibility:none}",
      map: undefined,
      media: undefined
    });
  };
  /* scoped */


  var __vue_scope_id__$K = "data-v-28708166";
  /* module identifier */

  var __vue_module_identifier__$v = undefined;
  /* functional template */

  var __vue_is_functional_template__$K = false;
  /* component normalizer */

  function __vue_normalize__$K(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "Question.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    {
      var hook;

      if (style) {
        hook = function hook(context) {
          style.call(this, createInjector(context));
        };
      }

      if (hook !== undefined) {
        if (component.functional) {
          // register for functional component in vue file
          var originalRender = component.render;

          component.render = function renderWithStyleInjection(h, context) {
            hook.call(context);
            return originalRender(h, context);
          };
        } else {
          // inject component registration as beforeCreate hook
          var existing = component.beforeCreate;
          component.beforeCreate = existing ? [].concat(existing, hook) : [hook];
        }
      }
    }

    return component;
  }
  /* style inject */


  function __vue_create_injector__$v() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$v.styles || (__vue_create_injector__$v.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());
    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = {
        ids: [],
        parts: [],
        element: undefined
      });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;
        style.ids.push(id);

        if (css.map) {
          // https://developer.chrome.com/devtools/docs/javascript-debugging
          // this makes source maps inside style tags work properly in Chrome
          code += '\n/*# sourceURL=' + css.map.sources[0] + ' */'; // http://stackoverflow.com/a/26603875

          code += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(css.map)))) + ' */';
        }

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';
          if (css.media) el.setAttribute('media', css.media);

          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */


  var Question$1 = __vue_normalize__$K({
    render: __vue_render__$K,
    staticRenderFns: __vue_staticRenderFns__$K
  }, __vue_inject_styles__$K, __vue_script__$K, __vue_scope_id__$K, __vue_is_functional_template__$K, __vue_module_identifier__$v, __vue_create_injector__$v);

  //

  var resolveComponentName$1 = function resolveComponentName(type) {
    return utils.getComponentName(utils.processAnswerType(type));
  };

  var WITH_FEEDBACK$1 = ['MC', 'SC', 'TF'];
  var TEXT_CONTAINERS$3 = ['JODIT_HTML', 'HTML'];
  var validationOptions$1 = {
    recursive: true,
    abortEarly: false
  };
  var script$J = {
    name: 'tce-question-container',
    inject: ['$teRegistry'],
    props: {
      element: {
        type: Object,
        required: true
      },
      isDisabled: {
        type: Boolean,
        "default": false
      }
    },
    data: function data(vm) {
      return {
        isEditing: !vm.element.id,
        editedElement: cloneDeep__default['default'](vm.element),
        undoState: cloneDeep__default['default'](vm.element),
        errors: [],
        alert: {}
      };
    },
    computed: {
      answerType: function answerType(vm) {
        return vm.element.data.type;
      },
      isGraded: function isGraded(vm) {
        return vm.element.type === 'ASSESSMENT';
      },
      showFeedback: function showFeedback(vm) {
        return WITH_FEEDBACK$1.includes(vm.answerType);
      },
      componentName: function componentName(vm) {
        return resolveComponentName$1(vm.answerType);
      },
      config: function config(vm) {
        return vm.$teRegistry.get(vm.answerType);
      },
      hintErrors: function hintErrors(vm) {
        return utils.assessment.getErrorMessages(vm.errors, 'hint');
      },
      schema: function schema() {
        var schema = this.config.schema;
        return ObjectSchema().shape(Object.assign({}, baseSchema$1, this.isGraded ? schema : omit__default['default'](schema, ['correct'])));
      }
    },
    methods: {
      edit: function edit() {
        this.editedElement = cloneDeep__default['default'](this.element);
        this.undoState = cloneDeep__default['default'](this.element);
        this.isEditing = true;
      },
      update: function update(data, validate) {
        var _this = this;

        Object.assign(this.editedElement.data, data);

        if (validate && !isEmpty__default['default'](this.errors)) {
          this.errors = [];
          this.validate()["catch"](function (err) {
            return _this.errors = err.inner;
          });
        }

        this.$emit('add', this.editedElement);
      },
      save: function save() {
        var _this2 = this;

        this.validate().then(function () {
          _this2.$emit('save', cloneDeep__default['default'](_this2.editedElement.data));

          _this2.isEditing = false;
          _this2.errors = [];
        })["catch"](function (err) {
          return _this2.errors = err.inner;
        });
      },
      cancel: function cancel() {
        if (!this.editedElement.id) return this.$emit('delete');
        this.$emit('add', cloneDeep__default['default'](this.undoState));
        this.editedElement = cloneDeep__default['default'](this.undoState);
        this.isEditing = false;
        this.errors = [];
        this.alert = {};
      },
      validate: function validate() {
        return this.schema.validate(this.editedElement.data, validationOptions$1);
      },
      updateFeedback: function updateFeedback(data) {
        var element = this.editedElement;
        this.$set(element.data, 'feedback', Object.assign({}, element.data.feedback, data));
      }
    },
    components: {
      Controls: Controls$1,
      Feedback: Feedback$1,
      Question: Question$1
    }
  };
  var question$1 = ArraySchema().test('has-text', 'Please define question', function (question) {
    return !!question.find(containsText$1);
  });

  function containsText$1(asset) {
    return TEXT_CONTAINERS$3.includes(asset.type) && asset.data.content && asset.data.content.trim().length > 0;
  }

  var baseSchema$1 = {
    question: question$1,
    hint: StringSchema().trim().max(500),
    _refs: ObjectSchema().shape({
      objectiveId: NumberSchema().integer().positive()
    })
  };

  /* script */
  var __vue_script__$J = script$J;
  /* template */

  var __vue_render__$J = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('v-card', {
      staticClass: "tce-question-container my-2 grey lighten-5"
    }, [_c('v-toolbar', {
      staticClass: "mb-5 px-0 elevation-2 text-left",
      attrs: {
        "color": "primary darken-3",
        "height": "36",
        "dark": ""
      }
    }, [_c('v-icon', {
      staticClass: "mr-2",
      attrs: {
        "color": "secondary lighten-2",
        "size": "18"
      }
    }, [_vm._v("mdi-help")]), _vm._v(" "), _c('span', {
      staticClass: "subtitle-2"
    }, [_vm._v(_vm._s(_vm.config.name))])], 1), _vm._v(" "), _vm._t("default", null, {
      "isEditing": _vm.isEditing
    }), _vm._v(" "), _c('div', {
      staticClass: "content"
    }, [_c('question', {
      attrs: {
        "assessment": _vm.editedElement,
        "is-editing": _vm.isEditing,
        "errors": _vm.errors
      },
      on: {
        "update": _vm.update
      }
    }), _vm._v(" "), _c(_vm.componentName, {
      tag: "component",
      staticClass: "tce-answer",
      attrs: {
        "assessment": _vm.editedElement.data,
        "is-editing": _vm.isEditing,
        "is-graded": _vm.isGraded,
        "errors": _vm.errors
      },
      on: {
        "update": _vm.update,
        "alert": function alert($event) {
          _vm.alert = $event;
        }
      }
    }), _vm._v(" "), _c('div', {
      staticClass: "subtitle-2 mb-2"
    }, [_vm._v("Hint")]), _vm._v(" "), _c('v-text-field', {
      attrs: {
        "error-messages": _vm.hintErrors,
        "disabled": !_vm.isEditing,
        "placeholder": "Optional hint...",
        "color": "blue-darken darken-3",
        "filled": "",
        "clearable": ""
      },
      model: {
        value: _vm.editedElement.data.hint,
        callback: function callback($$v) {
          _vm.$set(_vm.editedElement.data, "hint", $$v);
        },
        expression: "editedElement.data.hint"
      }
    }), _vm._v(" "), _vm.showFeedback ? _c('feedback', {
      attrs: {
        "answers": _vm.editedElement.data.answers,
        "feedback": _vm.editedElement.data.feedback,
        "is-graded": _vm.isGraded,
        "is-editing": _vm.isEditing
      },
      on: {
        "update": _vm.updateFeedback
      }
    }) : _vm._e(), _vm._v(" "), _c('v-alert', {
      directives: [{
        name: "show",
        rawName: "v-show",
        value: _vm.alert.text,
        expression: "alert.text"
      }],
      staticClass: "mt-4",
      attrs: {
        "type": _vm.alert.type,
        "prominent": ""
      }
    }, [_vm._v("\n      " + _vm._s(_vm.alert.text) + "\n    ")]), _vm._v(" "), !_vm.isDisabled ? _c('controls', {
      staticClass: "controls",
      attrs: {
        "is-editing": _vm.isEditing
      },
      on: {
        "edit": _vm.edit,
        "save": _vm.save,
        "cancel": _vm.cancel
      }
    }) : _vm._e()], 1)], 2);
  };

  var __vue_staticRenderFns__$J = [];
  /* style */

  var __vue_inject_styles__$J = function __vue_inject_styles__(inject) {
    if (!inject) return;
    inject("data-v-b4ecdf22_0", {
      source: ".tce-question-container[data-v-b4ecdf22]{min-height:25rem;background-color:#fff;overflow:visible;text-align:left}.tce-question-container[data-v-b4ecdf22]  .title{font-weight:400}.tce-question-container .content[data-v-b4ecdf22]{margin:.5rem 1.625rem}@media (max-width:1263px){.tce-question-container .content[data-v-b4ecdf22]{margin:.5rem}}.tce-question-container .tce-answer[data-v-b4ecdf22]{overflow:hidden}.disabled .controls[data-v-b4ecdf22]{display:none}",
      map: undefined,
      media: undefined
    });
  };
  /* scoped */


  var __vue_scope_id__$J = "data-v-b4ecdf22";
  /* module identifier */

  var __vue_module_identifier__$u = undefined;
  /* functional template */

  var __vue_is_functional_template__$J = false;
  /* component normalizer */

  function __vue_normalize__$J(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "index.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    {
      var hook;

      if (style) {
        hook = function hook(context) {
          style.call(this, createInjector(context));
        };
      }

      if (hook !== undefined) {
        if (component.functional) {
          // register for functional component in vue file
          var originalRender = component.render;

          component.render = function renderWithStyleInjection(h, context) {
            hook.call(context);
            return originalRender(h, context);
          };
        } else {
          // inject component registration as beforeCreate hook
          var existing = component.beforeCreate;
          component.beforeCreate = existing ? [].concat(existing, hook) : [hook];
        }
      }
    }

    return component;
  }
  /* style inject */


  function __vue_create_injector__$u() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$u.styles || (__vue_create_injector__$u.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());
    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = {
        ids: [],
        parts: [],
        element: undefined
      });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;
        style.ids.push(id);

        if (css.map) {
          // https://developer.chrome.com/devtools/docs/javascript-debugging
          // this makes source maps inside style tags work properly in Chrome
          code += '\n/*# sourceURL=' + css.map.sources[0] + ' */'; // http://stackoverflow.com/a/26603875

          code += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(css.map)))) + ' */';
        }

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';
          if (css.media) el.setAttribute('media', css.media);

          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */


  var TceQuestionContainer$1 = __vue_normalize__$J({
    render: __vue_render__$J,
    staticRenderFns: __vue_staticRenderFns__$J
  }, __vue_inject_styles__$J, __vue_script__$J, __vue_scope_id__$J, __vue_is_functional_template__$J, __vue_module_identifier__$u, __vue_create_injector__$u);

  //
  var TEXT_CONTAINERS$2 = ['JODIT_HTML', 'HTML'];
  var blankRegex$1 = /(@blank)/g;
  var htmlRegex$1 = /(<\/?[^>]+(>|$))|&nbsp;/g;

  var getTextAssets$1 = function getTextAssets(item) {
    return filter__default['default'](item, function (it) {
      return TEXT_CONTAINERS$2.includes(it.type);
    });
  };

  var script$I = {
    name: 'tailor-assessment-item',
    inject: ['$teRegistry', '$editorState'],
    props: {
      assessment: {
        type: Object,
        required: true
      },
      expanded: {
        type: Boolean,
        "default": false
      },
      draggable: {
        type: Boolean,
        "default": false
      },
      isDisabled: {
        type: Boolean,
        "default": false
      }
    },
    data: function data() {
      return {
        hover: false
      };
    },
    computed: {
      elementConfig: function elementConfig() {
        return this.$teRegistry.get(this.assessment.data.type);
      },
      question: function question() {
        var textAssets = getTextAssets$1(this.assessment.data.question);
        var question = map__default['default'](textAssets, 'data.content').join(' ');
        return question.replace(htmlRegex$1, '').replace(blankRegex$1, function () {
          return '____';
        });
      }
    },
    methods: {
      save: function save(data) {
        var assessment = cloneDeep__default['default'](this.assessment);
        Object.assign(assessment.data, data);
        this.$emit('save', assessment);
      }
    },
    components: {
      PublishDiffChip: PublishDiffChip$1,
      TceQuestionContainer: TceQuestionContainer$1
    }
  };

  /* script */
  var __vue_script__$I = script$I;
  /* template */

  var __vue_render__$I = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('li', {
      staticClass: "list-group-item assessment-item elevation-1",
      "class": [_vm.assessment.changeSincePublish, {
        hover: _vm.hover,
        expanded: _vm.expanded,
        diff: _vm.$editorState.isPublishDiff
      }],
      on: {
        "mouseenter": function mouseenter($event) {
          _vm.hover = true;
        },
        "mouseleave": function mouseleave($event) {
          _vm.hover = false;
        }
      }
    }, [_vm.draggable ? _c('span', {
      staticClass: "drag-handle"
    }, [_c('v-icon', [_vm._v("mdi-drag-vertical")])], 1) : _vm._e(), _vm._v(" "), _vm.expanded ? _c('tce-question-container', {
      staticClass: "question-container",
      attrs: {
        "element": _vm.assessment,
        "is-disabled": _vm.isDisabled
      },
      on: {
        "save": _vm.save,
        "delete": function _delete($event) {
          return _vm.$emit('delete');
        }
      },
      scopedSlots: _vm._u([{
        key: "default",
        fn: function fn(ref) {
          var isEditing = ref.isEditing;
          return [_c('div', {
            staticClass: "px-6 d-flex justify-end"
          }, [_c('v-btn', {
            staticClass: "px-2",
            attrs: {
              "text": "",
              "small": ""
            },
            on: {
              "click": function click($event) {
                return _vm.$emit('selected');
              }
            }
          }, [_c('v-icon', {
            staticClass: "mr-2",
            attrs: {
              "dense": ""
            }
          }, [_vm._v("mdi-arrow-collapse")]), _vm._v("\n          Collapse\n        ")], 1)], 1), _vm._v(" "), _c('div', {
            staticClass: "d-flex pb-4 px-6"
          }, [_vm._t("header", null, {
            "isEditing": isEditing
          })], 2)];
        }
      }], null, true)
    }) : _c('div', {
      staticClass: "minimized d-flex justify-space-between align-center",
      on: {
        "click": function click($event) {
          return _vm.$emit('selected');
        }
      }
    }, [_c('v-chip', {
      staticClass: "readonly",
      attrs: {
        "color": "primary darken-3",
        "label": "",
        "dark": "",
        "small": ""
      }
    }, [_vm._v("\n      " + _vm._s(_vm.elementConfig.subtype) + "\n    ")]), _vm._v(" "), _c('span', {
      staticClass: "question"
    }, [_vm._v(_vm._s(_vm._f("truncate")(_vm.question, 50)))]), _vm._v(" "), _vm.$editorState.isPublishDiff && _vm.assessment.changeSincePublish ? _c('publish-diff-chip', {
      attrs: {
        "change-type": _vm.assessment.changeSincePublish
      }
    }) : _c('v-btn', {
      staticClass: "delete",
      "class": {
        disabled: _vm.isDisabled
      },
      attrs: {
        "color": "primary darken-2",
        "icon": ""
      },
      on: {
        "click": function click($event) {
          $event.stopPropagation();
          return _vm.$emit('delete');
        }
      }
    }, [_c('v-icon', [_vm._v("mdi-close")])], 1)], 1)], 1);
  };

  var __vue_staticRenderFns__$I = [];
  /* style */

  var __vue_inject_styles__$I = function __vue_inject_styles__(inject) {
    if (!inject) return;
    inject("data-v-493c9656_0", {
      source: ".assessment-item[data-v-493c9656]{margin-bottom:.625rem;padding:0}.assessment-item .v-chip[data-v-493c9656]{min-width:1.875rem}.assessment-item .drag-handle[data-v-493c9656]{position:absolute;top:0;left:-3px;color:#888;font-size:28px;opacity:0;cursor:move}.assessment-item.hover .drag-handle[data-v-493c9656]{opacity:1;transition:opacity .6s ease-in-out}.assessment-item .minimized[data-v-493c9656]{padding:.375rem 1.375rem;cursor:pointer}.assessment-item .minimized .question[data-v-493c9656]{display:inline-block;max-width:80%;min-height:1.875rem;color:#444;font-size:1rem;font-weight:400;line-height:2.125rem}.assessment-item .minimized .v-chip[data-v-493c9656]{margin-top:.125rem}.assessment-item .delete[data-v-493c9656]{opacity:0}.assessment-item.hover:not(.sortable-chosen) .delete[data-v-493c9656]:not(.disabled){opacity:1}.question-container[data-v-493c9656]{margin:0!important}.diff[data-v-493c9656]{border:none}.diff.expanded[data-v-493c9656]{border-radius:4px}.diff.new[data-v-493c9656]{border:none;box-shadow:0 0 0 2px var(--v-success-lighten2)!important}.diff.changed[data-v-493c9656],.diff.removed[data-v-493c9656]{border:none;box-shadow:0 0 0 2px var(--v-secondary-lighten4)!important}",
      map: undefined,
      media: undefined
    });
  };
  /* scoped */


  var __vue_scope_id__$I = "data-v-493c9656";
  /* module identifier */

  var __vue_module_identifier__$t = undefined;
  /* functional template */

  var __vue_is_functional_template__$I = false;
  /* component normalizer */

  function __vue_normalize__$I(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "AssessmentItem.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    {
      var hook;

      if (style) {
        hook = function hook(context) {
          style.call(this, createInjector(context));
        };
      }

      if (hook !== undefined) {
        if (component.functional) {
          // register for functional component in vue file
          var originalRender = component.render;

          component.render = function renderWithStyleInjection(h, context) {
            hook.call(context);
            return originalRender(h, context);
          };
        } else {
          // inject component registration as beforeCreate hook
          var existing = component.beforeCreate;
          component.beforeCreate = existing ? [].concat(existing, hook) : [hook];
        }
      }
    }

    return component;
  }
  /* style inject */


  function __vue_create_injector__$t() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$t.styles || (__vue_create_injector__$t.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());
    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = {
        ids: [],
        parts: [],
        element: undefined
      });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;
        style.ids.push(id);

        if (css.map) {
          // https://developer.chrome.com/devtools/docs/javascript-debugging
          // this makes source maps inside style tags work properly in Chrome
          code += '\n/*# sourceURL=' + css.map.sources[0] + ' */'; // http://stackoverflow.com/a/26603875

          code += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(css.map)))) + ' */';
        }

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';
          if (css.media) el.setAttribute('media', css.media);

          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */


  var AssessmentItem = __vue_normalize__$I({
    render: __vue_render__$I,
    staticRenderFns: __vue_staticRenderFns__$I
  }, __vue_inject_styles__$I, __vue_script__$I, __vue_scope_id__$I, __vue_is_functional_template__$I, __vue_module_identifier__$t, __vue_create_injector__$t);

  var downloadMixin$1 = {
    methods: {
      download: function download(url, fileName) {
        var a = document.createElement('a');
        a.href = url;
        a.download = fileName;
        a.target = '_blank';
        a.click();
      }
    }
  };

  var uploadMixin$1 = {
    inject: ['$storageService', '$repository'],
    mixins: [downloadMixin$1],
    data: function data() {
      return {
        uploading: false
      };
    },
    computed: {
      repositoryId: function repositoryId() {
        return this.$repository.id;
      }
    },
    methods: Object.assign({}, vueRadio.mapRequests('app', ['showConfirmationModal']), {
      createFileForm: function createFileForm(e) {
        this.form = new FormData();

        var _e$target$files = _slicedToArray$1(e.target.files, 1),
            file = _e$target$files[0];

        if (!file) return;
        this.form.append('file', file, file.name);
      },
      upload: loader$1(function (e) {
        var _this = this;

        this.createFileForm(e);
        return this.$storageService.upload(this.repositoryId, this.form).then(function (data) {
          var _this$form$get = _this.form.get('file'),
              name = _this$form$get.name;

          _this.$emit('upload', Object.assign({}, data, {
            name: name
          }));
        })["catch"](function () {
          _this.error = 'An error has occurred!';
        });
      }, 'uploading'),
      downloadFile: async function downloadFile(key, name) {
        var url = await this.$storageService.getUrl(this.repositoryId, key);
        return this.download(url, name);
      },
      deleteFile: function deleteFile(item) {
        var _this2 = this;

        this.showConfirmationModal({
          title: 'Delete file?',
          message: "Are you sure you want to remove ".concat(item.fileName, "?"),
          action: function action() {
            return _this2.$emit('delete', item.id, null);
          }
        });
      }
    })
  };

  //
  var script$H = {
    name: 'upload-btn',
    mixins: [uploadMixin$1],
    props: {
      id: {
        type: String,
        "default": function _default() {
          return uniqueId__default['default']('file_');
        }
      },
      fileName: {
        type: String,
        "default": ''
      },
      fileKey: {
        type: String,
        "default": ''
      },
      validate: {
        type: Object,
        "default": function _default() {
          return {
            ext: []
          };
        }
      },
      label: {
        type: String,
        "default": 'Choose a file'
      },
      sm: {
        type: Boolean,
        "default": false
      }
    },
    methods: {
      validateAndUpload: async function validateAndUpload(e) {
        var _await$this$$refs$val = await this.$refs.validator.validate(e),
            valid = _await$this$$refs$val.valid;

        if (valid) this.upload(e);
      }
    },
    watch: {
      uploading: function uploading(val) {
        this.$emit('update:uploading', val);
      }
    }
  };

  /* script */
  var __vue_script__$H = script$H;
  /* template */

  var __vue_render__$H = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      staticClass: "file-upload"
    }, [_c('form', {
      staticClass: "upload-form",
      on: {
        "submit": function submit($event) {
          $event.preventDefault();
        }
      }
    }, [_c('validation-provider', {
      ref: "validator",
      attrs: {
        "rules": _vm.validate
      }
    }, [_c('input', {
      ref: _vm.id,
      staticClass: "upload-input",
      attrs: {
        "id": _vm.id,
        "name": _vm.id,
        "accept": _vm.validate.ext,
        "type": "file"
      },
      on: {
        "change": _vm.validateAndUpload
      }
    })]), _vm._v(" "), !_vm.fileKey ? _c('v-btn', {
      attrs: {
        "loading": _vm.uploading,
        "color": "grey darken-4",
        "text": ""
      },
      on: {
        "click": function click($event) {
          return _vm.$refs[_vm.id].click();
        }
      }
    }, [_c('v-icon', {
      staticClass: "mr-2",
      attrs: {
        "color": "secondary"
      }
    }, [_vm._v("mdi-cloud-upload-outline")]), _vm._v("\n      " + _vm._s(_vm.label) + "\n    ")], 1) : _c('span', {
      staticClass: "file-name",
      on: {
        "click": function click($event) {
          return _vm.downloadFile(_vm.fileKey, _vm.fileName);
        }
      }
    }, [_vm._v(_vm._s(_vm.fileName) + "\n    ")]), _vm._v(" "), _vm.fileKey ? _c('v-btn', {
      attrs: {
        "icon": "",
        "small": ""
      },
      on: {
        "click": function click($event) {
          return _vm.deleteFile({
            id: _vm.id,
            fileName: _vm.fileName
          });
        }
      }
    }, [_c('v-icon', [_vm._v("mdi-delete")])], 1) : _vm._e()], 1)]);
  };

  var __vue_staticRenderFns__$H = [];
  /* style */

  var __vue_inject_styles__$H = function __vue_inject_styles__(inject) {
    if (!inject) return;
    inject("data-v-1f089141_0", {
      source: ".file-upload[data-v-1f089141],.upload-form[data-v-1f089141]{display:inline-block}.upload-input[data-v-1f089141]{visibility:hidden;max-width:0;max-height:0}.file-name[data-v-1f089141]{color:#00f;font-size:1rem;text-decoration:underline;cursor:pointer}",
      map: undefined,
      media: undefined
    });
  };
  /* scoped */


  var __vue_scope_id__$H = "data-v-1f089141";
  /* module identifier */

  var __vue_module_identifier__$s = undefined;
  /* functional template */

  var __vue_is_functional_template__$H = false;
  /* component normalizer */

  function __vue_normalize__$H(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "UploadBtn.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    {
      var hook;

      if (style) {
        hook = function hook(context) {
          style.call(this, createInjector(context));
        };
      }

      if (hook !== undefined) {
        if (component.functional) {
          // register for functional component in vue file
          var originalRender = component.render;

          component.render = function renderWithStyleInjection(h, context) {
            hook.call(context);
            return originalRender(h, context);
          };
        } else {
          // inject component registration as beforeCreate hook
          var existing = component.beforeCreate;
          component.beforeCreate = existing ? [].concat(existing, hook) : [hook];
        }
      }
    }

    return component;
  }
  /* style inject */


  function __vue_create_injector__$s() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$s.styles || (__vue_create_injector__$s.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());
    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = {
        ids: [],
        parts: [],
        element: undefined
      });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;
        style.ids.push(id);

        if (css.map) {
          // https://developer.chrome.com/devtools/docs/javascript-debugging
          // this makes source maps inside style tags work properly in Chrome
          code += '\n/*# sourceURL=' + css.map.sources[0] + ' */'; // http://stackoverflow.com/a/26603875

          code += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(css.map)))) + ' */';
        }

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';
          if (css.media) el.setAttribute('media', css.media);

          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */


  var UploadBtn$1 = __vue_normalize__$H({
    render: __vue_render__$H,
    staticRenderFns: __vue_staticRenderFns__$H
  }, __vue_inject_styles__$H, __vue_script__$H, __vue_scope_id__$H, __vue_is_functional_template__$H, __vue_module_identifier__$s, __vue_create_injector__$s);

  //

  function isUploaded$1(url) {
    try {
      return url && new URL(url).protocol === 'storage:';
    } catch (e) {
      return false;
    }
  }

  var script$G = {
    name: 'tailor-asset-input',
    props: {
      url: {
        type: String,
        "default": null
      },
      publicUrl: {
        type: String,
        "default": null
      },
      extensions: {
        type: Array,
        required: true
      },
      allowFileUpload: {
        type: Boolean,
        "default": true
      },
      uploadLabel: {
        type: String,
        "default": 'Select file'
      }
    },
    data: function data() {
      var isLinked = !isUploaded$1(this.url);
      return {
        isEditing: !this.url,
        uploading: false,
        file: isLinked ? null : pick__default['default'](this, ['url', 'publicUrl']),
        urlInput: isLinked ? this.url : null
      };
    },
    computed: {
      hasAsset: function hasAsset(vm) {
        return vm.file || vm.urlInput;
      },
      isLinked: function isLinked(vm) {
        return !!vm.urlInput;
      },
      hasChanges: function hasChanges(vm) {
        return vm.url !== (vm.isLinked ? vm.urlInput : get__default['default'](vm, 'file.url', null));
      },
      fileName: function fileName() {
        if (!this.file) return null;
        return last__default['default'](this.file.url.split('___'));
      }
    },
    methods: {
      save: async function save() {
        if (this.$refs.provider) {
          var _await$this$$refs$pro = await this.$refs.provider.validate(),
              valid = _await$this$$refs$pro.valid;

          if (!valid) return;
        }

        this.isEditing = false;
        var payload = this.file || {
          url: this.urlInput,
          publicUrl: this.urlInput
        };
        this.$emit('input', payload);
      },
      cancel: function cancel() {
        var isLinked = !isUploaded$1(this.url);
        this.urlInput = isLinked ? this.url : null;
        this.file = isLinked ? null : pick__default['default'](this, ['url', 'publicUrl']);
        this.isEditing = !this.url;
      }
    },
    components: {
      UploadBtn: UploadBtn$1
    }
  };

  /* script */
  var __vue_script__$G = script$G;
  /* template */

  var __vue_render__$G = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('v-toolbar-items', [_vm.url && !_vm.isEditing ? _c('v-btn', {
      attrs: {
        "href": _vm.publicUrl || _vm.url,
        "target": "_blank",
        "color": "info",
        "text": ""
      }
    }, [_c('v-icon', [_vm._v("mdi-open-in-new")])], 1) : _vm._e(), _vm._v(" "), _vm.allowFileUpload ? _c('upload-btn', {
      directives: [{
        name: "show",
        rawName: "v-show",
        value: !_vm.file && _vm.isEditing,
        expression: "!file && isEditing"
      }],
      staticClass: "upload-btn",
      attrs: {
        "uploading": _vm.uploading,
        "validate": {
          ext: _vm.extensions
        },
        "confirm-deletion": false,
        "label": _vm.uploadLabel
      },
      on: {
        "upload": function upload(val) {
          return (_vm.file = val) && (_vm.urlInput = null);
        },
        "update:uploading": function updateUploading($event) {
          _vm.uploading = $event;
        }
      }
    }) : _vm._e(), _vm._v(" "), _vm.file ? [_vm.isEditing ? _c('v-btn', {
      attrs: {
        "color": "red",
        "text": ""
      },
      on: {
        "click": function click($event) {
          $event.stopPropagation();
          _vm.file = null;
        }
      }
    }, [_c('v-icon', [_vm._v("mdi-delete")])], 1) : _vm._e(), _vm._v(" "), _c('v-text-field', {
      attrs: {
        "value": _vm.fileName,
        "readonly": "",
        "hide-details": "",
        "filled": ""
      }
    })] : _vm._e(), _vm._v(" "), !_vm.uploading && (_vm.urlInput || !_vm.hasAsset) ? _c('validation-provider', {
      ref: "provider",
      attrs: {
        "rules": {
          url: {
            protocols: ['http', 'https'],
            require_protocol: true,
            require_valid_protocol: true
          }
        },
        "name": "URL"
      },
      scopedSlots: _vm._u([{
        key: "default",
        fn: function fn(ref) {
          var errors = ref.errors;
          return [_c('v-text-field', {
            attrs: {
              "error-messages": errors,
              "disabled": !_vm.isEditing,
              "placeholder": _vm.allowFileUpload ? 'or paste a URL...' : 'Paste a URL...',
              "filled": "",
              "clearable": ""
            },
            model: {
              value: _vm.urlInput,
              callback: function callback($$v) {
                _vm.urlInput = $$v;
              },
              expression: "urlInput"
            }
          })];
        }
      }], null, false, 17370557)
    }) : _vm._e(), _vm._v(" "), !_vm.isEditing ? _c('v-btn', {
      staticClass: "action",
      attrs: {
        "text": ""
      },
      on: {
        "click": function click($event) {
          $event.stopPropagation();
          _vm.isEditing = true;
        }
      }
    }, [_vm._v("\n    Edit\n  ")]) : [_vm.hasChanges ? _c('v-btn', {
      staticClass: "action",
      attrs: {
        "disabled": _vm.uploading,
        "text": ""
      },
      on: {
        "click": function click($event) {
          $event.stopPropagation();
          return _vm.save($event);
        }
      }
    }, [_vm._v("\n      Save\n    ")]) : _vm._e(), _vm._v(" "), _vm.hasChanges || _vm.url ? _c('v-btn', {
      staticClass: "action",
      attrs: {
        "disabled": _vm.uploading,
        "text": ""
      },
      on: {
        "click": function click($event) {
          $event.stopPropagation();
          return _vm.cancel($event);
        }
      }
    }, [_vm._v("\n      Cancel\n    ")]) : _vm._e()]], 2);
  };

  var __vue_staticRenderFns__$G = [];
  /* style */

  var __vue_inject_styles__$G = function __vue_inject_styles__(inject) {
    if (!inject) return;
    inject("data-v-00f47ac8_0", {
      source: ".v-text-field[data-v-00f47ac8]{min-width:21.875rem;margin:.5rem .75rem 0 1.75rem}.action[data-v-00f47ac8]  .v-btn__content{min-width:4rem!important}.upload-btn[data-v-00f47ac8]  .v-btn{height:100%}.upload-btn[data-v-00f47ac8]  .v-btn .v-btn__content{padding:1.5rem 0}",
      map: undefined,
      media: undefined
    });
  };
  /* scoped */


  var __vue_scope_id__$G = "data-v-00f47ac8";
  /* module identifier */

  var __vue_module_identifier__$r = undefined;
  /* functional template */

  var __vue_is_functional_template__$G = false;
  /* component normalizer */

  function __vue_normalize__$G(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "AssetInput.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    {
      var hook;

      if (style) {
        hook = function hook(context) {
          style.call(this, createInjector(context));
        };
      }

      if (hook !== undefined) {
        if (component.functional) {
          // register for functional component in vue file
          var originalRender = component.render;

          component.render = function renderWithStyleInjection(h, context) {
            hook.call(context);
            return originalRender(h, context);
          };
        } else {
          // inject component registration as beforeCreate hook
          var existing = component.beforeCreate;
          component.beforeCreate = existing ? [].concat(existing, hook) : [hook];
        }
      }
    }

    return component;
  }
  /* style inject */


  function __vue_create_injector__$r() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$r.styles || (__vue_create_injector__$r.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());
    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = {
        ids: [],
        parts: [],
        element: undefined
      });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;
        style.ids.push(id);

        if (css.map) {
          // https://developer.chrome.com/devtools/docs/javascript-debugging
          // this makes source maps inside style tags work properly in Chrome
          code += '\n/*# sourceURL=' + css.map.sources[0] + ' */'; // http://stackoverflow.com/a/26603875

          code += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(css.map)))) + ' */';
        }

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';
          if (css.media) el.setAttribute('media', css.media);

          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */


  var AssetInput = __vue_normalize__$G({
    render: __vue_render__$G,
    staticRenderFns: __vue_staticRenderFns__$G
  }, __vue_inject_styles__$G, __vue_script__$G, __vue_scope_id__$G, __vue_is_functional_template__$G, __vue_module_identifier__$r, __vue_create_injector__$r);

  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  var script$F = {
    name: 'date-picker',
    props: {
      value: {
        type: [String, Date],
        "default": null
      },
      label: {
        type: String,
        "default": null
      },
      clearable: {
        type: Boolean,
        "default": true
      },
      placeholder: {
        type: String,
        "default": 'Click to set...'
      }
    },
    data: function data() {
      return {
        showDatePicker: false
      };
    },
    methods: {
      clear: function clear() {
        this.$emit('input', null);
        this.$refs.textField.blur();
      }
    }
  };

  /* script */
  var __vue_script__$F = script$F;
  /* template */

  var __vue_render__$F = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('v-menu', {
      attrs: {
        "close-on-content-click": false,
        "min-width": "290px",
        "transition": "scale-transition"
      },
      scopedSlots: _vm._u([{
        key: "activator",
        fn: function fn(ref) {
          var on = ref.on;
          return [_c('v-text-field', _vm._g({
            ref: "textField",
            attrs: {
              "value": _vm._f("formatDate")(_vm.value, 'MMM D, YYYY'),
              "label": _vm.label,
              "placeholder": _vm.placeholder,
              "clearable": _vm.clearable,
              "outlined": "",
              "readonly": ""
            },
            on: {
              "click:clear": _vm.clear,
              "click": function click($event) {
                _vm.showDatePicker = true;
              }
            }
          }, on))];
        }
      }]),
      model: {
        value: _vm.showDatePicker,
        callback: function callback($$v) {
          _vm.showDatePicker = $$v;
        },
        expression: "showDatePicker"
      }
    }, [_vm._v(" "), _c('v-date-picker', {
      attrs: {
        "value": _vm._f("formatDate")(_vm.value, 'YYYY-MM-DD'),
        "color": "primary darken-2",
        "no-title": ""
      },
      on: {
        "input": function input($event) {
          return _vm.$emit('input', $event);
        },
        "change": function change($event) {
          _vm.showDatePicker = false;
        }
      }
    })], 1);
  };

  var __vue_staticRenderFns__$F = [];
  /* style */

  var __vue_inject_styles__$F = undefined;
  /* scoped */

  var __vue_scope_id__$F = undefined;
  /* functional template */

  var __vue_is_functional_template__$F = false;
  /* component normalizer */

  function __vue_normalize__$F(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "DatePicker.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */

  /* style inject SSR */


  var DatePicker = __vue_normalize__$F({
    render: __vue_render__$F,
    staticRenderFns: __vue_staticRenderFns__$F
  }, __vue_inject_styles__$F, __vue_script__$F, __vue_scope_id__$F, __vue_is_functional_template__$F);

  //
  var CE_FOCUS_EVENT$1 = 'element:focus';
  var script$E = {
    name: 'tailor-element-list',
    props: {
      elements: {
        type: Array,
        "default": function _default() {
          return [];
        }
      },
      dragOptions: {
        type: Object,
        "default": function _default() {
          return {};
        }
      },
      supportedTypes: {
        type: Array,
        "default": null
      },
      activity: {
        type: Object,
        "default": null
      },
      layout: {
        type: Boolean,
        "default": false
      },
      isDisabled: {
        type: Boolean,
        "default": false
      },
      enableAdd: {
        type: Boolean,
        "default": true
      },
      addElementOptions: {
        type: Object,
        "default": function _default() {
          return {};
        }
      }
    },
    data: function data() {
      return {
        dragElementIndex: null
      };
    },
    computed: Object.assign({}, vueRadio.mapChannels({
      editorChannel: 'editor'
    }), {
      options: function options(vm) {
        return Object.assign({}, vm.dragOptions, {
          handle: '.drag-handle'
        });
      }
    }),
    methods: {
      get: get__default['default'],
      getElementId: utils.getElementId,
      onDragStart: function onDragStart(index) {
        this.dragElementIndex = index;
        this.editorChannel.emit(CE_FOCUS_EVENT$1);
      },
      onDragEnd: function onDragEnd(element) {
        this.dragElementIndex = -1;
        this.editorChannel.emit(CE_FOCUS_EVENT$1, element);
      },
      reorder: function reorder(_ref) {
        var newPosition = _ref.newIndex;
        var items = this.elements;
        this.$emit('update', {
          newPosition: newPosition,
          items: items
        });
      }
    },
    components: {
      AddElement: AddElement$1,
      Draggable: Draggable__default['default']
    }
  };

  /* script */
  var __vue_script__$E = script$E;
  /* template */

  var __vue_render__$E = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      staticClass: "list-group"
    }, [_c('draggable', _vm._b({
      staticClass: "row",
      attrs: {
        "list": _vm.elements,
        "disabled": _vm.isDisabled
      },
      on: {
        "start": function start($event) {
          _vm.dragElementIndex = $event.oldIndex;
        },
        "end": function end($event) {
          _vm.dragElementIndex = -1;
        },
        "update": _vm.reorder
      }
    }, 'draggable', _vm.options, false), _vm._l(_vm.elements, function (element, index) {
      return _c('div', {
        key: _vm.getElementId(element),
        staticClass: "pr-5",
        "class": "col-xs-" + _vm.get(element, 'data.width', 12),
        on: {
          "dragstart": function dragstart($event) {
            return _vm.onDragStart(index);
          },
          "dragend": function dragend($event) {
            return _vm.onDragEnd(element);
          }
        }
      }, [_vm._t("list-item", null, {
        "element": element,
        "isDragged": _vm.dragElementIndex === index,
        "position": index
      })], 2);
    }), 0), _vm._v(" "), _vm.enableAdd && !_vm.isDisabled ? [_vm._t("list-add", [_c('add-element', {
      staticClass: "mt-1",
      attrs: {
        "items": _vm.elements,
        "include": _vm.supportedTypes,
        "activity": _vm.activity,
        "label": _vm.addElementOptions.label,
        "large": _vm.addElementOptions.large,
        "position": _vm.elements.length,
        "layout": _vm.layout
      },
      on: {
        "add": function add($event) {
          return _vm.$emit('add', $event);
        }
      }
    })], {
      "include": _vm.supportedTypes,
      "activity": _vm.activity,
      "position": _vm.elements.length,
      "layout": _vm.layout
    })] : _vm._e()], 2);
  };

  var __vue_staticRenderFns__$E = [];
  /* style */

  var __vue_inject_styles__$E = function __vue_inject_styles__(inject) {
    if (!inject) return;
    inject("data-v-f18f3e56_0", {
      source: ".list-group[data-v-f18f3e56]{padding:.625rem 1.5rem}[data-v-f18f3e56] .sortable-ghost .drag-handle{display:none}[data-v-f18f3e56] .sortable-ghost .content-element{max-height:9.375rem;background:#f4f5f5}[data-v-f18f3e56] .sortable-ghost .content-element>*{visibility:hidden}[data-v-f18f3e56] .sortable-drag .content-element{max-height:auto;background:#fff}",
      map: undefined,
      media: undefined
    });
  };
  /* scoped */


  var __vue_scope_id__$E = "data-v-f18f3e56";
  /* module identifier */

  var __vue_module_identifier__$q = undefined;
  /* functional template */

  var __vue_is_functional_template__$E = false;
  /* component normalizer */

  function __vue_normalize__$E(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "ElementList.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    {
      var hook;

      if (style) {
        hook = function hook(context) {
          style.call(this, createInjector(context));
        };
      }

      if (hook !== undefined) {
        if (component.functional) {
          // register for functional component in vue file
          var originalRender = component.render;

          component.render = function renderWithStyleInjection(h, context) {
            hook.call(context);
            return originalRender(h, context);
          };
        } else {
          // inject component registration as beforeCreate hook
          var existing = component.beforeCreate;
          component.beforeCreate = existing ? [].concat(existing, hook) : [hook];
        }
      }
    }

    return component;
  }
  /* style inject */


  function __vue_create_injector__$q() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$q.styles || (__vue_create_injector__$q.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());
    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = {
        ids: [],
        parts: [],
        element: undefined
      });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;
        style.ids.push(id);

        if (css.map) {
          // https://developer.chrome.com/devtools/docs/javascript-debugging
          // this makes source maps inside style tags work properly in Chrome
          code += '\n/*# sourceURL=' + css.map.sources[0] + ' */'; // http://stackoverflow.com/a/26603875

          code += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(css.map)))) + ' */';
        }

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';
          if (css.media) el.setAttribute('media', css.media);

          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */


  var ElementList$1 = __vue_normalize__$E({
    render: __vue_render__$E,
    staticRenderFns: __vue_staticRenderFns__$E
  }, __vue_inject_styles__$E, __vue_script__$E, __vue_scope_id__$E, __vue_is_functional_template__$E, __vue_module_identifier__$q, __vue_create_injector__$q);

  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  var script$D = {
    name: 'tailor-element-placeholder',
    props: {
      name: {
        type: String,
        required: true
      },
      icon: {
        type: String,
        required: true
      },
      placeholder: {
        type: String,
        "default": 'Select to edit'
      },
      activePlaceholder: {
        type: String,
        "default": 'Use toolbar to edit'
      },
      activeIcon: {
        type: String,
        "default": null
      },
      activeColor: {
        type: String,
        "default": '#fff'
      },
      isDisabled: {
        type: Boolean,
        "default": false
      },
      isFocused: {
        type: Boolean,
        "default": false
      },
      dense: {
        type: Boolean,
        "default": false
      }
    },
    computed: {
      iconSize: function iconSize() {
        if (this.dense) return this.isFocused ? 24 : 20;
        return this.isFocused ? 38 : 30;
      }
    }
  };

  /* script */
  var __vue_script__$D = script$D;
  /* template */

  var __vue_render__$D = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('v-sheet', {
      staticClass: "transparent grey--text text--darken-4",
      "class": _vm.dense ? 'pt-3' : 'pa-12'
    }, [_c('v-avatar', {
      attrs: {
        "size": _vm.dense ? 40 : 60,
        "color": _vm.isDisabled ? 'grey darken-3' : 'primary darken-4'
      }
    }, [_c('v-icon', {
      attrs: {
        "size": _vm.iconSize,
        "color": _vm.isFocused ? _vm.activeColor : '#fff'
      }
    }, [_vm._v("\n      " + _vm._s(_vm.icon) + "\n    ")])], 1), _vm._v(" "), _c('div', {
      staticClass: "grey--text",
      "class": [_vm.isDisabled ? 'text--darken-3' : 'text--darken-4', _vm.dense ? 'my-2 subtitle-2' : 'my-4 headline']
    }, [_vm._v("\n    " + _vm._s(_vm.name) + "\n  ")]), _vm._v(" "), !_vm.dense && !_vm.isDisabled ? _c('div', {
      staticClass: "subtitle-1"
    }, [!_vm.isFocused ? [_vm._v(_vm._s(_vm.placeholder))] : [_c('span', [_vm._v(_vm._s(_vm.activePlaceholder))]), _vm._v(" "), _vm.activeIcon ? _c('v-icon', {
      attrs: {
        "size": "20",
        "color": "primary darken-4"
      }
    }, [_vm._v("\n        " + _vm._s(_vm.activeIcon) + "\n      ")]) : _vm._e()]], 2) : _vm._e()], 1);
  };

  var __vue_staticRenderFns__$D = [];
  /* style */

  var __vue_inject_styles__$D = undefined;
  /* scoped */

  var __vue_scope_id__$D = undefined;
  /* functional template */

  var __vue_is_functional_template__$D = false;
  /* component normalizer */

  function __vue_normalize__$D(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "ElementPlaceholder.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */

  /* style inject SSR */


  var ElementPlaceholder = __vue_normalize__$D({
    render: __vue_render__$D,
    staticRenderFns: __vue_staticRenderFns__$D
  }, __vue_inject_styles__$D, __vue_script__$D, __vue_scope_id__$D, __vue_is_functional_template__$D);

  var script$C = {
    name: 'tailor-embedded-container',
    inheritAttrs: false,
    props: {
      container: {
        type: Object,
        required: true
      },
      types: {
        type: Array,
        "default": function _default() {
          return ['JODIT_HTML', 'IMAGE', 'HTML', 'VIDEO'];
        }
      },
      isDisabled: {
        type: Boolean,
        "default": false
      },
      addElementOptions: {
        type: Object,
        "default": function _default() {
          return {};
        }
      },
      enableAdd: {
        type: Boolean,
        "default": true
      }
    },
    computed: {
      embeds: function embeds() {
        var items = this.container.embeds;
        return items ? values__default['default'](items).sort(function (a, b) {
          return a.position - b.position;
        }) : [];
      }
    },
    methods: Object.assign({}, vueRadio.mapRequests('app', ['showConfirmationModal']), {
      addItems: function addItems(items) {
        items = Array.isArray(items) ? items : [items];
        var container = cloneDeep__default['default'](this.container);
        container.embeds = Object.assign({}, container.embeds, mapKeys__default['default'](items, 'id'));
        this.$emit('save', container);
      },
      reorderItem: function reorderItem(_ref) {
        var newPosition = _ref.newPosition,
            items = _ref.items;
        var context = {
          items: items,
          newPosition: newPosition
        };
        var container = cloneDeep__default['default'](this.container);
        var reordered = container.embeds[items[newPosition].id];
        reordered.position = utils.calculatePosition(context);
        this.$emit('save', container);
      },
      save: function save(item, key, value) {
        var container = cloneDeep__default['default'](this.container);
        container.embeds[item.id] = Object.assign({}, item, _defineProperty$1({}, key, value));
        this.$emit('save', container);
      },
      requestDeleteConfirmation: function requestDeleteConfirmation(element) {
        var _this = this;

        this.showConfirmationModal({
          title: 'Delete element?',
          message: 'Are you sure you want to delete element?',
          action: function action() {
            return _this.$emit('delete', element);
          }
        });
      }
    }),
    components: {
      ContainedContent: ContainedContent$1,
      ElementList: ElementList$1
    }
  };

  /* script */
  var __vue_script__$C = script$C;
  /* template */

  var __vue_render__$C = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('element-list', {
      attrs: {
        "add-element-options": _vm.addElementOptions,
        "elements": _vm.embeds,
        "supported-types": _vm.types,
        "enable-add": !_vm.isDisabled && _vm.enableAdd
      },
      on: {
        "add": _vm.addItems,
        "update": _vm.reorderItem
      },
      scopedSlots: _vm._u([{
        key: "list-item",
        fn: function fn(ref) {
          var element = ref.element;
          var isDragged = ref.isDragged;
          return [_c('contained-content', _vm._b({
            staticClass: "my-2",
            attrs: {
              "element": element,
              "is-dragged": isDragged,
              "is-disabled": _vm.isDisabled
            },
            on: {
              "save": function save($event) {
                return _vm.save(element, 'data', $event);
              },
              "save:meta": function saveMeta($event) {
                return _vm.save(element, 'meta', $event);
              },
              "delete": function _delete($event) {
                return _vm.requestDeleteConfirmation(element);
              }
            }
          }, 'contained-content', _vm.$attrs, false))];
        }
      }])
    });
  };

  var __vue_staticRenderFns__$C = [];
  /* style */

  var __vue_inject_styles__$C = undefined;
  /* scoped */

  var __vue_scope_id__$C = undefined;
  /* functional template */

  var __vue_is_functional_template__$C = false;
  /* component normalizer */

  function __vue_normalize__$C(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "EmbeddedContainer.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */

  /* style inject SSR */


  var EmbeddedContainer = __vue_normalize__$C({
    render: __vue_render__$C,
    staticRenderFns: __vue_staticRenderFns__$C
  }, __vue_inject_styles__$C, __vue_script__$C, __vue_scope_id__$C, __vue_is_functional_template__$C);

  var script$A = {
    name: 'tailor-active-users',
    props: {
      users: {
        type: Array,
        "default": function _default() {
          return [];
        }
      },
      size: {
        type: Number,
        "default": 36
      }
    },
    filters: {
      capitalize: capitalize__default['default']
    }
  };
  /* script */

  var __vue_script__$A = script$A;
  /* template */

  var __vue_render__$A = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      staticClass: "d-flex align-center"
    }, _vm._l(_vm.users, function (ref) {
      var id = ref.id;
      var label = ref.label;
      var imgUrl = ref.imgUrl;
      return _c('v-avatar', {
        key: id,
        staticClass: "avatar",
        attrs: {
          "size": _vm.size,
          "color": "pink accent-2"
        }
      }, [_c('v-tooltip', {
        attrs: {
          "bottom": ""
        },
        scopedSlots: _vm._u([{
          key: "activator",
          fn: function fn(ref) {
            var on = ref.on;
            return [imgUrl ? _c('img', _vm._g({
              attrs: {
                "src": imgUrl,
                "alt": label,
                "aria-describedby": "activeUser-" + id,
                "tabindex": "0"
              }
            }, on)) : _vm._e()];
          }
        }], null, true)
      }, [_vm._v(" "), _c('span', {
        attrs: {
          "id": "activeUser-" + id
        }
      }, [_vm._v(_vm._s(label))])])], 1);
    }), 1);
  };

  var __vue_staticRenderFns__$A = [];
  /* style */

  var __vue_inject_styles__$A = function __vue_inject_styles__(inject) {
    if (!inject) return;
    inject("data-v-33d463d4_0", {
      source: ".avatar[data-v-33d463d4]{transition:all .2s}.avatar img[data-v-33d463d4]{padding:.125rem}.avatar[data-v-33d463d4]:focus-within,.avatar[data-v-33d463d4]:hover{transform:scale(1.1);z-index:1}.avatar:focus-within img[data-v-33d463d4]:focus,.avatar:hover img[data-v-33d463d4]:focus{outline:0}",
      map: undefined,
      media: undefined
    });
  };
  /* scoped */


  var __vue_scope_id__$A = "data-v-33d463d4";
  /* module identifier */

  var __vue_module_identifier__$o = undefined;
  /* functional template */

  var __vue_is_functional_template__$A = false;
  /* component normalizer */

  function __vue_normalize__$A(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "ActiveUsers.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;
    {
      var hook;

      if (style) {
        hook = function hook(context) {
          style.call(this, createInjector(context));
        };
      }

      if (hook !== undefined) {
        if (component.functional) {
          // register for functional component in vue file
          var originalRender = component.render;

          component.render = function renderWithStyleInjection(h, context) {
            hook.call(context);
            return originalRender(h, context);
          };
        } else {
          // inject component registration as beforeCreate hook
          var existing = component.beforeCreate;
          component.beforeCreate = existing ? [].concat(existing, hook) : [hook];
        }
      }
    }
    return component;
  }
  /* style inject */


  function __vue_create_injector__$o() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$o.styles || (__vue_create_injector__$o.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());
    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = {
        ids: [],
        parts: [],
        element: undefined
      });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;
        style.ids.push(id);

        if (css.map) {
          // https://developer.chrome.com/devtools/docs/javascript-debugging
          // this makes source maps inside style tags work properly in Chrome
          code += '\n/*# sourceURL=' + css.map.sources[0] + ' */'; // http://stackoverflow.com/a/26603875

          code += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(css.map)))) + ' */';
        }

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';
          if (css.media) el.setAttribute('media', css.media);

          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */


  var ActiveUsers = __vue_normalize__$A({
    render: __vue_render__$A,
    staticRenderFns: __vue_staticRenderFns__$A
  }, __vue_inject_styles__$A, __vue_script__$A, __vue_scope_id__$A, __vue_is_functional_template__$A, __vue_module_identifier__$o, __vue_create_injector__$o); //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //


  var script$z = {
    name: 'add-new-element',
    props: {
      library: {
        type: Array,
        required: true
      },
      allowedTypes: {
        type: Array,
        required: true
      }
    },
    methods: {
      isAllowed: function isAllowed(type) {
        return !this.allowedTypes.length || this.allowedTypes.includes(type);
      }
    }
  };
  /* script */

  var __vue_script__$z = script$z;
  /* template */

  var __vue_render__$z = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('v-bottom-sheet', _vm._g(_vm._b({
      attrs: {
        "max-width": "1240",
        "inset": ""
      }
    }, 'v-bottom-sheet', _vm.$attrs, false), _vm.$listeners), [_c('div', {
      staticClass: "element-container grey lighten-5"
    }, [_c('div', {
      staticClass: "d-flex align-center py-4 px-10"
    }, [_vm._t("header")], 2), _vm._v(" "), _vm._l(_vm.library, function (group) {
      return _c('div', {
        key: group.name
      }, [_c('div', {
        staticClass: "group-heading grey--text text--darken-4"
      }, [_vm._v(_vm._s(group.name))]), _vm._v(" "), _c('div', {
        staticClass: "group-elements"
      }, _vm._l(group.elements, function (element) {
        return _c('v-hover', {
          key: element.position,
          scopedSlots: _vm._u([{
            key: "default",
            fn: function fn(ref) {
              var hover = ref.hover;
              return [_c('v-btn', {
                staticClass: "add-element",
                attrs: {
                  "disabled": !_vm.isAllowed(element.type),
                  "color": hover ? 'secondary accent-2' : 'blue-grey darken-4',
                  "text": ""
                },
                on: {
                  "click": function click($event) {
                    $event.stopPropagation();
                    return _vm.$emit('add', [element]);
                  }
                }
              }, [element.ui.icon ? _c('v-icon', {
                attrs: {
                  "size": "26",
                  "color": "primary darken-3"
                }
              }, [_vm._v("\n              " + _vm._s(element.ui.icon) + "\n            ")]) : _vm._e(), _vm._v(" "), _c('span', {
                staticClass: "button-text body-2"
              }, [_vm._v(_vm._s(element.name))])], 1)];
            }
          }], null, true)
        });
      }), 1)]);
    })], 2)]);
  };

  var __vue_staticRenderFns__$z = [];
  /* style */

  var __vue_inject_styles__$z = function __vue_inject_styles__(inject) {
    if (!inject) return;
    inject("data-v-5e4d908e_0", {
      source: ".element-container[data-v-5e4d908e]{min-height:20rem;padding:0 0 1.875rem;border-top-left-radius:.5rem;border-top-right-radius:.5rem;overflow:hidden}.group-heading[data-v-5e4d908e]{margin:0 2.5rem .375rem;padding-top:.5rem;font-size:.875rem;font-weight:500;line-height:1rem;text-align:left}.group-elements[data-v-5e4d908e]{display:flex;flex-wrap:wrap;width:100%;padding:0 1.875rem}.add-element[data-v-5e4d908e]{width:8.125rem;min-width:8.125rem;height:auto!important;min-height:4.375rem;padding:0!important;white-space:normal}.add-element[data-v-5e4d908e]  .v-btn__content{flex:1 1 100%;flex-direction:column;padding:.375rem;text-transform:none}.add-element .v-icon[data-v-5e4d908e]{padding:.125rem 0;font-size:1.875rem}.add-element .button-text[data-v-5e4d908e]{margin:.625rem 0}",
      map: undefined,
      media: undefined
    });
  };
  /* scoped */


  var __vue_scope_id__$z = "data-v-5e4d908e";
  /* module identifier */

  var __vue_module_identifier__$n = undefined;
  /* functional template */

  var __vue_is_functional_template__$z = false;
  /* component normalizer */

  function __vue_normalize__$z(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "AddNewElement.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;
    {
      var hook;

      if (style) {
        hook = function hook(context) {
          style.call(this, createInjector(context));
        };
      }

      if (hook !== undefined) {
        if (component.functional) {
          // register for functional component in vue file
          var originalRender = component.render;

          component.render = function renderWithStyleInjection(h, context) {
            hook.call(context);
            return originalRender(h, context);
          };
        } else {
          // inject component registration as beforeCreate hook
          var existing = component.beforeCreate;
          component.beforeCreate = existing ? [].concat(existing, hook) : [hook];
        }
      }
    }
    return component;
  }
  /* style inject */


  function __vue_create_injector__$n() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$n.styles || (__vue_create_injector__$n.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());
    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = {
        ids: [],
        parts: [],
        element: undefined
      });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;
        style.ids.push(id);

        if (css.map) {
          // https://developer.chrome.com/devtools/docs/javascript-debugging
          // this makes source maps inside style tags work properly in Chrome
          code += '\n/*# sourceURL=' + css.map.sources[0] + ' */'; // http://stackoverflow.com/a/26603875

          code += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(css.map)))) + ' */';
        }

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';
          if (css.media) el.setAttribute('media', css.media);

          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */


  var AddNewElement = __vue_normalize__$z({
    render: __vue_render__$z,
    staticRenderFns: __vue_staticRenderFns__$z
  }, __vue_inject_styles__$z, __vue_script__$z, __vue_scope_id__$z, __vue_is_functional_template__$z, __vue_module_identifier__$n, __vue_create_injector__$n);

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
  }

  function _iterableToArrayLimit(arr, i) {
    if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  } //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //


  var script$y = {
    name: 'tailor-editor-link',
    props: {
      activityId: {
        type: Number,
        required: true
      },
      elementUid: {
        type: String,
        "default": null
      },
      label: {
        type: String,
        required: true
      }
    },
    computed: {
      editorRoute: function editorRoute(_ref) {
        var activityId = _ref.activityId,
            elementUid = _ref.elementUid;
        return Object.assign({
          name: 'editor',
          params: {
            activityId: activityId
          }
        }, elementUid && {
          query: {
            elementId: elementUid
          }
        });
      }
    }
  };
  /* script */

  var __vue_script__$y = script$y;
  /* template */

  var __vue_render__$y = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      staticClass: "editor-link"
    }, [_c('v-tooltip', {
      attrs: {
        "right": ""
      },
      scopedSlots: _vm._u([{
        key: "activator",
        fn: function fn(ref) {
          var on = ref.on;
          return [_c('router-link', {
            attrs: {
              "to": _vm.editorRoute
            },
            scopedSlots: _vm._u([{
              key: "default",
              fn: function fn(ref) {
                var navigate = ref.navigate;
                var isExactActive = ref.isExactActive;
                return [_c('v-btn', _vm._g(_vm._b({
                  attrs: {
                    "color": isExactActive ? 'teal accent-4' : 'primary',
                    "text": "",
                    "x-small": ""
                  },
                  on: {
                    "click": navigate
                  }
                }, 'v-btn', _vm.$attrs, false), on), [_vm._v("\n          " + _vm._s(_vm.label) + "\n          "), _vm._t("icon", [_c('v-icon', {
                  staticClass: "ml-1",
                  attrs: {
                    "x-small": ""
                  }
                }, [_vm._v("mdi-arrow-top-right-thick")])])], 2)];
              }
            }], null, true)
          })];
        }
      }])
    }, [_vm._v(" "), _vm._t("tooltip", [_c('span', [_vm._v("View element")])])], 2)], 1);
  };

  var __vue_staticRenderFns__$y = [];
  /* style */

  var __vue_inject_styles__$y = undefined;
  /* scoped */

  var __vue_scope_id__$y = undefined;
  /* functional template */

  var __vue_is_functional_template__$y = false;
  /* component normalizer */

  function __vue_normalize__$y(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "EditorLink.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;
    return component;
  }
  /* style inject */

  /* style inject SSR */


  var EditorLink = __vue_normalize__$y({
    render: __vue_render__$y,
    staticRenderFns: __vue_staticRenderFns__$y
  }, __vue_inject_styles__$y, __vue_script__$y, __vue_scope_id__$y, __vue_is_functional_template__$y); //


  var getOptions = function getOptions() {
    return {
      resolve: {
        action: 'resolve',
        icon: 'check-box-outline',
        color: 'teal accent-4'
      },
      edit: {
        action: 'toggleEdit',
        icon: 'pencil-outline',
        color: 'grey'
      },
      remove: {
        action: 'remove',
        icon: 'trash-can-outline',
        color: 'grey'
      }
    };
  };

  var script$x = {
    name: 'comment-header',
    props: {
      comment: {
        type: Object,
        required: true
      },
      isActivityThread: {
        type: Boolean,
        "default": false
      },
      isResolved: {
        type: Boolean,
        "default": false
      },
      elementLabel: {
        type: String,
        "default": null
      },
      user: {
        type: Object,
        required: true
      }
    },
    computed: {
      elementUid: function elementUid(vm) {
        return vm.comment.contentElement.uid;
      },
      author: function author(vm) {
        return vm.comment.author;
      },
      isAuthor: function isAuthor(vm) {
        return vm.author.id === vm.user.id;
      },
      isDeleted: function isDeleted(vm) {
        return !!vm.comment.deletedAt;
      },
      showEditedLabel: function showEditedLabel(vm) {
        return !!vm.comment.editedAt;
      },
      showOptions: function showOptions(vm) {
        return vm.isAuthor && !vm.isDeleted && !vm.isResolved;
      },
      options: function options() {
        var options = getOptions();
        if (this.isActivityThread) delete options.resolve;
        return options;
      }
    },
    components: {
      EditorLink: EditorLink
    }
  };
  /* script */

  var __vue_script__$x = script$x;
  /* template */

  var __vue_render__$x = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      staticClass: "header"
    }, [_c('v-avatar', {
      staticClass: "comment-avatar",
      attrs: {
        "size": "34"
      }
    }, [_c('img', {
      attrs: {
        "src": _vm.author.imgUrl
      }
    })]), _vm._v(" "), _c('div', {
      staticClass: "info-container"
    }, [_c('div', {
      staticClass: "d-flex align-center"
    }, [_c('v-tooltip', {
      attrs: {
        "right": ""
      },
      scopedSlots: _vm._u([{
        key: "activator",
        fn: function fn(ref) {
          var on = ref.on;
          return [_c('span', _vm._g({
            staticClass: "author text-truncate"
          }, on), [_vm._v(_vm._s(_vm.author.label))])];
        }
      }])
    }, [_vm._v("\n        " + _vm._s(_vm.author.label) + "\n      ")]), _vm._v(" "), _vm.showEditedLabel ? _c('span', {
      staticClass: "edited ml-1"
    }, [_vm._v("(edited)")]) : _vm._e()], 1), _vm._v(" "), _c('div', {
      staticClass: "d-flex align-center"
    }, [_c('v-tooltip', {
      attrs: {
        "right": ""
      },
      scopedSlots: _vm._u([{
        key: "activator",
        fn: function fn(ref) {
          var on = ref.on;
          return [_c('span', _vm._g({}, on), [_c('timeago', {
            staticClass: "time",
            attrs: {
              "datetime": _vm.comment.createdAt,
              "auto-update": 60
            }
          })], 1)];
        }
      }])
    }, [_vm._v(" "), _c('span', [_vm._v(_vm._s(_vm._f("formatDate")(_vm.comment.createdAt, 'DD. MMM h:mm A')))])]), _vm._v(" "), _vm.isActivityThread && _vm.elementLabel ? [_c('v-divider', {
      attrs: {
        "vertical": ""
      }
    }), _vm._v(" "), _c('editor-link', {
      attrs: {
        "activity-id": _vm.comment.activityId,
        "element-uid": _vm.elementUid,
        "label": _vm.elementLabel
      }
    })] : _vm._e()], 2)]), _vm._v(" "), _vm.showOptions ? _c('div', {
      staticClass: "actions"
    }, _vm._l(_vm.options, function (ref, name) {
      var action = ref.action;
      var icon = ref.icon;
      var color = ref.color;
      return _c('v-btn', {
        key: name,
        staticClass: "ml-1",
        attrs: {
          "x-small": "",
          "icon": ""
        },
        on: {
          "click": function click($event) {
            return _vm.$emit(action);
          }
        }
      }, [_c('v-icon', {
        attrs: {
          "color": color,
          "size": "14"
        }
      }, [_vm._v(" mdi-" + _vm._s(icon))])], 1);
    }), 1) : _vm._e()], 1);
  };

  var __vue_staticRenderFns__$x = [];
  /* style */

  var __vue_inject_styles__$x = function __vue_inject_styles__(inject) {
    if (!inject) return;
    inject("data-v-a1e0c4e8_0", {
      source: ".header[data-v-a1e0c4e8]{display:flex;align-items:flex-start}.header .comment-avatar[data-v-a1e0c4e8]{margin:.375rem .375rem 0 0}.header .info-container[data-v-a1e0c4e8]{display:flex;flex-direction:column;flex:0 100%;max-width:calc(100% - 8rem);margin-left:.125rem}.header .info-container .author[data-v-a1e0c4e8]{display:inline-block;max-width:75%;color:#000;font-size:1rem}.header .info-container .edited[data-v-a1e0c4e8],.header .info-container .time[data-v-a1e0c4e8]{color:#888;font-size:.75rem}.header .info-container hr.v-divider--vertical[data-v-a1e0c4e8]{margin:.25rem .125rem .125rem .625rem}.header .info-container[data-v-a1e0c4e8]  .editor-link{display:inline-flex;align-self:flex-end}.header .actions[data-v-a1e0c4e8]{margin-left:auto}",
      map: undefined,
      media: undefined
    });
  };
  /* scoped */


  var __vue_scope_id__$x = "data-v-a1e0c4e8";
  /* module identifier */

  var __vue_module_identifier__$m = undefined;
  /* functional template */

  var __vue_is_functional_template__$x = false;
  /* component normalizer */

  function __vue_normalize__$x(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "Header.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;
    {
      var hook;

      if (style) {
        hook = function hook(context) {
          style.call(this, createInjector(context));
        };
      }

      if (hook !== undefined) {
        if (component.functional) {
          // register for functional component in vue file
          var originalRender = component.render;

          component.render = function renderWithStyleInjection(h, context) {
            hook.call(context);
            return originalRender(h, context);
          };
        } else {
          // inject component registration as beforeCreate hook
          var existing = component.beforeCreate;
          component.beforeCreate = existing ? [].concat(existing, hook) : [hook];
        }
      }
    }
    return component;
  }
  /* style inject */


  function __vue_create_injector__$m() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$m.styles || (__vue_create_injector__$m.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());
    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = {
        ids: [],
        parts: [],
        element: undefined
      });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;
        style.ids.push(id);

        if (css.map) {
          // https://developer.chrome.com/devtools/docs/javascript-debugging
          // this makes source maps inside style tags work properly in Chrome
          code += '\n/*# sourceURL=' + css.map.sources[0] + ' */'; // http://stackoverflow.com/a/26603875

          code += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(css.map)))) + ' */';
        }

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';
          if (css.media) el.setAttribute('media', css.media);

          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */


  var CommentHeader = __vue_normalize__$x({
    render: __vue_render__$x,
    staticRenderFns: __vue_staticRenderFns__$x
  }, __vue_inject_styles__$x, __vue_script__$x, __vue_scope_id__$x, __vue_is_functional_template__$x, __vue_module_identifier__$m, __vue_create_injector__$m); //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //


  var script$w = {
    name: 'comment-preview',
    props: {
      content: {
        type: String,
        "default": ''
      },
      isResolved: {
        type: Boolean,
        "default": false
      }
    }
  };
  /* script */

  var __vue_script__$w = script$w;
  /* template */

  var __vue_render__$w = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      staticClass: "content",
      "class": {
        resolved: _vm.isResolved
      }
    }, [_vm.isResolved ? _c('div', {
      staticClass: "resolvement-options"
    }, [_c('span', {
      staticClass: "font-italic mr-1"
    }, [_vm._v("Marked as resolved.")]), _vm._v(" "), _c('v-tooltip', {
      attrs: {
        "open-delay": "800",
        "right": ""
      },
      scopedSlots: _vm._u([{
        key: "activator",
        fn: function fn(ref) {
          var on = ref.on;
          return [_c('v-btn', _vm._g({
            attrs: {
              "color": "secondary",
              "text": "",
              "x-small": ""
            },
            on: {
              "click": _vm.$listeners.unresolve
            }
          }, on), [_vm._v("\n          Undo\n        ")])];
        }
      }], null, false, 3181083862)
    }, [_vm._v(" "), _c('span', [_vm._v("Unresolve comment")])])], 1) : _vm._e(), _vm._v(" "), _c('pre', [_c('span', [_vm._v(_vm._s(_vm.content))]), _c('br')])]);
  };

  var __vue_staticRenderFns__$w = [];
  /* style */

  var __vue_inject_styles__$w = function __vue_inject_styles__(inject) {
    if (!inject) return;
    inject("data-v-3d625308_0", {
      source: ".content[data-v-3d625308]{margin-top:.375rem}.content pre[data-v-3d625308]{height:100%;margin:0;padding:0 .25rem .5rem 0;font:inherit;white-space:pre-wrap;word-break:break-all;word-wrap:break-word;overflow-wrap:break-word;background:inherit;border:none;overflow:hidden}.content.resolved[data-v-3d625308]{opacity:.7}.content.resolved .resolvement-options[data-v-3d625308]{display:flex;align-items:center;margin-bottom:.25rem;font-size:.75rem}",
      map: undefined,
      media: undefined
    });
  };
  /* scoped */


  var __vue_scope_id__$w = "data-v-3d625308";
  /* module identifier */

  var __vue_module_identifier__$l = undefined;
  /* functional template */

  var __vue_is_functional_template__$w = false;
  /* component normalizer */

  function __vue_normalize__$w(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "Preview.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;
    {
      var hook;

      if (style) {
        hook = function hook(context) {
          style.call(this, createInjector(context));
        };
      }

      if (hook !== undefined) {
        if (component.functional) {
          // register for functional component in vue file
          var originalRender = component.render;

          component.render = function renderWithStyleInjection(h, context) {
            hook.call(context);
            return originalRender(h, context);
          };
        } else {
          // inject component registration as beforeCreate hook
          var existing = component.beforeCreate;
          component.beforeCreate = existing ? [].concat(existing, hook) : [hook];
        }
      }
    }
    return component;
  }
  /* style inject */


  function __vue_create_injector__$l() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$l.styles || (__vue_create_injector__$l.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());
    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = {
        ids: [],
        parts: [],
        element: undefined
      });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;
        style.ids.push(id);

        if (css.map) {
          // https://developer.chrome.com/devtools/docs/javascript-debugging
          // this makes source maps inside style tags work properly in Chrome
          code += '\n/*# sourceURL=' + css.map.sources[0] + ' */'; // http://stackoverflow.com/a/26603875

          code += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(css.map)))) + ' */';
        }

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';
          if (css.media) el.setAttribute('media', css.media);

          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */


  var CommentPreview = __vue_normalize__$w({
    render: __vue_render__$w,
    staticRenderFns: __vue_staticRenderFns__$w
  }, __vue_inject_styles__$w, __vue_script__$w, __vue_scope_id__$w, __vue_is_functional_template__$w, __vue_module_identifier__$l, __vue_create_injector__$l); //


  var script$v = {
    name: 'thread-comment',
    props: {
      comment: {
        type: Object,
        required: true
      },
      isActivityThread: {
        type: Boolean,
        "default": false
      },
      elementLabel: {
        type: String,
        "default": null
      },
      user: {
        type: Object,
        required: true
      }
    },
    data: function data(vm) {
      return {
        content: vm.comment.content,
        isEditing: false
      };
    },
    computed: {
      isResolved: function isResolved(_ref) {
        var comment = _ref.comment;
        return !!comment.resolvedAt;
      }
    },
    methods: {
      toggleEdit: function toggleEdit() {
        this.isEditing = !this.isEditing;
      },
      save: function save() {
        var comment = this.comment,
            content = this.content;
        if (!content) return this.remove();
        this.toggleEdit();
        this.$emit('update', comment, content);
      },
      remove: function remove() {
        this.$emit('remove', this.comment);
      },
      reset: function reset() {
        this.content = this.comment.content;
        this.isEditing = false;
      }
    },
    watch: {
      comment: {
        deep: true,
        handler: 'reset'
      }
    },
    components: {
      CommentHeader: CommentHeader,
      CommentPreview: CommentPreview
    }
  };
  /* script */

  var __vue_script__$v = script$v;
  /* template */

  var __vue_render__$v = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      staticClass: "comment"
    }, [_c('comment-header', _vm._b({
      on: {
        "toggleEdit": _vm.toggleEdit,
        "remove": _vm.remove,
        "resolve": function resolve($event) {
          return _vm.$emit('resolve', _vm.comment);
        }
      }
    }, 'comment-header', {
      comment: _vm.comment,
      isActivityThread: _vm.isActivityThread,
      isResolved: _vm.isResolved,
      elementLabel: _vm.elementLabel,
      user: _vm.user
    }, false)), _vm._v(" "), _c('div', {
      staticClass: "comment-body"
    }, [!_vm.isEditing ? _c('comment-preview', _vm._b({
      on: {
        "unresolve": function unresolve($event) {
          return _vm.$emit('unresolve', _vm.comment);
        }
      }
    }, 'comment-preview', {
      content: _vm.content,
      isResolved: _vm.isResolved
    }, false)) : [_c('v-textarea', {
      staticClass: "comment-editor",
      attrs: {
        "rows": "3",
        "autofocus": "",
        "outlined": "",
        "auto-grow": "",
        "clearable": "",
        "counter": ""
      },
      model: {
        value: _vm.content,
        callback: function callback($$v) {
          _vm.content = typeof $$v === 'string' ? $$v.trim() : $$v;
        },
        expression: "content"
      }
    }), _vm._v(" "), _c('span', {
      staticClass: "d-flex justify-end"
    }, [_c('v-btn', {
      attrs: {
        "text": "",
        "small": ""
      },
      on: {
        "click": _vm.reset
      }
    }, [_vm._v("Cancel")]), _vm._v(" "), _c('v-btn', {
      attrs: {
        "color": "green",
        "text": "",
        "small": ""
      },
      on: {
        "click": _vm.save
      }
    }, [_c('v-icon', {
      staticClass: "pr-1"
    }, [_vm._v("mdi-check")]), _vm._v(" Save\n        ")], 1)], 1)]], 2)], 1);
  };

  var __vue_staticRenderFns__$v = [];
  /* style */

  var __vue_inject_styles__$v = function __vue_inject_styles__(inject) {
    if (!inject) return;
    inject("data-v-3d04e7dc_0", {
      source: ".comment[data-v-3d04e7dc]{display:flex;flex-direction:column;font-family:Roboto,Arial,sans-serif}.comment-body[data-v-3d04e7dc]{flex:1;padding:0 .25rem 0 2.625rem}.comment-editor.v-textarea[data-v-3d04e7dc]{margin:.75rem 0 0 0}.comment-editor.v-textarea[data-v-3d04e7dc]  .v-input__slot{width:auto}",
      map: undefined,
      media: undefined
    });
  };
  /* scoped */


  var __vue_scope_id__$v = "data-v-3d04e7dc";
  /* module identifier */

  var __vue_module_identifier__$k = undefined;
  /* functional template */

  var __vue_is_functional_template__$v = false;
  /* component normalizer */

  function __vue_normalize__$v(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "index.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;
    {
      var hook;

      if (style) {
        hook = function hook(context) {
          style.call(this, createInjector(context));
        };
      }

      if (hook !== undefined) {
        if (component.functional) {
          // register for functional component in vue file
          var originalRender = component.render;

          component.render = function renderWithStyleInjection(h, context) {
            hook.call(context);
            return originalRender(h, context);
          };
        } else {
          // inject component registration as beforeCreate hook
          var existing = component.beforeCreate;
          component.beforeCreate = existing ? [].concat(existing, hook) : [hook];
        }
      }
    }
    return component;
  }
  /* style inject */


  function __vue_create_injector__$k() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$k.styles || (__vue_create_injector__$k.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());
    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = {
        ids: [],
        parts: [],
        element: undefined
      });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;
        style.ids.push(id);

        if (css.map) {
          // https://developer.chrome.com/devtools/docs/javascript-debugging
          // this makes source maps inside style tags work properly in Chrome
          code += '\n/*# sourceURL=' + css.map.sources[0] + ' */'; // http://stackoverflow.com/a/26603875

          code += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(css.map)))) + ' */';
        }

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';
          if (css.media) el.setAttribute('media', css.media);

          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */


  var ThreadComment = __vue_normalize__$v({
    render: __vue_render__$v,
    staticRenderFns: __vue_staticRenderFns__$v
  }, __vue_inject_styles__$v, __vue_script__$v, __vue_scope_id__$v, __vue_is_functional_template__$v, __vue_module_identifier__$k, __vue_create_injector__$k); //


  var script$u = {
    name: 'thread-list',
    inject: ['$teRegistry'],
    props: {
      comments: {
        type: Array,
        "default": function _default() {
          return [];
        }
      },
      isActivityThread: {
        type: Boolean,
        "default": false
      },
      elementLabel: {
        type: String,
        "default": null
      },
      user: {
        type: Object,
        required: true
      }
    },
    methods: {
      getElementLabel: function getElementLabel(_ref) {
        var _find;

        var contentElement = _ref.contentElement;
        if (!contentElement) return;
        return (_find = find__default['default'](this.$teRegistry._registry, {
          type: contentElement.type
        })) === null || _find === void 0 ? void 0 : _find.name;
      }
    },
    components: {
      ThreadComment: ThreadComment
    }
  };
  /* script */

  var __vue_script__$u = script$u;
  /* template */

  var __vue_render__$u = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('ul', {
      staticClass: "thread-list"
    }, _vm._l(_vm.comments, function (comment) {
      return _c('li', {
        key: comment.uid,
        staticClass: "thread-list-item"
      }, [_c('v-divider'), _vm._v(" "), _c('thread-comment', _vm._g(_vm._b({
        staticClass: "mb-3",
        attrs: {
          "element-label": _vm.getElementLabel(comment)
        }
      }, 'thread-comment', {
        comment: comment,
        isActivityThread: _vm.isActivityThread,
        user: _vm.user
      }, false), _vm.$listeners))], 1);
    }), 0);
  };

  var __vue_staticRenderFns__$u = [];
  /* style */

  var __vue_inject_styles__$u = function __vue_inject_styles__(inject) {
    if (!inject) return;
    inject("data-v-b5620cec_0", {
      source: ".thread-list[data-v-b5620cec]{margin:0;padding:0;list-style:none}.thread-list .thread-list-item .v-divider[data-v-b5620cec]{margin:0 .25rem 1rem .25rem}.thread-list .thread-list-item:first-child .v-divider[data-v-b5620cec]{display:none}",
      map: undefined,
      media: undefined
    });
  };
  /* scoped */


  var __vue_scope_id__$u = "data-v-b5620cec";
  /* module identifier */

  var __vue_module_identifier__$j = undefined;
  /* functional template */

  var __vue_is_functional_template__$u = false;
  /* component normalizer */

  function __vue_normalize__$u(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "List.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;
    {
      var hook;

      if (style) {
        hook = function hook(context) {
          style.call(this, createInjector(context));
        };
      }

      if (hook !== undefined) {
        if (component.functional) {
          // register for functional component in vue file
          var originalRender = component.render;

          component.render = function renderWithStyleInjection(h, context) {
            hook.call(context);
            return originalRender(h, context);
          };
        } else {
          // inject component registration as beforeCreate hook
          var existing = component.beforeCreate;
          component.beforeCreate = existing ? [].concat(existing, hook) : [hook];
        }
      }
    }
    return component;
  }
  /* style inject */


  function __vue_create_injector__$j() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$j.styles || (__vue_create_injector__$j.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());
    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = {
        ids: [],
        parts: [],
        element: undefined
      });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;
        style.ids.push(id);

        if (css.map) {
          // https://developer.chrome.com/devtools/docs/javascript-debugging
          // this makes source maps inside style tags work properly in Chrome
          code += '\n/*# sourceURL=' + css.map.sources[0] + ' */'; // http://stackoverflow.com/a/26603875

          code += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(css.map)))) + ' */';
        }

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';
          if (css.media) el.setAttribute('media', css.media);

          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */


  var ThreadList = __vue_normalize__$u({
    render: __vue_render__$u,
    staticRenderFns: __vue_staticRenderFns__$u
  }, __vue_inject_styles__$u, __vue_script__$u, __vue_scope_id__$u, __vue_is_functional_template__$u, __vue_module_identifier__$j, __vue_create_injector__$j); //


  var script$t = {
    name: 'unseen-divider',
    props: {
      count: {
        type: Number,
        required: true
      }
    },
    computed: {
      unseenCommentsLabel: function unseenCommentsLabel(_ref) {
        var count = _ref.count;
        return "".concat(count, " new ").concat(pluralize__default['default']('message', count));
      }
    }
  };
  /* script */

  var __vue_script__$t = script$t;
  /* template */

  var __vue_render__$t = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      staticClass: "unseen-divider"
    }, [_c('v-divider'), _vm._v(" "), _c('v-chip', {
      attrs: {
        "close-icon": "mdi-close",
        "color": "teal accent-4",
        "outlined": "",
        "small": "",
        "close": ""
      },
      on: {
        "click": function click($event) {
          return _vm.$emit('seen');
        },
        "click:close": function clickClose($event) {
          return _vm.$emit('seen');
        }
      }
    }, [_c('v-icon', {
      staticClass: "mr-1",
      attrs: {
        "size": "14"
      }
    }, [_vm._v("mdi-arrow-down")]), _vm._v(" "), _c('span', {
      staticClass: "mr-2"
    }, [_vm._v(_vm._s(_vm.unseenCommentsLabel))])], 1)], 1);
  };

  var __vue_staticRenderFns__$t = [];
  /* style */

  var __vue_inject_styles__$t = function __vue_inject_styles__(inject) {
    if (!inject) return;
    inject("data-v-221b9d72_0", {
      source: ".unseen-divider[data-v-221b9d72]{text-align:center}.unseen-divider .v-divider[data-v-221b9d72]{margin:1rem 0 .25rem}.unseen-divider[data-v-221b9d72]  .v-chip.v-chip--outlined.v-chip{margin:-1.5rem 0 .5rem 0;border-radius:1rem!important;background-color:#fafafa!important}.unseen-divider[data-v-221b9d72]  .v-chip.v-chip--outlined.v-chip .v-chip__content .v-chip__close{margin-top:.125rem;font-size:.75rem!important}",
      map: undefined,
      media: undefined
    });
  };
  /* scoped */


  var __vue_scope_id__$t = "data-v-221b9d72";
  /* module identifier */

  var __vue_module_identifier__$i = undefined;
  /* functional template */

  var __vue_is_functional_template__$t = false;
  /* component normalizer */

  function __vue_normalize__$t(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "UnseenDivider.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;
    {
      var hook;

      if (style) {
        hook = function hook(context) {
          style.call(this, createInjector(context));
        };
      }

      if (hook !== undefined) {
        if (component.functional) {
          // register for functional component in vue file
          var originalRender = component.render;

          component.render = function renderWithStyleInjection(h, context) {
            hook.call(context);
            return originalRender(h, context);
          };
        } else {
          // inject component registration as beforeCreate hook
          var existing = component.beforeCreate;
          component.beforeCreate = existing ? [].concat(existing, hook) : [hook];
        }
      }
    }
    return component;
  }
  /* style inject */


  function __vue_create_injector__$i() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$i.styles || (__vue_create_injector__$i.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());
    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = {
        ids: [],
        parts: [],
        element: undefined
      });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;
        style.ids.push(id);

        if (css.map) {
          // https://developer.chrome.com/devtools/docs/javascript-debugging
          // this makes source maps inside style tags work properly in Chrome
          code += '\n/*# sourceURL=' + css.map.sources[0] + ' */'; // http://stackoverflow.com/a/26603875

          code += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(css.map)))) + ' */';
        }

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';
          if (css.media) el.setAttribute('media', css.media);

          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */


  var UnseenDivider = __vue_normalize__$t({
    render: __vue_render__$t,
    staticRenderFns: __vue_staticRenderFns__$t
  }, __vue_inject_styles__$t, __vue_script__$t, __vue_scope_id__$t, __vue_is_functional_template__$t, __vue_module_identifier__$i, __vue_create_injector__$i);

  var script$s = {
    name: 'discussion-thread',
    props: {
      items: {
        type: Array,
        required: true
      },
      showAll: {
        type: Boolean,
        "default": false
      },
      minDisplayed: {
        type: Number,
        "default": 5
      },
      isActivityThread: {
        type: Boolean,
        "default": false
      },
      unseenCount: {
        type: Number,
        required: true
      },
      user: {
        type: Object,
        required: true
      }
    },
    data: function data() {
      return {
        isVisible: false
      };
    },
    computed: {
      visibleComments: function visibleComments() {
        var items = this.items,
            minDisplayed = this.minDisplayed,
            showAll = this.showAll;
        var comments = showAll ? items : takeRgt__default['default'](items, minDisplayed);

        var _partition = partition__default['default'](comments, 'unseen'),
            _partition2 = _slicedToArray(_partition, 2),
            unseen = _partition2[0],
            seen = _partition2[1];

        return {
          seen: seen,
          unseen: unseen
        };
      }
    },
    methods: {
      onUpdate: function onUpdate(comment, content) {
        this.$emit('update', Object.assign({}, comment, {
          content: content
        }));
      },
      onIntersect: function onIntersect(_entries, _observer, isIntersected) {
        this.isVisible = isIntersected;
      },
      revealUnseen: function revealUnseen(count) {
        var $refs = this.$refs,
            minDisplayed = this.minDisplayed;
        if ((count || this.unseenCount) < minDisplayed) return;
        this.$emit('showAll', true);
        this.$nextTick(function () {
          var element = $refs.unseenDivider.$el;
          if (!element) return;
          element.scrollIntoView({
            behavior: 'smooth'
          });
        });
      },
      markSeen: function markSeen() {
        this.$emit('seen');
        this.$emit('showAll', false);
      }
    },
    watch: {
      isVisible: function isVisible(val) {
        if (!val || !this.unseenCount) return;
        this.revealUnseen();
      },
      unseenCount: {
        immediate: true,
        handler: 'revealUnseen'
      }
    },
    components: {
      UnseenDivider: UnseenDivider,
      ThreadList: ThreadList
    }
  };
  /* script */

  var __vue_script__$s = script$s;
  /* template */

  var __vue_render__$s = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      directives: [{
        name: "intersect",
        rawName: "v-intersect",
        value: _vm.onIntersect,
        expression: "onIntersect"
      }],
      staticClass: "discussion-thread",
      "class": {
        'scroll-container': !_vm.isActivityThread
      }
    }, [_c('thread-list', _vm._b({
      on: {
        "update": _vm.onUpdate,
        "remove": function remove($event) {
          return _vm.$emit('remove', $event);
        },
        "resolve": function resolve($event) {
          return _vm.$emit('resolve', $event);
        },
        "unresolve": function unresolve($event) {
          return _vm.$emit('unresolve', $event);
        }
      }
    }, 'thread-list', {
      isActivityThread: _vm.isActivityThread,
      user: _vm.user,
      comments: _vm.visibleComments.seen
    }, false)), _vm._v(" "), _c('transition', {
      attrs: {
        "name": "fade"
      }
    }, [_vm.unseenCount ? _c('unseen-divider', {
      ref: "unseenDivider",
      attrs: {
        "count": _vm.unseenCount
      },
      on: {
        "seen": _vm.markSeen
      }
    }) : _vm._e()], 1), _vm._v(" "), _c('thread-list', _vm._b({
      on: {
        "update": _vm.onUpdate,
        "remove": function remove($event) {
          return _vm.$emit('remove', $event);
        },
        "resolve": function resolve($event) {
          return _vm.$emit('resolve', $event);
        },
        "unresolve": function unresolve($event) {
          return _vm.$emit('unresolve', $event);
        }
      }
    }, 'thread-list', {
      isActivityThread: _vm.isActivityThread,
      user: _vm.user,
      comments: _vm.visibleComments.unseen
    }, false))], 1);
  };

  var __vue_staticRenderFns__$s = [];
  /* style */

  var __vue_inject_styles__$s = function __vue_inject_styles__(inject) {
    if (!inject) return;
    inject("data-v-c6af8436_0", {
      source: ".discussion-thread[data-v-c6af8436]{width:100%}.discussion-thread.scroll-container[data-v-c6af8436]{max-height:31.25rem;overflow-y:scroll;overflow-x:hidden;padding-right:1.5rem;box-sizing:content-box}.discussion-thread .fade-enter-active[data-v-c6af8436],.discussion-thread .fade-leave-active[data-v-c6af8436]{transition:opacity .5s}.discussion-thread .fade-enter[data-v-c6af8436],.discussion-thread .fade-leave-to[data-v-c6af8436]{opacity:0}",
      map: undefined,
      media: undefined
    });
  };
  /* scoped */


  var __vue_scope_id__$s = "data-v-c6af8436";
  /* module identifier */

  var __vue_module_identifier__$h = undefined;
  /* functional template */

  var __vue_is_functional_template__$s = false;
  /* component normalizer */

  function __vue_normalize__$s(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "index.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;
    {
      var hook;

      if (style) {
        hook = function hook(context) {
          style.call(this, createInjector(context));
        };
      }

      if (hook !== undefined) {
        if (component.functional) {
          // register for functional component in vue file
          var originalRender = component.render;

          component.render = function renderWithStyleInjection(h, context) {
            hook.call(context);
            return originalRender(h, context);
          };
        } else {
          // inject component registration as beforeCreate hook
          var existing = component.beforeCreate;
          component.beforeCreate = existing ? [].concat(existing, hook) : [hook];
        }
      }
    }
    return component;
  }
  /* style inject */


  function __vue_create_injector__$h() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$h.styles || (__vue_create_injector__$h.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());
    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = {
        ids: [],
        parts: [],
        element: undefined
      });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;
        style.ids.push(id);

        if (css.map) {
          // https://developer.chrome.com/devtools/docs/javascript-debugging
          // this makes source maps inside style tags work properly in Chrome
          code += '\n/*# sourceURL=' + css.map.sources[0] + ' */'; // http://stackoverflow.com/a/26603875

          code += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(css.map)))) + ' */';
        }

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';
          if (css.media) el.setAttribute('media', css.media);

          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */


  var DiscussionThread = __vue_normalize__$s({
    render: __vue_render__$s,
    staticRenderFns: __vue_staticRenderFns__$s
  }, __vue_inject_styles__$s, __vue_script__$s, __vue_scope_id__$s, __vue_is_functional_template__$s, __vue_module_identifier__$h, __vue_create_injector__$h); //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //


  var script$r = {
    name: 'resolve-comments-btn'
  };
  /* script */

  var __vue_script__$r = script$r;
  /* template */

  var __vue_render__$r = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      staticClass: "resolve-btn-container"
    }, [_c('v-tooltip', {
      attrs: {
        "open-delay": "800",
        "left": ""
      },
      scopedSlots: _vm._u([{
        key: "activator",
        fn: function fn(ref) {
          var on = ref.on;
          return [_c('v-btn', _vm._g({
            staticClass: "px-1",
            attrs: {
              "color": "teal accent-4",
              "small": "",
              "text": ""
            }
          }, Object.assign({}, _vm.$listeners, on)), [_c('v-icon', {
            staticClass: "mr-2",
            attrs: {
              "size": "24",
              "color": "teal accent-4"
            }
          }, [_vm._v("\n          mdi-check-box-outline\n        ")]), _vm._v("\n        Resolve All\n      ")], 1)];
        }
      }])
    }, [_vm._v(" "), _c('span', [_vm._v("Mark all as resolved and hide discussion")])])], 1);
  };

  var __vue_staticRenderFns__$r = [];
  /* style */

  var __vue_inject_styles__$r = undefined;
  /* scoped */

  var __vue_scope_id__$r = undefined;
  /* functional template */

  var __vue_is_functional_template__$r = false;
  /* component normalizer */

  function __vue_normalize__$r(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "ResolveButton.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;
    return component;
  }
  /* style inject */

  /* style inject SSR */


  var ResolveButton = __vue_normalize__$r({
    render: __vue_render__$r,
    staticRenderFns: __vue_staticRenderFns__$r
  }, __vue_inject_styles__$r, __vue_script__$r, __vue_scope_id__$r, __vue_is_functional_template__$r); //


  var initCommentInput = function initCommentInput() {
    return {
      content: ''
    };
  };

  var script$q = {
    name: 'tailor-embedded-discussion',
    inheritAttrs: true,
    props: {
      comments: {
        type: Array,
        "default": function _default() {
          return [];
        }
      },
      unseenComments: {
        type: Array,
        "default": function _default() {
          return [];
        }
      },
      commentsShownLimit: {
        type: Number,
        "default": 5
      },
      scrollTarget: {
        type: String,
        "default": 'discussion'
      },
      showHeading: {
        type: Boolean,
        "default": false
      },
      showNotifications: {
        type: Boolean,
        "default": false
      },
      isActivityThread: {
        type: Boolean,
        "default": false
      },
      hasUnresolvedComments: {
        type: Boolean,
        "default": false
      },
      isVisible: {
        type: Boolean,
        "default": false
      },
      user: {
        type: Object,
        required: true
      }
    },
    data: function data() {
      return {
        showAll: false,
        comment: initCommentInput()
      };
    },
    computed: {
      thread: function thread() {
        var comments = this.comments,
            unseenComments = this.unseenComments;
        var processedThread = comments.map(function (comment) {
          var unseen = unseenComments.find(function (it) {
            return it.id === comment.id;
          });
          return Object.assign({}, comment, {
            unseen: !!unseen
          });
        });
        return orderBy__default['default'](processedThread, ['unseen', 'createdAt'], 'asc');
      },
      commentsCount: function commentsCount(vm) {
        return vm.thread.length;
      },
      hasHiddenComments: function hasHiddenComments(vm) {
        return vm.commentsShownLimit < vm.commentsCount;
      },
      isTextEditorEmpty: function isTextEditorEmpty(vm) {
        var _vm$comment$content;

        return !((_vm$comment$content = vm.comment.content) !== null && _vm$comment$content !== void 0 && _vm$comment$content.trim());
      },
      showResolveButton: function showResolveButton(vm) {
        return vm.hasUnresolvedComments && !vm.isActivityThread;
      }
    },
    methods: Object.assign({}, vueRadio.mapRequests('app', ['showConfirmationModal']), {
      post: function post() {
        var _this = this;

        var scrollTarget = this.scrollTarget,
            comment = this.comment,
            author = this.user;
        if (!comment.content) return;
        var payload = {
          content: comment.content,
          author: author,
          createdAt: Date.now(),
          updatedAt: Date.now()
        };
        this.comment = initCommentInput();
        this.$emit('save', payload); // Keep editor/discussion container inside viewport.

        var scrollOptions = {
          block: 'center',
          behavior: 'smooth'
        };
        this.$nextTick(function () {
          return _this.$refs[scrollTarget].scrollIntoView(scrollOptions);
        });
      },
      remove: function remove(comment) {
        var _this2 = this;

        this.showConfirmationModal(Object.assign({
          title: 'Remove comment',
          message: 'Are you sure you want to remove this comment?',
          action: function action() {
            return _this2.$emit('remove', comment);
          }
        }, this.onConfirmationActive()));
      },
      resolveAll: function resolveAll() {
        var _this3 = this;

        this.showConfirmationModal(Object.assign({
          title: 'Resolve all comments',
          message: 'Are you sure you want to resolve all comments?',
          action: function action() {
            return _this3.$emit('resolve');
          }
        }, this.onConfirmationActive()));
      },
      onConfirmationActive: function onConfirmationActive() {
        var _this4 = this;

        var onOpen = function onOpen() {
          return _this4.$emit('update:confirmationActive', true);
        };

        var onClose = function onClose() {
          return _this4.$emit('update:confirmationActive', false);
        };

        return {
          onOpen: onOpen,
          onClose: onClose
        };
      }
    }),
    watch: {
      commentsCount: function commentsCount() {
        this.$emit('change', this.thread);
      },
      isVisible: {
        immediate: true,
        handler: function handler(val) {
          var _this5 = this;

          if (!val && this.isActivityThread) return; // Focus comment input manually with delay to avoid
          // element focus prioritization (e.g HTML element)

          setTimeout(function () {
            return _this5.$refs.commentInput.focus();
          }, 500);
        }
      }
    },
    created: function created() {
      this.comment = initCommentInput();
    },
    components: {
      DiscussionThread: DiscussionThread,
      ResolveButton: ResolveButton
    }
  };
  /* script */

  var __vue_script__$q = script$q;
  /* template */

  var __vue_render__$q = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      ref: "discussion",
      staticClass: "embedded-discussion"
    }, [_vm.showResolveButton ? _c('resolve-button', {
      on: {
        "click": _vm.resolveAll
      }
    }) : _vm._e(), _vm._v(" "), _c('div', {
      "class": {
        'pb-7': !_vm.showHeading && _vm.hasHiddenComments
      }
    }, [_vm.hasHiddenComments ? _c('v-btn', {
      staticClass: "float-right mt-1",
      attrs: {
        "text": "",
        "x-small": ""
      },
      on: {
        "click": function click($event) {
          _vm.showAll = !_vm.showAll;
        }
      }
    }, [_vm._v("\n      Show " + _vm._s(_vm.showAll ? 'less' : 'more') + "\n    ")]) : _vm._e()], 1), _vm._v(" "), _vm.showHeading ? _c('div', {
      staticClass: "header d-flex grey--text text--darken-3"
    }, [_c('v-icon', {
      staticClass: "mr-2",
      attrs: {
        "color": "grey darken-3"
      }
    }, [_vm._v("\n      mdi-forum-outline\n    ")]), _vm._v("\n    Comments\n  ")], 1) : _vm._e(), _vm._v(" "), !_vm.commentsCount && _vm.showNotifications ? _c('v-alert', {
      staticClass: "alert",
      attrs: {
        "color": "primary lighten-5",
        "icon": "mdi-keyboard-outline",
        "prominent": ""
      }
    }, [_c('span', {
      staticClass: "px-1 subtitle-2"
    }, [_vm._v("\n      Be the First to Comment!\n    ")])]) : _vm._e(), _vm._v(" "), _vm.thread.length ? _c('discussion-thread', {
      staticClass: "mt-2",
      attrs: {
        "items": _vm.thread,
        "show-all": _vm.showAll,
        "min-displayed": _vm.commentsShownLimit,
        "is-activity-thread": _vm.isActivityThread,
        "unseen-count": _vm.unseenComments.length,
        "user": _vm.user
      },
      on: {
        "update": function update($event) {
          return _vm.$emit('update', $event);
        },
        "resolve": function resolve($event) {
          return _vm.$emit('resolve', $event);
        },
        "unresolve": function unresolve($event) {
          return _vm.$emit('unresolve', $event);
        },
        "seen": function seen($event) {
          return _vm.$emit('seen');
        },
        "remove": _vm.remove,
        "showAll": function showAll($event) {
          _vm.showAll = $event;
        }
      }
    }) : _vm._e(), _vm._v(" "), _c('div', {
      ref: "inputContainer",
      staticClass: "text-right"
    }, [_c('v-textarea', {
      ref: "commentInput",
      staticClass: "comment-input",
      attrs: {
        "placeholder": _vm.commentsCount ? 'Add a comment...' : 'Start the discussion...',
        "rows": "3",
        "outlined": "",
        "auto-grow": "",
        "clearable": "",
        "counter": ""
      },
      on: {
        "focus": function focus($event) {
          return _vm.$emit('seen');
        }
      },
      model: {
        value: _vm.comment.content,
        callback: function callback($$v) {
          _vm.$set(_vm.comment, "content", typeof $$v === 'string' ? $$v.trim() : $$v);
        },
        expression: "comment.content"
      }
    }), _vm._v(" "), _c('v-btn', {
      attrs: {
        "disabled": _vm.isTextEditorEmpty,
        "icon": ""
      },
      on: {
        "click": _vm.post
      }
    }, [_c('v-icon', [_vm._v("mdi-send")])], 1)], 1)], 1);
  };

  var __vue_staticRenderFns__$q = [];
  /* style */

  var __vue_inject_styles__$q = function __vue_inject_styles__(inject) {
    if (!inject) return;
    inject("data-v-5744b719_0", {
      source: ".embedded-discussion[data-v-5744b719]{font-family:Roboto,Arial,sans-serif}.embedded-discussion .resolve-btn-container[data-v-5744b719]{display:flex;justify-content:flex-end;margin:.5rem 0 0 0}.embedded-discussion .header[data-v-5744b719]{margin:.875rem 0 1.625rem 0;font-size:1.125rem;font-weight:400}.embedded-discussion .comment-input[data-v-5744b719]{margin:0 .25rem 0 .25rem}.embedded-discussion .alert[data-v-5744b719]  .v-icon{color:var(--v-primary-darken2)!important}",
      map: undefined,
      media: undefined
    });
  };
  /* scoped */


  var __vue_scope_id__$q = "data-v-5744b719";
  /* module identifier */

  var __vue_module_identifier__$g = undefined;
  /* functional template */

  var __vue_is_functional_template__$q = false;
  /* component normalizer */

  function __vue_normalize__$q(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "index.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;
    {
      var hook;

      if (style) {
        hook = function hook(context) {
          style.call(this, createInjector(context));
        };
      }

      if (hook !== undefined) {
        if (component.functional) {
          // register for functional component in vue file
          var originalRender = component.render;

          component.render = function renderWithStyleInjection(h, context) {
            hook.call(context);
            return originalRender(h, context);
          };
        } else {
          // inject component registration as beforeCreate hook
          var existing = component.beforeCreate;
          component.beforeCreate = existing ? [].concat(existing, hook) : [hook];
        }
      }
    }
    return component;
  }
  /* style inject */


  function __vue_create_injector__$g() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$g.styles || (__vue_create_injector__$g.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());
    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = {
        ids: [],
        parts: [],
        element: undefined
      });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;
        style.ids.push(id);

        if (css.map) {
          // https://developer.chrome.com/devtools/docs/javascript-debugging
          // this makes source maps inside style tags work properly in Chrome
          code += '\n/*# sourceURL=' + css.map.sources[0] + ' */'; // http://stackoverflow.com/a/26603875

          code += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(css.map)))) + ' */';
        }

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';
          if (css.media) el.setAttribute('media', css.media);

          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */


  var Discussion$1 = __vue_normalize__$q({
    render: __vue_render__$q,
    staticRenderFns: __vue_staticRenderFns__$q
  }, __vue_inject_styles__$q, __vue_script__$q, __vue_scope_id__$q, __vue_is_functional_template__$q, __vue_module_identifier__$g, __vue_create_injector__$g); //


  var getActivatorOptions = function getActivatorOptions(unseenComments) {
    return {
      unseen: {
        "class": 'teal accent-4 white--text',
        tooltip: 'View new comments',
        text: unseenComments.length
      },
      preview: {
        icon: 'mdi-comment-text-multiple-outline',
        color: 'primary darken-4',
        tooltip: 'View comments'
      },
      post: {
        icon: 'mdi-message-plus-outline',
        color: 'primary darken-4',
        tooltip: 'Post a comment'
      }
    };
  };

  var script$p = {
    name: 'tailor-element-discussion',
    props: {
      id: {
        type: Number,
        "default": null
      },
      uid: {
        type: String,
        required: true
      },
      comments: {
        type: Array,
        required: true
      },
      hasUnresolvedComments: {
        type: Boolean,
        "default": false
      },
      lastSeen: {
        type: Number,
        required: true
      },
      user: {
        type: Object,
        required: true
      }
    },
    data: function data() {
      return {
        isVisible: false,
        isConfirmationActive: false
      };
    },
    computed: Object.assign({}, vueRadio.mapChannels({
      editorBus: 'editor'
    }), {
      events: function events() {
        return utils.Events.Discussion;
      },
      lastCommentAt: function lastCommentAt(vm) {
        return new Date(get__default['default'](vm.comments[0], 'createdAt', 0)).getTime();
      },
      unseenComments: function unseenComments() {
        var comments = this.comments,
            user = this.user,
            lastSeen = this.lastSeen;
        return comments.filter(function (it) {
          var createdAt = new Date(it.createdAt).getTime();
          return it.author.id !== user.id && createdAt > lastSeen;
        });
      },
      activator: function activator() {
        var comments = this.comments,
            unseenComments = this.unseenComments;
        var type = unseenComments.length ? 'unseen' : comments.length ? 'preview' : 'post';
        return getActivatorOptions(unseenComments)[type];
      }
    }),
    methods: {
      save: function save(data) {
        var author = this.user,
            elementId = this.id,
            hasUnresolvedComments = this.hasUnresolvedComments;
        return this.editorBus.emit(utils.Events.Discussion.SAVE, Object.assign({}, data, {
          author: author,
          contentElementId: elementId,
          hasUnresolvedComments: hasUnresolvedComments
        }));
      },
      setLastSeen: function setLastSeen(timeout) {
        var elementUid = this.uid,
            lastCommentAt = this.lastCommentAt,
            events = this.events;
        var options = {
          elementUid: elementUid,
          lastCommentAt: lastCommentAt,
          timeout: timeout
        };
        this.editorBus.emit(events.SET_LAST_SEEN, options);
      },
      resolve: function resolve() {
        var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
            id = _ref.id,
            resolvedAt = _ref.resolvedAt;

        var contentElementId = this.id,
            events = this.events;
        this.editorBus.emit(events.RESOLVE, {
          id: id,
          contentElementId: contentElementId,
          resolvedAt: resolvedAt
        });
      }
    },
    watch: {
      isVisible: function isVisible(val) {
        if (val) this.$emit('open');
      }
    },
    components: {
      Discussion: Discussion$1
    }
  };
  /* script */

  var __vue_script__$p = script$p;
  /* template */

  var __vue_render__$p = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('v-menu', {
      attrs: {
        "close-on-content-click": false,
        "close-on-click": !_vm.isConfirmationActive,
        "min-width": "300",
        "transition": "slide-y-transition",
        "left": "",
        "offset-y": "",
        "attach": ""
      },
      nativeOn: {
        "click": function click($event) {
          $event.stopPropagation();
        }
      },
      scopedSlots: _vm._u([{
        key: "activator",
        fn: function fn(ref) {
          var menu = ref.on;
          return [_c('v-tooltip', {
            attrs: {
              "open-delay": "800",
              "left": ""
            },
            scopedSlots: _vm._u([{
              key: "activator",
              fn: function fn(ref) {
                var tooltip = ref.on;
                return [_c('v-btn', _vm._g({
                  "class": _vm.activator["class"],
                  attrs: {
                    "x-small": "",
                    "icon": ""
                  }
                }, Object.assign({}, menu, tooltip)), [_vm.activator.text ? _c('div', {
                  staticClass: "unseen"
                }, [_vm._v(_vm._s(_vm.activator.text))]) : _c('v-icon', {
                  attrs: {
                    "color": _vm.activator.color,
                    "size": "18"
                  }
                }, [_vm._v("\n            " + _vm._s(_vm.activator.icon) + "\n          ")])], 1)];
              }
            }], null, true)
          }, [_vm._v(" "), _c('span', [_vm._v(_vm._s(_vm.activator.tooltip))])])];
        }
      }]),
      model: {
        value: _vm.isVisible,
        callback: function callback($$v) {
          _vm.isVisible = $$v;
        },
        expression: "isVisible"
      }
    }, [_vm._v(" "), _c('discussion', _vm._b({
      staticClass: "pa-2",
      attrs: {
        "confirmation-active": _vm.isConfirmationActive
      },
      on: {
        "save": _vm.save,
        "update": _vm.save,
        "remove": function remove($event) {
          return _vm.editorBus.emit(_vm.events.REMOVE, $event);
        },
        "seen": _vm.setLastSeen,
        "resolve": _vm.resolve,
        "update:confirmationActive": function updateConfirmationActive($event) {
          _vm.isConfirmationActive = $event;
        },
        "update:confirmation-active": function updateConfirmationActive($event) {
          _vm.isConfirmationActive = $event;
        }
      }
    }, 'discussion', {
      comments: _vm.comments,
      unseenComments: _vm.unseenComments,
      hasUnresolvedComments: _vm.hasUnresolvedComments,
      user: _vm.user,
      isVisible: _vm.isVisible
    }, false))], 1);
  };

  var __vue_staticRenderFns__$p = [];
  /* style */

  var __vue_inject_styles__$p = function __vue_inject_styles__(inject) {
    if (!inject) return;
    inject("data-v-382b8ce9_0", {
      source: "[data-v-382b8ce9] .v-menu__content{background:#fff}[data-v-382b8ce9] .v-menu__content .embedded-discussion{text-align:left}[data-v-382b8ce9] .v-menu__content .comment .author{font-size:.875rem}.unseen[data-v-382b8ce9]{font-size:.75rem}",
      map: undefined,
      media: undefined
    });
  };
  /* scoped */


  var __vue_scope_id__$p = "data-v-382b8ce9";
  /* module identifier */

  var __vue_module_identifier__$f = undefined;
  /* functional template */

  var __vue_is_functional_template__$p = false;
  /* component normalizer */

  function __vue_normalize__$p(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "ElementDiscussion.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;
    {
      var hook;

      if (style) {
        hook = function hook(context) {
          style.call(this, createInjector(context));
        };
      }

      if (hook !== undefined) {
        if (component.functional) {
          // register for functional component in vue file
          var originalRender = component.render;

          component.render = function renderWithStyleInjection(h, context) {
            hook.call(context);
            return originalRender(h, context);
          };
        } else {
          // inject component registration as beforeCreate hook
          var existing = component.beforeCreate;
          component.beforeCreate = existing ? [].concat(existing, hook) : [hook];
        }
      }
    }
    return component;
  }
  /* style inject */


  function __vue_create_injector__$f() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$f.styles || (__vue_create_injector__$f.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());
    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = {
        ids: [],
        parts: [],
        element: undefined
      });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;
        style.ids.push(id);

        if (css.map) {
          // https://developer.chrome.com/devtools/docs/javascript-debugging
          // this makes source maps inside style tags work properly in Chrome
          code += '\n/*# sourceURL=' + css.map.sources[0] + ' */'; // http://stackoverflow.com/a/26603875

          code += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(css.map)))) + ' */';
        }

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';
          if (css.media) el.setAttribute('media', css.media);

          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */


  var Discussion = __vue_normalize__$p({
    render: __vue_render__$p,
    staticRenderFns: __vue_staticRenderFns__$p
  }, __vue_inject_styles__$p, __vue_script__$p, __vue_scope_id__$p, __vue_is_functional_template__$p, __vue_module_identifier__$f, __vue_create_injector__$f); //


  var script$o = {
    name: 'tailor-publish-diff-chip',
    props: {
      changeType: {
        validator: function validator(value) {
          if (!value) return true;
          return Object.values(utils.publishDiffChangeTypes).includes(value);
        },
        "default": null
      }
    }
  };
  /* script */

  var __vue_script__$o = script$o;
  /* template */

  var __vue_render__$o = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _vm.changeType ? _c('v-chip', {
      staticClass: "readonly font-weight-medium text-capitalize",
      attrs: {
        "text-color": _vm.changeType === 'new' ? 'success' : 'secondary',
        "color": "primary lighten-5",
        "small": "",
        "round": ""
      }
    }, [_vm._v("\n  " + _vm._s(_vm.changeType) + "\n")]) : _vm._e();
  };

  var __vue_staticRenderFns__$o = [];
  /* style */

  var __vue_inject_styles__$o = undefined;
  /* scoped */

  var __vue_scope_id__$o = undefined;
  /* functional template */

  var __vue_is_functional_template__$o = false;
  /* component normalizer */

  function __vue_normalize__$o(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "PublishDiffChip.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;
    return component;
  }
  /* style inject */

  /* style inject SSR */


  var PublishDiffChip = __vue_normalize__$o({
    render: __vue_render__$o,
    staticRenderFns: __vue_staticRenderFns__$o
  }, __vue_inject_styles__$o, __vue_script__$o, __vue_scope_id__$o, __vue_is_functional_template__$o); //


  var script$n = {
    name: 'tailor-content-element',
    inject: {
      $getCurrentUser: {},
      $editorState: {
        "default": {}
      }
    },
    inheritAttrs: false,
    props: {
      element: {
        type: Object,
        required: true
      },
      parent: {
        type: Object,
        "default": null
      },
      isHovered: {
        type: Boolean,
        "default": false
      },
      isDragged: {
        type: Boolean,
        "default": false
      },
      isDisabled: {
        type: Boolean,
        "default": false
      },
      frame: {
        type: Boolean,
        "default": true
      },
      dense: {
        type: Boolean,
        "default": false
      },
      showDiscussion: {
        type: Boolean,
        "default": false
      }
    },
    data: function data() {
      return {
        isFocused: false,
        isSaving: false,
        activeUsers: []
      };
    },
    computed: Object.assign({}, vueRadio.mapChannels({
      editorBus: 'editor'
    }), {
      id: function id(vm) {
        return utils.getElementId(vm.element);
      },
      componentName: function componentName(vm) {
        return utils.getComponentName(vm.element.type);
      },
      isEmbed: function isEmbed(vm) {
        return !!vm.parent || !vm.element.uid;
      },
      isHighlighted: function isHighlighted(vm) {
        return vm.isFocused || vm.isHovered;
      },
      hasComments: function hasComments(vm) {
        var _vm$element$comments;

        return !!((_vm$element$comments = vm.element.comments) !== null && _vm$element$comments !== void 0 && _vm$element$comments.length);
      },
      elementBus: function elementBus(vm) {
        return vm.$radio.channel("element:".concat(vm.id));
      },
      currentUser: function currentUser(vm) {
        return vm.$getCurrentUser();
      }
    }),
    methods: {
      onSelect: function onSelect(e) {
        if (this.isDisabled || this.$editorState.isPublishDiff || e.component) return;
        this.focus();
        e.component = {
          name: 'content-element',
          data: this.element
        };
      },
      onSave: function onSave(data) {
        if (!this.isEmbed) this.isSaving = true;
        this.$emit('save', data);
      },
      focus: function focus() {
        this.editorBus.emit('element:focus', this.element, this.parent);
      }
    },
    created: function created() {
      var _this = this;

      var deferSaveFlag = function deferSaveFlag() {
        return setTimeout(function () {
          return _this.isSaving = false;
        }, 1000);
      }; // Element listeners


      this.elementBus.on('delete', function () {
        return _this.$emit('delete');
      });
      this.elementBus.on('save:meta', function (meta) {
        return _this.$emit('save:meta', meta);
      });
      this.elementBus.on('saved', deferSaveFlag); // Editor listeners

      this.editorBus.on('element:select', function (_ref) {
        var elementId = _ref.elementId,
            _ref$isSelected = _ref.isSelected,
            isSelected = _ref$isSelected === void 0 ? true : _ref$isSelected,
            user = _ref.user;
        if (_this.id !== elementId) return; // If current user; focus element

        if (!user || user.id === _this.currentUser.id) {
          _this.isFocused = isSelected;
          if (isSelected) _this.focus();
          return;
        } // If other user, toggle within active users list


        if (isSelected && !_this.activeUsers.find(function (it) {
          return it.id === user.id;
        })) {
          _this.activeUsers.push(user);
        } else if (!isSelected && _this.activeUsers.find(function (it) {
          return it.id === user.id;
        })) {
          _this.activeUsers = _this.activeUsers.filter(function (it) {
            return it.id !== user.id;
          });
        }
      });
      this.editorBus.on('element:focus', function (element) {
        _this.isFocused = !!element && utils.getElementId(element) === _this.id;
      });
    },
    provide: function provide() {
      return {
        $elementBus: this.elementBus
      };
    },
    components: {
      ActiveUsers: ActiveUsers,
      Discussion: Discussion,
      PublishDiffChip: PublishDiffChip
    }
  };
  /* script */

  var __vue_script__$n = script$n;
  /* template */

  var __vue_render__$n = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      staticClass: "content-element",
      "class": [_vm.element.changeSincePublish, {
        selected: _vm.activeUsers.length,
        focused: _vm.isFocused,
        diff: _vm.$editorState.isPublishDiff,
        frame: _vm.frame
      }],
      on: {
        "click": _vm.onSelect
      }
    }, [_c('div', {
      staticClass: "header d-flex",
      "class": {
        visible: _vm.$editorState.isPublishDiff && _vm.element.changeSincePublish
      }
    }, [_c('publish-diff-chip', {
      staticClass: "ml-auto ",
      attrs: {
        "change-type": _vm.element.changeSincePublish
      }
    })], 1), _vm._v(" "), _c('active-users', {
      staticClass: "active-users",
      attrs: {
        "users": _vm.activeUsers,
        "size": 20
      }
    }), _vm._v(" "), _c(_vm.componentName, _vm._b({
      tag: "component",
      attrs: {
        "id": "element_" + _vm.id
      },
      on: {
        "add": function add($event) {
          return _vm.$emit('add', $event);
        },
        "save": _vm.onSave,
        "delete": function _delete($event) {
          return _vm.$emit('delete');
        },
        "focus": _vm.onSelect
      }
    }, 'component', Object.assign({}, _vm.$attrs, {
      element: _vm.element,
      isFocused: _vm.isFocused,
      isDragged: _vm.isDragged,
      isDisabled: _vm.isDisabled,
      dense: _vm.dense
    }), false)), _vm._v(" "), !_vm.isDisabled ? _c('div', {
      staticClass: "element-actions"
    }, [_vm.showDiscussion ? _c('div', {
      "class": {
        'is-visible': _vm.isHighlighted || _vm.hasComments
      }
    }, [_c('discussion', _vm._b({
      attrs: {
        "user": _vm.currentUser
      },
      on: {
        "open": _vm.focus
      }
    }, 'discussion', _vm.element, false))], 1) : _vm._e(), _vm._v(" "), !_vm.parent ? _c('div', {
      "class": {
        'is-visible': _vm.isHighlighted
      }
    }, [_c('v-btn', {
      attrs: {
        "color": "pink lighten-1",
        "dark": "",
        "icon": "",
        "x-small": ""
      },
      on: {
        "click": function click($event) {
          return _vm.$emit('delete');
        }
      }
    }, [_c('v-icon', {
      attrs: {
        "size": "20"
      }
    }, [_vm._v("mdi-delete-outline")])], 1)], 1) : _vm._e()]) : _vm._e(), _vm._v(" "), _vm.isSaving ? _c('v-progress-linear', {
      staticClass: "save-indicator",
      attrs: {
        "height": "2",
        "color": "teal accent-2",
        "indeterminate": ""
      }
    }) : _vm._e()], 1);
  };

  var __vue_staticRenderFns__$n = [];
  /* style */

  var __vue_inject_styles__$n = function __vue_inject_styles__(inject) {
    if (!inject) return;
    inject("data-v-74c5ccda_0", {
      source: ".content-element[data-v-74c5ccda]{position:relative;border:1px solid transparent}.content-element[data-v-74c5ccda]::after{content:'';display:none;position:absolute;top:0;right:-.125rem;width:.125rem;height:100%}.content-element.focused[data-v-74c5ccda]{border:1px dashed #1de9b6}.content-element.focused[data-v-74c5ccda]::after{display:block;background:#1de9b6}.content-element.selected[data-v-74c5ccda]{border:1px dashed #ff4081}.content-element.selected[data-v-74c5ccda]::after{display:block;background:#ff4081}.frame[data-v-74c5ccda]{padding:10px 20px;border:1px solid #e1e1e1}.element-actions[data-v-74c5ccda]{display:flex;flex-direction:column;position:absolute;top:-.0625rem;right:-1.25rem;width:1.5rem;height:100%;padding-left:.75rem}.element-actions>*[data-v-74c5ccda]{min-height:1.75rem;opacity:0;transition:opacity .1s linear}.element-actions>.is-visible[data-v-74c5ccda]{opacity:1;transition:opacity .5s linear}.active-users[data-v-74c5ccda]{position:absolute;top:0;left:-1.625rem}.save-indicator[data-v-74c5ccda]{position:absolute;bottom:-.125rem;left:0}.header[data-v-74c5ccda]{width:100%;max-height:0}.header.visible[data-v-74c5ccda]{max-height:unset;padding:0 0 .5rem}.diff.new[data-v-74c5ccda]{border:none;box-shadow:0 0 0 2px var(--v-success-lighten2)!important}.diff.changed[data-v-74c5ccda],.diff.removed[data-v-74c5ccda]{border:none;box-shadow:0 0 0 2px var(--v-secondary-lighten4)!important}.diff .element-actions[data-v-74c5ccda]{display:none}",
      map: undefined,
      media: undefined
    });
  };
  /* scoped */


  var __vue_scope_id__$n = "data-v-74c5ccda";
  /* module identifier */

  var __vue_module_identifier__$e = undefined;
  /* functional template */

  var __vue_is_functional_template__$n = false;
  /* component normalizer */

  function __vue_normalize__$n(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "ContentElement.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;
    {
      var hook;

      if (style) {
        hook = function hook(context) {
          style.call(this, createInjector(context));
        };
      }

      if (hook !== undefined) {
        if (component.functional) {
          // register for functional component in vue file
          var originalRender = component.render;

          component.render = function renderWithStyleInjection(h, context) {
            hook.call(context);
            return originalRender(h, context);
          };
        } else {
          // inject component registration as beforeCreate hook
          var existing = component.beforeCreate;
          component.beforeCreate = existing ? [].concat(existing, hook) : [hook];
        }
      }
    }
    return component;
  }
  /* style inject */


  function __vue_create_injector__$e() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$e.styles || (__vue_create_injector__$e.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());
    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = {
        ids: [],
        parts: [],
        element: undefined
      });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;
        style.ids.push(id);

        if (css.map) {
          // https://developer.chrome.com/devtools/docs/javascript-debugging
          // this makes source maps inside style tags work properly in Chrome
          code += '\n/*# sourceURL=' + css.map.sources[0] + ' */'; // http://stackoverflow.com/a/26603875

          code += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(css.map)))) + ' */';
        }

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';
          if (css.media) el.setAttribute('media', css.media);

          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */


  var ContentElement$1 = __vue_normalize__$n({
    render: __vue_render__$n,
    staticRenderFns: __vue_staticRenderFns__$n
  }, __vue_inject_styles__$n, __vue_script__$n, __vue_scope_id__$n, __vue_is_functional_template__$n, __vue_module_identifier__$e, __vue_create_injector__$e); //


  var script$m = {
    name: 'content-element-preview',
    props: {
      element: {
        type: Object,
        required: true
      },
      selectable: {
        type: Boolean,
        "default": false
      },
      isSelected: {
        type: Boolean,
        "default": false
      },
      selectionDisabled: {
        type: Boolean,
        "default": false
      }
    },
    computed: {
      disabled: function disabled(vm) {
        return vm.selectionDisabled && !vm.isSelected;
      },
      elementWidth: function elementWidth(vm) {
        return "col-xs-".concat(get__default['default'](vm.element, 'data.width', 12));
      }
    },
    methods: {
      toggleSelection: function toggleSelection() {
        if (!this.selectable || this.disabled) return;
        this.$emit('toggle');
      }
    },
    components: {
      ContentElement: ContentElement$1
    }
  };
  /* script */

  var __vue_script__$m = script$m;
  /* template */

  var __vue_render__$m = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      staticClass: "element-preview-container float-none",
      "class": _vm.elementWidth
    }, [_vm.selectable ? _c('v-checkbox', {
      attrs: {
        "input-value": _vm.isSelected,
        "disabled": _vm.disabled,
        "color": "primary darken-4"
      },
      on: {
        "click": _vm.toggleSelection
      }
    }) : _vm._e(), _vm._v(" "), _c('v-hover', {
      scopedSlots: _vm._u([{
        key: "default",
        fn: function fn(ref) {
          var hover = ref.hover;
          return [_c('div', {
            staticClass: "element-wrapper flex-grow-1"
          }, [_c('content-element', _vm._b({
            staticClass: "content-element",
            "class": {
              selected: _vm.isSelected
            },
            attrs: {
              "element": _vm.element,
              "set-width": false
            }
          }, 'content-element', _vm.$attrs, false)), _vm._v(" "), _c('v-tooltip', {
            attrs: {
              "open-delay": "400",
              "top": ""
            },
            scopedSlots: _vm._u([{
              key: "activator",
              fn: function fn(ref) {
                var on = ref.on;
                return [_c('v-btn', _vm._g({
                  staticClass: "open-element-button",
                  "class": {
                    visible: hover
                  },
                  attrs: {
                    "color": "blue-grey darken-4",
                    "fab": "",
                    "depressed": "",
                    "x-small": ""
                  },
                  on: {
                    "click": function click($event) {
                      $event.stopPropagation();
                      return _vm.$emit('element:open', _vm.element.uid);
                    }
                  }
                }, on), [_c('v-icon', {
                  attrs: {
                    "color": "secondary lighten-4",
                    "dense": ""
                  }
                }, [_vm._v("mdi-open-in-new")])], 1)];
              }
            }], null, true)
          }, [_vm._v(" "), _c('span', [_vm._v("Open in editor")])])], 1)];
        }
      }])
    })], 1);
  };

  var __vue_staticRenderFns__$m = [];
  /* style */

  var __vue_inject_styles__$m = function __vue_inject_styles__(inject) {
    if (!inject) return;
    inject("data-v-72d4e8ff_0", {
      source: ".element-preview-container[data-v-72d4e8ff]{display:flex;position:relative;margin:.25rem 0}.element-preview-container .v-input[data-v-72d4e8ff]{margin:0}.content-element[data-v-72d4e8ff]{flex:1 0;margin:.4375rem 0 0 .25rem;box-shadow:none;border:1px solid #e1e1e1}.content-element.selected[data-v-72d4e8ff]{border-style:dashed;border-color:#444}.content-element.selected[data-v-72d4e8ff]::after{display:none}.element-preview-container[data-v-72d4e8ff]  .contained-content{margin:0}.element-preview-container[data-v-72d4e8ff]  .contained-content .message span:not(.heading){display:none}.element-preview-container[data-v-72d4e8ff]  .contained-content .ql-editor{word-break:break-all}.element-wrapper[data-v-72d4e8ff]{position:relative}.open-element-button[data-v-72d4e8ff]{position:absolute;top:0;right:-.75rem;transition:opacity .4s}.open-element-button[data-v-72d4e8ff]:not(.visible){opacity:0}",
      map: undefined,
      media: undefined
    });
  };
  /* scoped */


  var __vue_scope_id__$m = "data-v-72d4e8ff";
  /* module identifier */

  var __vue_module_identifier__$d = undefined;
  /* functional template */

  var __vue_is_functional_template__$m = false;
  /* component normalizer */

  function __vue_normalize__$m(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "Element.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;
    {
      var hook;

      if (style) {
        hook = function hook(context) {
          style.call(this, createInjector(context));
        };
      }

      if (hook !== undefined) {
        if (component.functional) {
          // register for functional component in vue file
          var originalRender = component.render;

          component.render = function renderWithStyleInjection(h, context) {
            hook.call(context);
            return originalRender(h, context);
          };
        } else {
          // inject component registration as beforeCreate hook
          var existing = component.beforeCreate;
          component.beforeCreate = existing ? [].concat(existing, hook) : [hook];
        }
      }
    }
    return component;
  }
  /* style inject */


  function __vue_create_injector__$d() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$d.styles || (__vue_create_injector__$d.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());
    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = {
        ids: [],
        parts: [],
        element: undefined
      });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;
        style.ids.push(id);

        if (css.map) {
          // https://developer.chrome.com/devtools/docs/javascript-debugging
          // this makes source maps inside style tags work properly in Chrome
          code += '\n/*# sourceURL=' + css.map.sources[0] + ' */'; // http://stackoverflow.com/a/26603875

          code += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(css.map)))) + ' */';
        }

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';
          if (css.media) el.setAttribute('media', css.media);

          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */


  var ContentElement = __vue_normalize__$m({
    render: __vue_render__$m,
    staticRenderFns: __vue_staticRenderFns__$m
  }, __vue_inject_styles__$m, __vue_script__$m, __vue_scope_id__$m, __vue_is_functional_template__$m, __vue_module_identifier__$d, __vue_create_injector__$d); //


  var script$l = {
    name: 'content-preview',
    props: {
      contentContainers: {
        type: Array,
        required: true
      },
      selectable: {
        type: Boolean,
        "default": false
      },
      multiple: {
        type: Boolean,
        "default": true
      },
      allowedTypes: {
        type: Array,
        "default": function _default() {
          return [];
        }
      },
      selected: {
        type: Array,
        "default": function _default() {
          return [];
        }
      }
    },
    computed: {
      isSelectionDisabled: function isSelectionDisabled() {
        return this.selectable && !this.multiple && !!this.selected.length;
      },
      selectionMap: function selectionMap(vm) {
        return keyBy__default['default'](vm.selected, 'id');
      },
      processedContainers: function processedContainers() {
        var containers = this.contentContainers,
            allowedTypes = this.allowedTypes;
        if (!allowedTypes.length) return containers;
        return containers.map(function (container) {
          return Object.assign({}, container, {
            elements: container.elements.filter(function (it) {
              return allowedTypes.includes(it.type);
            })
          });
        });
      },
      elements: function elements() {
        var containers = this.processedContainers;
        return containers.reduce(function (acc, it) {
          return acc.concat(it.elements);
        }, []);
      }
    },
    components: {
      ContentElement: ContentElement
    }
  };
  /* script */

  var __vue_script__$l = script$l;
  /* template */

  var __vue_render__$l = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      staticClass: "content-preview"
    }, [!_vm.elements.length ? _c('v-alert', {
      staticClass: "mx-4",
      attrs: {
        "color": "grey darken-4",
        "text": ""
      }
    }, [_vm._v("\n    No available elements.\n  ")]) : _vm._e(), _vm._v(" "), _vm._l(_vm.processedContainers, function (container) {
      return _c('div', {
        key: container.id,
        staticClass: "content-container d-flex flex-wrap"
      }, _vm._l(container.elements, function (element) {
        return _c('content-element', {
          key: element.id,
          attrs: {
            "element": element,
            "selectable": _vm.selectable,
            "is-selected": !!_vm.selectionMap[element.id],
            "selection-disabled": _vm.isSelectionDisabled,
            "is-disabled": ""
          },
          on: {
            "toggle": function toggle($event) {
              return _vm.$emit('toggle', element);
            },
            "element:open": function elementOpen($event) {
              return _vm.$emit('element:open', $event);
            }
          }
        });
      }), 1);
    })], 2);
  };

  var __vue_staticRenderFns__$l = [];
  /* style */

  var __vue_inject_styles__$l = function __vue_inject_styles__(inject) {
    if (!inject) return;
    inject("data-v-2013b96d_0", {
      source: ".content-preview .v-alert[data-v-2013b96d]{display:flex;align-items:center;justify-content:center;height:19rem}.content-preview .content-container[data-v-2013b96d]:last-child{margin-bottom:.625rem}",
      map: undefined,
      media: undefined
    });
  };
  /* scoped */


  var __vue_scope_id__$l = "data-v-2013b96d";
  /* module identifier */

  var __vue_module_identifier__$c = undefined;
  /* functional template */

  var __vue_is_functional_template__$l = false;
  /* component normalizer */

  function __vue_normalize__$l(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "index.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;
    {
      var hook;

      if (style) {
        hook = function hook(context) {
          style.call(this, createInjector(context));
        };
      }

      if (hook !== undefined) {
        if (component.functional) {
          // register for functional component in vue file
          var originalRender = component.render;

          component.render = function renderWithStyleInjection(h, context) {
            hook.call(context);
            return originalRender(h, context);
          };
        } else {
          // inject component registration as beforeCreate hook
          var existing = component.beforeCreate;
          component.beforeCreate = existing ? [].concat(existing, hook) : [hook];
        }
      }
    }
    return component;
  }
  /* style inject */


  function __vue_create_injector__$c() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$c.styles || (__vue_create_injector__$c.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());
    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = {
        ids: [],
        parts: [],
        element: undefined
      });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;
        style.ids.push(id);

        if (css.map) {
          // https://developer.chrome.com/devtools/docs/javascript-debugging
          // this makes source maps inside style tags work properly in Chrome
          code += '\n/*# sourceURL=' + css.map.sources[0] + ' */'; // http://stackoverflow.com/a/26603875

          code += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(css.map)))) + ' */';
        }

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';
          if (css.media) el.setAttribute('media', css.media);

          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */


  var ContentPreview = __vue_normalize__$l({
    render: __vue_render__$l,
    staticRenderFns: __vue_staticRenderFns__$l
  }, __vue_inject_styles__$l, __vue_script__$l, __vue_scope_id__$l, __vue_is_functional_template__$l, __vue_module_identifier__$c, __vue_create_injector__$c);

  function loader(action, name) {
    var minDuration = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    return function () {
      var _this = this;

      this[name] = true;
      return pMinDelay_1(Promise.resolve(action.call.apply(action, [this].concat(Array.prototype.slice.call(arguments)))), minDuration)["finally"](function () {
        return _this[name] = false;
      });
    };
  } //


  var toTreeFormat = utils.activity.toTreeFormat,
      getOutlineChildrenFilterFn = utils.activity.getOutlineChildrenFilterFn;
  var script$k = {
    name: 'select-activity',
    inject: ['$schemaService'],
    props: {
      selectedElements: {
        type: Array,
        "default": function _default() {
          return [];
        }
      },
      activities: {
        type: Array,
        "default": function _default() {
          return [];
        }
      }
    },
    data: function data() {
      return {
        search: ''
      };
    },
    computed: {
      groupedSelection: function groupedSelection(vm) {
        return groupBy__default['default'](vm.selectedElements, 'outlineId');
      },
      expandedActivityIds: function expandedActivityIds(vm) {
        return map__default['default'](vm.activities, 'id');
      },
      activityTree: function activityTree() {
        return toTreeFormat(this.activities, {
          filterNodesFn: getOutlineChildrenFilterFn(this.$schemaService)
        });
      },
      noResultsMessage: function noResultsMessage() {
        var activities = this.activities,
            search = this.search,
            $refs = this.$refs;
        if (!activities.length) return 'Empty repository';
        if (!search || !$refs) return '';
        var _$refs$treeview = $refs.treeview,
            excludedItems = _$refs$treeview.excludedItems,
            nodes = _$refs$treeview.nodes;
        var hasSearchResults = excludedItems.size !== Object.keys(nodes).length;
        return !hasSearchResults && 'No matches found';
      }
    },
    methods: {
      hasContentContainers: function hasContentContainers(type) {
        return this.$schemaService.isEditable(type);
      },
      getChipLabel: function getChipLabel(_ref) {
        var length = _ref.length;
        return "".concat(length, " ").concat(pluralize__default['default']('element', length), " selected");
      }
    }
  };
  /* script */

  var __vue_script__$k = script$k;
  /* template */

  var __vue_render__$k = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      staticClass: "mx-3"
    }, [_c('v-text-field', {
      attrs: {
        "disabled": !_vm.activities.length,
        "placeholder": "Filter items...",
        "prepend-inner-icon": "mdi-filter-outline",
        "clear-icon": "mdi-close-circle-outline",
        "clearable": "",
        "outlined": ""
      },
      model: {
        value: _vm.search,
        callback: function callback($$v) {
          _vm.search = $$v;
        },
        expression: "search"
      }
    }), _vm._v(" "), _c('v-treeview', {
      directives: [{
        name: "show",
        rawName: "v-show",
        value: !_vm.noResultsMessage,
        expression: "!noResultsMessage"
      }],
      ref: "treeview",
      staticClass: "py-3 px-1 treeview",
      attrs: {
        "items": _vm.activityTree,
        "search": _vm.search,
        "open": _vm.expandedActivityIds,
        "transition": "",
        "open-on-click": ""
      },
      scopedSlots: _vm._u([{
        key: "label",
        fn: function fn(ref) {
          var ref_item = ref.item;
          var id = ref_item.id;
          var data = ref_item.data;
          return [_vm._v("\n      " + _vm._s(data.name) + "\n      "), _vm.groupedSelection[id] ? _c('v-chip', {
            staticClass: "readonly custom-chip",
            attrs: {
              "rounded": "",
              "small": ""
            }
          }, [_vm._v("\n        " + _vm._s(_vm.getChipLabel(_vm.groupedSelection[id])) + "\n      ")]) : _vm._e()];
        }
      }, {
        key: "append",
        fn: function fn(ref) {
          var item = ref.item;
          return [_vm.hasContentContainers(item.type) ? _c('v-btn', {
            attrs: {
              "color": "primary darken-2",
              "outlined": "",
              "small": ""
            },
            on: {
              "click": function click($event) {
                return _vm.$emit('selected', item);
              }
            }
          }, [_vm._v("\n        View elements\n      ")]) : _vm._e()];
        }
      }])
    }), _vm._v(" "), _c('v-alert', {
      attrs: {
        "value": !!_vm.noResultsMessage,
        "color": "primary darken-2",
        "dark": ""
      }
    }, [_vm._v("\n    " + _vm._s(_vm.noResultsMessage) + "\n  ")])], 1);
  };

  var __vue_staticRenderFns__$k = [];
  /* style */

  var __vue_inject_styles__$k = function __vue_inject_styles__(inject) {
    if (!inject) return;
    inject("data-v-466d804b_0", {
      source: ".treeview[data-v-466d804b]{max-height:19rem;text-align:left;background-color:#fcfcfc;border:1px solid #eee;overflow-y:scroll}.treeview .v-chip.custom-chip[data-v-466d804b]{border-radius:12px!important}.treeview[data-v-466d804b]  .v-treeview-node--leaf>.treeview ::v-deep .v-treeview-node__content>*,.treeview[data-v-466d804b]  .v-treeview-node--leaf>.treeview ::v-deep .v-treeview-node__root{cursor:auto}",
      map: undefined,
      media: undefined
    });
  };
  /* scoped */


  var __vue_scope_id__$k = "data-v-466d804b";
  /* module identifier */

  var __vue_module_identifier__$b = undefined;
  /* functional template */

  var __vue_is_functional_template__$k = false;
  /* component normalizer */

  function __vue_normalize__$k(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "SelectActivity.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;
    {
      var hook;

      if (style) {
        hook = function hook(context) {
          style.call(this, createInjector(context));
        };
      }

      if (hook !== undefined) {
        if (component.functional) {
          // register for functional component in vue file
          var originalRender = component.render;

          component.render = function renderWithStyleInjection(h, context) {
            hook.call(context);
            return originalRender(h, context);
          };
        } else {
          // inject component registration as beforeCreate hook
          var existing = component.beforeCreate;
          component.beforeCreate = existing ? [].concat(existing, hook) : [hook];
        }
      }
    }
    return component;
  }
  /* style inject */


  function __vue_create_injector__$b() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$b.styles || (__vue_create_injector__$b.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());
    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = {
        ids: [],
        parts: [],
        element: undefined
      });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;
        style.ids.push(id);

        if (css.map) {
          // https://developer.chrome.com/devtools/docs/javascript-debugging
          // this makes source maps inside style tags work properly in Chrome
          code += '\n/*# sourceURL=' + css.map.sources[0] + ' */'; // http://stackoverflow.com/a/26603875

          code += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(css.map)))) + ' */';
        }

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';
          if (css.media) el.setAttribute('media', css.media);

          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */


  var SelectActivity = __vue_normalize__$k({
    render: __vue_render__$k,
    staticRenderFns: __vue_staticRenderFns__$k
  }, __vue_inject_styles__$k, __vue_script__$k, __vue_scope_id__$k, __vue_is_functional_template__$k, __vue_module_identifier__$b, __vue_create_injector__$b); //


  var script$j = {
    name: 'select-repository',
    props: {
      repository: {
        type: Object,
        "default": null
      }
    },
    inject: ['$api'],
    data: function data() {
      return {
        repositories: [],
        loading: false
      };
    },
    methods: {
      selectRepository: function selectRepository(repository) {
        if (find__default['default'](this.repositories, {
          id: repository.id
        })) {
          this.$emit('selected', repository);
        }
      },
      fetchRepositories: debounce__default['default'](loader(function (search) {
        var _this = this;

        return this.$api.fetchRepositories({
          search: search
        }).then(function (repositories) {
          _this.repositories = sortBy__default['default'](repositories, 'name');
        });
      }, 'loading'), 500)
    },
    created: function created() {
      this.fetchRepositories();
    }
  };
  /* script */

  var __vue_script__$j = script$j;
  /* template */

  var __vue_render__$j = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('v-combobox', _vm._b({
      staticClass: "mx-3",
      attrs: {
        "value": _vm.repository,
        "items": _vm.repositories,
        "loading": _vm.loading,
        "item-value": "id",
        "item-text": "name",
        "label": "Select repository",
        "placeholder": "Type to search repositories...",
        "outlined": "",
        "return-object": ""
      },
      on: {
        "input": _vm.selectRepository,
        "update:search-input": _vm.fetchRepositories
      }
    }, 'v-combobox', _vm.$attrs, false));
  };

  var __vue_staticRenderFns__$j = [];
  /* style */

  var __vue_inject_styles__$j = undefined;
  /* scoped */

  var __vue_scope_id__$j = undefined;
  /* functional template */

  var __vue_is_functional_template__$j = false;
  /* component normalizer */

  function __vue_normalize__$j(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "SelectRepository.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;
    return component;
  }
  /* style inject */

  /* style inject SSR */


  var SelectRepository = __vue_normalize__$j({
    render: __vue_render__$j,
    staticRenderFns: __vue_staticRenderFns__$j
  }, __vue_inject_styles__$j, __vue_script__$j, __vue_scope_id__$j, __vue_is_functional_template__$j); //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //


  var script$i = {
    name: 'tailor-dialog',
    props: {
      headerIcon: {
        type: String,
        "default": null
      },
      width: {
        type: [Number, String],
        "default": 500
      },
      paddingless: {
        type: Boolean,
        "default": false
      }
    }
  };
  /* script */

  var __vue_script__$i = script$i;
  /* template */

  var __vue_render__$i = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('v-dialog', _vm._g(_vm._b({
      attrs: {
        "width": _vm.width
      },
      scopedSlots: _vm._u([_vm._l(_vm.$scopedSlots, function (_, slot) {
        return {
          key: slot,
          fn: function fn(scope) {
            return [_vm._t(slot, null, null, scope)];
          }
        };
      })], null, true)
    }, 'v-dialog', _vm.$attrs, false), _vm.$listeners), [_vm._v(" "), _c('v-card', [_c('v-card-title', {
      staticClass: "dialog-title primary darken-3",
      attrs: {
        "primary-title": ""
      }
    }, [_vm.headerIcon ? _c('v-avatar', {
      staticClass: "mr-3",
      attrs: {
        "color": "secondary",
        "size": "38"
      }
    }, [_c('v-icon', {
      attrs: {
        "dark": ""
      }
    }, [_vm._v(_vm._s(_vm.headerIcon))])], 1) : _vm._e(), _vm._v(" "), _c('div', {
      staticClass: "text-truncate"
    }, [_vm._t("header")], 2)], 1), _vm._v(" "), _c('v-card-text', {
      "class": [_vm.paddingless ? 'pa-0' : 'pt-7 px-4 pb-2']
    }, [_vm._t("body")], 2), _vm._v(" "), _vm.$slots.actions ? _c('v-card-actions', {
      staticClass: "px-4 pb-3"
    }, [_c('v-spacer'), _vm._v(" "), _vm._t("actions")], 2) : _vm._e()], 1)], 1);
  };

  var __vue_staticRenderFns__$i = [];
  /* style */

  var __vue_inject_styles__$i = function __vue_inject_styles__(inject) {
    if (!inject) return;
    inject("data-v-b6f646a2_0", {
      source: ".dialog-title[data-v-b6f646a2]{display:flex;color:#f1f1f1}.dialog-title .text-truncate[data-v-b6f646a2]{flex:1;text-align:left}",
      map: undefined,
      media: undefined
    });
  };
  /* scoped */


  var __vue_scope_id__$i = "data-v-b6f646a2";
  /* module identifier */

  var __vue_module_identifier__$a = undefined;
  /* functional template */

  var __vue_is_functional_template__$i = false;
  /* component normalizer */

  function __vue_normalize__$i(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "TailorDialog.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;
    {
      var hook;

      if (style) {
        hook = function hook(context) {
          style.call(this, createInjector(context));
        };
      }

      if (hook !== undefined) {
        if (component.functional) {
          // register for functional component in vue file
          var originalRender = component.render;

          component.render = function renderWithStyleInjection(h, context) {
            hook.call(context);
            return originalRender(h, context);
          };
        } else {
          // inject component registration as beforeCreate hook
          var existing = component.beforeCreate;
          component.beforeCreate = existing ? [].concat(existing, hook) : [hook];
        }
      }
    }
    return component;
  }
  /* style inject */


  function __vue_create_injector__$a() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$a.styles || (__vue_create_injector__$a.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());
    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = {
        ids: [],
        parts: [],
        element: undefined
      });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;
        style.ids.push(id);

        if (css.map) {
          // https://developer.chrome.com/devtools/docs/javascript-debugging
          // this makes source maps inside style tags work properly in Chrome
          code += '\n/*# sourceURL=' + css.map.sources[0] + ' */'; // http://stackoverflow.com/a/26603875

          code += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(css.map)))) + ' */';
        }

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';
          if (css.media) el.setAttribute('media', css.media);

          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */


  var TailorDialog = __vue_normalize__$i({
    render: __vue_render__$i,
    staticRenderFns: __vue_staticRenderFns__$i
  }, __vue_inject_styles__$i, __vue_script__$i, __vue_scope_id__$i, __vue_is_functional_template__$i, __vue_module_identifier__$a, __vue_create_injector__$a);

  var getDescendants = utils.activity.getDescendants;
  var TOGGLE_BUTTON = {
    SELECT: {
      label: 'Select all',
      icon: 'checkbox-multiple-marked-outline'
    },
    DESELECT: {
      label: 'Deselect all',
      icon: 'checkbox-multiple-blank-outline'
    }
  };
  var script$h = {
    name: 'select-element',
    inject: ['$schemaService', '$repository', '$api'],
    props: {
      selected: {
        type: Array,
        "default": function _default() {
          return [];
        }
      },
      heading: {
        type: String,
        required: true
      },
      allowedTypes: {
        type: Array,
        required: true
      },
      multiple: {
        type: Boolean,
        "default": true
      },
      submitLabel: {
        type: String,
        "default": 'Save'
      },
      headerIcon: {
        type: String,
        "default": 'mdi-toy-brick-plus-outline'
      },
      onlyCurrentRepo: {
        type: Boolean,
        "default": false
      }
    },
    data: function data() {
      return {
        items: {
          activities: [],
          contentContainers: []
        },
        selection: {
          repository: null,
          activity: null,
          elements: []
        },
        loadingContent: false
      };
    },
    computed: {
      currentRepository: function currentRepository(vm) {
        return vm.$repository;
      },
      allElementsSelected: function allElementsSelected(vm) {
        return vm.selection.elements.length === vm.elements.length;
      },
      rootContainerTypes: function rootContainerTypes() {
        var _this$selection$activ;

        var type = (_this$selection$activ = this.selection.activity) === null || _this$selection$activ === void 0 ? void 0 : _this$selection$activ.type;
        return type && this.getContainerTypes(type);
      },
      processedContainers: function processedContainers() {
        var _this = this;

        var activity = this.selection.activity,
            activities = this.items.activities;
        if (!activity || !activities.length) return [];
        var containers = sortBy__default['default'](activities.filter(this.isRootContainer), [this.getTypePosition, 'position', 'createdAt']);
        return flatMap__default['default'](containers, function (it) {
          return [it].concat(_toConsumableArray(_this.getSubcontainers(it)));
        });
      },
      elements: function elements() {
        var _this2 = this;

        var elements = flatMap__default['default'](this.items.contentContainers, 'elements');
        if (!this.allowedTypes.length) return elements;
        return elements.filter(function (it) {
          return _this2.allowedTypes.includes(it.type);
        });
      },
      toggleButton: function toggleButton() {
        var allElementsSelected = this.allElementsSelected,
            elements = this.elements,
            multiple = this.multiple,
            selection = this.selection;
        if (!multiple || !selection.activity || !elements.length) return;
        var SELECT = TOGGLE_BUTTON.SELECT,
            DESELECT = TOGGLE_BUTTON.DESELECT;
        return allElementsSelected ? DESELECT : SELECT;
      }
    },
    methods: {
      getContainerTypes: function getContainerTypes(type) {
        return map__default['default'](this.$schemaService.getSupportedContainers(type), 'type');
      },
      getTypePosition: function getTypePosition(_ref) {
        var type = _ref.type;
        return this.rootContainerTypes.indexOf(type);
      },
      isRootContainer: function isRootContainer(_ref2) {
        var parentId = _ref2.parentId,
            type = _ref2.type;
        var activity = this.selection.activity,
            rootContainerTypes = this.rootContainerTypes;
        return parentId === activity.id && rootContainerTypes.includes(type);
      },
      getSubcontainers: function getSubcontainers(container) {
        var activities = this.items.activities;
        return sortBy__default['default'](getDescendants(activities, container), 'position');
      },
      showActivityElements: async function showActivityElements(activity) {
        var _this3 = this;

        this.selection.activity = activity;
        var processedContainers = this.processedContainers;
        var elements = await this.fetchElements(processedContainers);
        this.items.contentContainers = processedContainers.map(function (container) {
          return _this3.assignElements(container, activity, elements);
        });
      },
      assignElements: function assignElements(container, activity, elements) {
        var containerElements = elements.filter(function (it) {
          return it.activityId === container.id;
        }).map(function (element) {
          return Object.assign({}, element, {
            activity: activity
          });
        });
        return Object.assign({}, container, {
          elements: sortBy__default['default'](containerElements, 'position')
        });
      },
      toggleElementSelection: function toggleElementSelection(element) {
        var elements = this.selection.elements;
        var existing = elements.find(function (it) {
          return it.id === element.id;
        });
        this.selection.elements = existing ? elements.filter(function (it) {
          return it.id !== element.id;
        }) : elements.concat(element);
      },
      toggleSelectAll: function toggleSelectAll() {
        this.selection.elements = this.allElementsSelected ? [] : this.elements;
      },
      deselectActivity: function deselectActivity() {
        this.selection.activity = null;
        this.items.contentContainers = [];
        this.selection.elements = _toConsumableArray(this.selected);
      },
      selectRepository: async function selectRepository(repository) {
        var currentRepository = this.currentRepository;
        this.selection.repository = repository;
        this.deselectActivity();
        this.items.activities = currentRepository.id === repository.id ? currentRepository.activities : await this.fetchActivities(repository);
      },
      fetchActivities: loader(function (repository) {
        return this.$api.fetchActivities(repository.id);
      }, 'loadingContent'),
      fetchElements: loader(function (containers) {
        var repositoryId = this.selection.repository.id;
        var queryOpts = {
          repositoryId: repositoryId,
          ids: containers.map(function (it) {
            return it.id;
          })
        };
        return this.$api.fetchContentElements(queryOpts);
      }, 'loadingContent', 500),
      save: function save() {
        this.$emit('selected', _toConsumableArray(this.selection.elements));
        this.close();
      },
      close: function close() {
        this.$emit('close');
      },
      openInEditor: function openInEditor(elementId) {
        var params = {
          activityId: this.selection.activity.id,
          repositoryId: this.selection.repository.id
        };
        var route = {
          name: 'editor',
          params: params,
          query: {
            elementId: elementId
          }
        };

        var _this$$router$resolve = this.$router.resolve(route),
            href = _this$$router$resolve.href;

        window.open(href, '_blank');
      }
    },
    created: function created() {
      this.selection.elements = _toConsumableArray(this.selected);
      this.selection.repository = this.currentRepository;
      this.items.activities = this.currentRepository.activities;
    },
    components: {
      ContentPreview: ContentPreview,
      SelectActivity: SelectActivity,
      SelectRepository: SelectRepository,
      TailorDialog: TailorDialog
    }
  };
  /* script */

  var __vue_script__$h = script$h;
  /* template */

  var __vue_render__$h = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('tailor-dialog', {
      attrs: {
        "value": true,
        "header-icon": _vm.headerIcon,
        "width": "650",
        "scrollable": ""
      },
      on: {
        "click:outside": _vm.close
      },
      scopedSlots: _vm._u([{
        key: "header",
        fn: function fn() {
          return [_vm._v(_vm._s(_vm.heading))];
        },
        proxy: true
      }, {
        key: "body",
        fn: function fn() {
          return [!_vm.selection.activity ? [_c('select-repository', {
            attrs: {
              "repository": _vm.selection.repository,
              "disabled": _vm.onlyCurrentRepo
            },
            on: {
              "selected": _vm.selectRepository
            }
          }), _vm._v(" "), _vm.loadingContent ? _c('v-progress-circular', {
            staticClass: "mt-5",
            attrs: {
              "indeterminate": ""
            }
          }) : _c('select-activity', {
            attrs: {
              "activities": _vm.items.activities,
              "selected-elements": _vm.selection.elements
            },
            on: {
              "selected": _vm.showActivityElements
            }
          })] : [_vm.toggleButton ? _c('div', {
            staticClass: "d-flex justify-end mb-2 px-4"
          }, [_c('v-btn', {
            attrs: {
              "outlined": ""
            },
            on: {
              "click": _vm.toggleSelectAll
            }
          }, [_c('v-icon', {
            staticClass: "mr-2"
          }, [_vm._v("mdi-" + _vm._s(_vm.toggleButton.icon))]), _vm._v("\n          " + _vm._s(_vm.toggleButton.label) + "\n        ")], 1)], 1) : _vm._e(), _vm._v(" "), _vm.loadingContent ? _c('v-progress-circular', {
            staticClass: "mt-5",
            attrs: {
              "indeterminate": ""
            }
          }) : _c('content-preview', {
            attrs: {
              "content-containers": _vm.items.contentContainers,
              "selected": _vm.selection.elements,
              "allowed-types": _vm.allowedTypes,
              "multiple": _vm.multiple,
              "selectable": ""
            },
            on: {
              "toggle": _vm.toggleElementSelection,
              "element:open": _vm.openInEditor
            }
          })]];
        },
        proxy: true
      }, {
        key: "actions",
        fn: function fn() {
          return [_vm.selection.activity ? _c('v-btn', {
            staticClass: "mr-2",
            attrs: {
              "text": "",
              "outlined": ""
            },
            on: {
              "click": _vm.deselectActivity
            }
          }, [_c('v-icon', {
            staticClass: "mr-2",
            attrs: {
              "dense": ""
            }
          }, [_vm._v("mdi-arrow-left")]), _vm._v("Back\n    ")], 1) : _vm._e(), _vm._v(" "), _c('v-btn', {
            staticClass: "ml-1",
            attrs: {
              "text": ""
            },
            on: {
              "click": _vm.close
            }
          }, [_vm._v("Cancel")]), _vm._v(" "), _c('v-btn', {
            staticClass: "mr-2",
            attrs: {
              "text": ""
            },
            on: {
              "click": _vm.save
            }
          }, [_vm._v(_vm._s(_vm.submitLabel))])];
        },
        proxy: true
      }])
    });
  };

  var __vue_staticRenderFns__$h = [];
  /* style */

  var __vue_inject_styles__$h = undefined;
  /* scoped */

  var __vue_scope_id__$h = undefined;
  /* functional template */

  var __vue_is_functional_template__$h = false;
  /* component normalizer */

  function __vue_normalize__$h(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "index.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;
    return component;
  }
  /* style inject */

  /* style inject SSR */


  var SelectElement = __vue_normalize__$h({
    render: __vue_render__$h,
    staticRenderFns: __vue_staticRenderFns__$h
  }, __vue_inject_styles__$h, __vue_script__$h, __vue_scope_id__$h, __vue_is_functional_template__$h); //


  var DEFAULT_ELEMENT_WIDTH = 100;
  var LAYOUT = {
    HALF_WIDTH: 6,
    FULL_WIDTH: 12
  };
  var ELEMENT_GROUPS = [{
    name: 'Content Elements',
    icon: 'mdi-set-center'
  }, {
    name: 'Assessments',
    icon: 'mdi-help-rhombus'
  }, {
    name: 'Nongraded questions',
    icon: 'mdi-comment-question-outline'
  }];

  var getQuestionData = function getQuestionData(element, type) {
    var data = {
      width: LAYOUT.FULL_WIDTH
    };
    var question = [{
      id: utils.uuid(),
      data: data,
      type: 'JODIT_HTML',
      embedded: true
    }];
    return Object.assign({
      question: question,
      type: type
    }, element.data);
  };

  var script$g = {
    name: 'tailor-add-element',
    inject: ['$teRegistry'],
    props: {
      items: {
        type: Array,
        required: true
      },
      activity: {
        type: Object,
        "default": null
      },
      position: {
        type: Number,
        "default": null
      },
      layout: {
        type: Boolean,
        "default": true
      },
      include: {
        type: Array,
        "default": null
      },
      show: {
        type: Boolean,
        "default": false
      },
      large: {
        type: Boolean,
        "default": false
      },
      label: {
        type: String,
        "default": 'Add content'
      },
      icon: {
        type: String,
        "default": 'mdi-plus'
      }
    },
    data: function data() {
      return {
        isVisible: false,
        elementWidth: DEFAULT_ELEMENT_WIDTH,
        showElementBrowser: false
      };
    },
    computed: {
      registry: function registry() {
        return this.$teRegistry.all;
      },
      questions: function questions() {
        return filter__default['default'](this.registry, {
          type: 'QUESTION'
        });
      },
      contentElements: function contentElements() {
        var _this = this;

        var items = filter__default['default'](this.registry, function (it) {
          return !utils.isQuestion(it.type);
        });
        if (!this.isSubset) return items;
        return filter__default['default'](items, function (it) {
          return _this.include.includes(it.type);
        });
      },
      assessments: function assessments() {
        var registry = this.registry,
            isSubset = this.isSubset,
            include = this.include,
            questions = this.questions;
        if (isSubset && !include.includes('ASSESSMENT')) return [];
        return filter__default['default'](registry, {
          type: 'ASSESSMENT'
        }).concat(questions.map(function (it) {
          return Object.assign({}, it, {
            type: 'ASSESSMENT'
          });
        }));
      },
      reflections: function reflections() {
        var registry = this.registry,
            isSubset = this.isSubset,
            include = this.include,
            questions = this.questions;
        if (isSubset && !include.includes('REFLECTION')) return [];
        return filter__default['default'](registry, {
          type: 'REFLECTION'
        }).concat(questions.map(function (it) {
          return Object.assign({}, it, {
            type: 'REFLECTION'
          });
        }));
      },
      isSubset: function isSubset() {
        return !!this.include && !!this.include.length;
      },
      library: function library() {
        var groups = [this.contentElements, this.assessments, this.reflections];
        return reduce__default['default'](groups, function (acc, elements, i) {
          if (elements.length) acc.push(Object.assign({}, ELEMENT_GROUPS[i], {
            elements: elements
          }));
          return acc;
        }, []);
      },
      processedWidth: function processedWidth() {
        return this.elementWidth === 50 ? LAYOUT.HALF_WIDTH : LAYOUT.FULL_WIDTH;
      },
      allowedTypes: function allowedTypes() {
        var elementWidth = this.elementWidth,
            include = this.include,
            layout = this.layout,
            library = this.library;
        var elements = flatMap__default['default'](library, 'elements');
        if (!layout) return include || [];
        var allowedElements = elementWidth === DEFAULT_ELEMENT_WIDTH ? elements : reject__default['default'](elements, 'ui.forceFullWidth');
        var allowedTypes = allowedElements.map(function (it) {
          return it.type;
        });
        return include ? intersection__default['default'](include, allowedTypes) : allowedTypes;
      }
    },
    methods: {
      addElements: function addElements(elements) {
        var _this2 = this;

        var positions = utils.getPositions(this.items, this.position, elements.length);
        var items = elements.map(function (it, index) {
          return _this2.buildElement(Object.assign({}, it, {
            position: positions[index]
          }));
        });
        this.$emit('add', items);
        this.isVisible = false;
      },
      buildElement: function buildElement(el) {
        var width = this.processedWidth,
            activity = this.activity;
        var position = el.position,
            subtype = el.subtype,
            _el$data = el.data,
            data = _el$data === void 0 ? {} : _el$data,
            _el$initState = el.initState,
            initState = _el$initState === void 0 ? function () {
          return {};
        } : _el$initState;
        var element = Object.assign({
          position: position
        }, pick__default['default'](el, ['type', 'refs']), {
          data: Object.assign({}, initState(), data, {
            width: width
          })
        });
        var contextData = activity ? {
          activityId: activity.id
        } // If content element within activity
        : {
          id: utils.uuid(),
          embedded: true
        }; // If embed, assign id

        Object.assign(element, contextData);
        if (utils.isQuestion(element.type)) element.data = getQuestionData(element, subtype);
        if (element.type === 'REFLECTION') delete element.data.correct;
        return element;
      },
      onHidden: function onHidden() {
        this.elementWidth = DEFAULT_ELEMENT_WIDTH;
        this.$emit('hidden');
      },
      showElementPicker: function showElementPicker() {
        this.isVisible = true;
      }
    },
    watch: {
      isVisible: function isVisible(val, oldVal) {
        if (!val && oldVal) this.onHidden();
      },
      show: function show(val) {
        return val ? this.showElementPicker() : this.onHidden();
      }
    },
    components: {
      AddNewElement: AddNewElement,
      SelectElement: SelectElement
    }
  };
  /* script */

  var __vue_script__$g = script$g;
  /* template */

  var __vue_render__$g = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      staticClass: "add-element-container"
    }, [_vm._t("default", [_vm.large ? _c('v-btn', {
      staticClass: "mt-3 mb-4",
      attrs: {
        "color": "primary darken-3",
        "text": ""
      },
      on: {
        "click": function click($event) {
          $event.stopPropagation();
          return _vm.showElementPicker($event);
        }
      }
    }, [_c('v-icon', {
      staticClass: "pr-2"
    }, [_vm._v(_vm._s(_vm.icon))]), _vm._v(_vm._s(_vm.label) + "\n    ")], 1) : _c('v-btn', {
      attrs: {
        "color": "primary darken-3",
        "icon": "",
        "text": ""
      },
      on: {
        "click": function click($event) {
          $event.stopPropagation();
          return _vm.showElementPicker($event);
        }
      }
    }, [_c('v-icon', [_vm._v(_vm._s(_vm.icon))])], 1)], {
      "addElement": _vm.showElementPicker
    }), _vm._v(" "), _vm.isVisible ? [_vm.showElementBrowser ? _c('select-element', {
      attrs: {
        "allowed-types": _vm.allowedTypes,
        "submit-label": "Copy",
        "heading": "Copy elements",
        "header-icon": "mdi-content-duplicate",
        "multiple": ""
      },
      on: {
        "selected": _vm.addElements,
        "close": function close($event) {
          _vm.showElementBrowser = false;
        }
      }
    }) : _c('add-new-element', {
      attrs: {
        "library": _vm.library,
        "allowed-types": _vm.allowedTypes
      },
      on: {
        "add": _vm.addElements
      },
      scopedSlots: _vm._u([{
        key: "header",
        fn: function fn() {
          return [_vm.layout ? _c('div', {
            staticClass: "mr-6"
          }, [_c('div', {
            staticClass: "pb-1 caption text-left"
          }, [_vm._v("Element width")]), _vm._v(" "), _c('v-btn-toggle', {
            attrs: {
              "color": "secondary accent-2",
              "mandatory": ""
            },
            model: {
              value: _vm.elementWidth,
              callback: function callback($$v) {
                _vm.elementWidth = $$v;
              },
              expression: "elementWidth"
            }
          }, [_c('v-btn', {
            attrs: {
              "value": 100,
              "height": "38",
              "icon": ""
            }
          }, [_c('v-icon', [_vm._v("mdi-square-outline")])], 1), _vm._v(" "), _c('v-btn', {
            attrs: {
              "value": 50,
              "height": "38",
              "icon": ""
            }
          }, [_c('v-icon', [_vm._v("mdi-select-compare")])], 1)], 1)], 1) : _vm._e(), _vm._v(" "), _c('v-btn', {
            staticClass: "mt-6",
            attrs: {
              "color": "primary darken-3",
              "depressed": ""
            },
            on: {
              "click": function click($event) {
                _vm.showElementBrowser = !_vm.showElementBrowser;
              }
            }
          }, [_c('v-icon', {
            staticClass: "mr-2",
            attrs: {
              "dense": ""
            }
          }, [_vm._v("mdi-content-copy")]), _vm._v("\n          Copy existing\n        ")], 1)];
        },
        proxy: true
      }], null, false, 2543524328),
      model: {
        value: _vm.isVisible,
        callback: function callback($$v) {
          _vm.isVisible = $$v;
        },
        expression: "isVisible"
      }
    })] : _vm._e()], 2);
  };

  var __vue_staticRenderFns__$g = [];
  /* style */

  var __vue_inject_styles__$g = undefined;
  /* scoped */

  var __vue_scope_id__$g = undefined;
  /* functional template */

  var __vue_is_functional_template__$g = false;
  /* component normalizer */

  function __vue_normalize__$g(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "index.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;
    return component;
  }
  /* style inject */

  /* style inject SSR */


  var AddElement = __vue_normalize__$g({
    render: __vue_render__$g,
    staticRenderFns: __vue_staticRenderFns__$g
  }, __vue_inject_styles__$g, __vue_script__$g, __vue_scope_id__$g, __vue_is_functional_template__$g); //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //


  var script$f = {
    name: 'question-controls',
    props: {
      isEditing: {
        type: Boolean,
        "default": false
      }
    },
    methods: {
      save: function save() {
        var _this = this; // Make sure all other handlers are executed prior to save


        setTimeout(function () {
          return _this.$emit('save');
        }, 0);
      }
    }
  };
  /* script */

  var __vue_script__$f = script$f;
  /* template */

  var __vue_render__$f = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      staticClass: "d-flex pb-4"
    }, [_c('v-spacer'), _vm._v(" "), _vm.isEditing ? _c('div', [_c('v-btn', {
      attrs: {
        "text": "",
        "large": ""
      },
      on: {
        "click": function click($event) {
          return _vm.$emit('cancel');
        }
      }
    }, [_vm._v("Cancel")]), _vm._v(" "), _c('v-btn', {
      attrs: {
        "color": "green darken-3",
        "text": "",
        "large": ""
      },
      on: {
        "click": _vm.save
      }
    }, [_c('v-icon', {
      staticClass: "pr-1"
    }, [_vm._v("mdi-check")]), _vm._v("\n      Save\n    ")], 1)], 1) : _c('v-btn', {
      attrs: {
        "color": "primary darken-4",
        "text": "",
        "large": ""
      },
      on: {
        "click": function click($event) {
          return _vm.$emit('edit');
        }
      }
    }, [_vm._v("\n    Edit\n  ")])], 1);
  };

  var __vue_staticRenderFns__$f = [];
  /* style */

  var __vue_inject_styles__$f = undefined;
  /* scoped */

  var __vue_scope_id__$f = undefined;
  /* functional template */

  var __vue_is_functional_template__$f = false;
  /* component normalizer */

  function __vue_normalize__$f(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "Controls.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;
    return component;
  }
  /* style inject */

  /* style inject SSR */


  var Controls = __vue_normalize__$f({
    render: __vue_render__$f,
    staticRenderFns: __vue_staticRenderFns__$f
  }, __vue_inject_styles__$f, __vue_script__$f, __vue_scope_id__$f, __vue_is_functional_template__$f);

  var QUILL_OPTIONS = {
    modules: {
      toolbar: [['bold', 'italic', 'underline', 'strike'], ['blockquote', 'code-block'], [{
        list: 'ordered'
      }, {
        list: 'bullet'
      }], [{
        script: 'sub'
      }, {
        script: 'super'
      }], [{
        color: []
      }, {
        background: []
      }], ['link']]
    }
  };

  var getAnswerType = function getAnswerType(isGraded) {
    return isGraded ? 'Answer' : 'Option';
  };

  var getButtonLabel = function getButtonLabel(isExpanded) {
    return isExpanded ? 'hide' : 'show';
  };

  var script$e = {
    name: 'feedback',
    props: {
      answers: {
        type: [Array, Boolean],
        "default": null
      },
      feedback: {
        type: Object,
        "default": function _default() {
          return {};
        }
      },
      isEditing: {
        type: Boolean,
        "default": false
      },
      isGraded: {
        type: Boolean,
        "default": false
      }
    },
    data: function data(vm) {
      return {
        isExpanded: some__default['default'](vm.feedback)
      };
    },
    computed: {
      quillOptions: function quillOptions() {
        return QUILL_OPTIONS;
      },
      answerType: function answerType(vm) {
        return getAnswerType(vm.isGraded);
      },
      buttonLabel: function buttonLabel(vm) {
        return getButtonLabel(vm.isExpanded);
      },
      processedAnswers: function processedAnswers(vm) {
        return isArray__default['default'](vm.answers) ? vm.answers : ['True', 'False'];
      }
    },
    methods: {
      updateFeedback: function updateFeedback(_ref, index) {
        var html = _ref.html;
        this.$emit('update', _defineProperty({}, index, html));
      },
      toggleExpand: function toggleExpand() {
        this.isExpanded = !this.isExpanded;
      }
    },
    watch: {
      isEditing: function isEditing(val) {
        if (!some__default['default'](this.feedback)) return;
        if (val) this.isExpanded = true;
      }
    },
    components: {
      QuillEditor: vueQuillEditor.quillEditor
    }
  };
  /* script */

  var __vue_script__$e = script$e;
  /* template */

  var __vue_render__$e = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      staticClass: "px-1"
    }, [_c('div', [_c('span', {
      staticClass: "subtitle-2"
    }, [_vm._v("Feedback")]), _vm._v(" "), _c('v-btn', {
      staticClass: "ml-1",
      attrs: {
        "text": "",
        "small": ""
      },
      on: {
        "click": _vm.toggleExpand
      }
    }, [_vm._v("\n      " + _vm._s(_vm.buttonLabel) + "\n    ")])], 1), _vm._v(" "), _c('transition', {
      attrs: {
        "name": "fade"
      }
    }, [_vm.isExpanded ? _c('div', {
      staticClass: "feedback-content"
    }, _vm._l(_vm.processedAnswers, function (answer, i) {
      return _c('v-row', {
        key: i
      }, [_c('v-col', [_c('div', {
        staticClass: "feedback-info mb-4"
      }, [_c('span', {
        staticClass: "answer-type subtitle-2"
      }, [_vm._v(_vm._s(_vm.answerType) + " " + _vm._s(i + 1) + ":")]), _vm._v(" "), _c('span', [_vm._v(_vm._s(answer || 'Answer not added.'))])]), _vm._v(" "), _vm.isEditing ? _c('quill-editor', {
        staticClass: "grey lighten-3",
        attrs: {
          "options": _vm.quillOptions,
          "content": _vm.feedback[i]
        },
        on: {
          "change": function change($event) {
            return _vm.updateFeedback($event, i);
          }
        }
      }) : _c('div', {
        staticClass: "feedback-preview"
      }, [_vm.feedback[i] ? _c('div', {
        domProps: {
          "innerHTML": _vm._s(_vm.feedback[i])
        }
      }) : _c('i', [_vm._v("Feedback not added.")])])], 1)], 1);
    }), 1) : _vm._e()])], 1);
  };

  var __vue_staticRenderFns__$e = [];
  /* style */

  var __vue_inject_styles__$e = undefined;
  /* scoped */

  var __vue_scope_id__$e = undefined;
  /* functional template */

  var __vue_is_functional_template__$e = false;
  /* component normalizer */

  function __vue_normalize__$e(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "Feedback.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;
    return component;
  }
  /* style inject */

  /* style inject SSR */


  var Feedback = __vue_normalize__$e({
    render: __vue_render__$e,
    staticRenderFns: __vue_staticRenderFns__$e
  }, __vue_inject_styles__$e, __vue_script__$e, __vue_scope_id__$e, __vue_is_functional_template__$e); //


  var script$d = {
    name: 'tailor-contained-content',
    inheritAttrs: false,
    props: {
      element: {
        type: Object,
        required: true
      },
      isDisabled: {
        type: Boolean,
        "default": false
      },
      isDragged: {
        type: Boolean,
        "default": false
      },
      setWidth: {
        type: Boolean,
        "default": true
      },
      dense: {
        type: Boolean,
        "default": false
      }
    },
    data: function data() {
      return {
        isHovered: false
      };
    },
    computed: {
      bindings: function bindings() {
        var element = this.element,
            isDisabled = this.isDisabled,
            isDragged = this.isDragged,
            isHovered = this.isHovered,
            dense = this.dense,
            attrs = this.$attrs;
        return Object.assign({
          element: element,
          isDisabled: isDisabled,
          isDragged: isDragged,
          isHovered: isHovered,
          dense: dense
        }, attrs);
      },
      widthClass: function widthClass() {
        var element = this.element,
            setWidth = this.setWidth;
        return setWidth ? "col-xs-".concat(get__default['default'](element, 'data.width', 12)) : '';
      }
    },
    methods: {
      scrollContainer: throttle__default['default'](function (e) {
        var scrollUp = e.y < 200;
        var scrollDown = e.y > window.innerHeight - 200;
        if (scrollUp || scrollDown) window.scrollBy(0, scrollUp ? -30 : 30);
      }, 20)
    },
    components: {
      ContentElement: ContentElement$1
    }
  };
  /* script */

  var __vue_script__$d = script$d;
  /* template */

  var __vue_render__$d = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      staticClass: "contained-content",
      "class": [_vm.widthClass, {
        disabled: _vm.isDisabled,
        hovered: _vm.isHovered
      }],
      on: {
        "mouseover": function mouseover($event) {
          _vm.isHovered = true;
        },
        "mouseleave": function mouseleave($event) {
          _vm.isHovered = false;
        },
        "dragstart": function dragstart($event) {
          return _vm.$emit('dragstart');
        },
        "dragend": function dragend($event) {
          return _vm.$emit('dragend');
        },
        "dragover": _vm.scrollContainer
      }
    }, [!_vm.isDisabled ? _c('span', {
      staticClass: "drag-handle"
    }, [_c('span', {
      staticClass: "mdi mdi-drag-vertical"
    })]) : _vm._e(), _vm._v(" "), _c('content-element', _vm._b({
      on: {
        "add": function add($event) {
          return _vm.$emit('add', $event);
        },
        "save": function save($event) {
          return _vm.$emit('save', $event);
        },
        "save:meta": function saveMeta($event) {
          return _vm.$emit('save:meta', $event);
        },
        "delete": function _delete($event) {
          return _vm.$emit('delete');
        }
      }
    }, 'content-element', _vm.bindings, false))], 1);
  };

  var __vue_staticRenderFns__$d = [];
  /* style */

  var __vue_inject_styles__$d = function __vue_inject_styles__(inject) {
    if (!inject) return;
    inject("data-v-cb586726_0", {
      source: ".drag-handle[data-v-cb586726]{position:absolute;left:-3px;z-index:2;width:26px;opacity:0}.drag-handle .mdi[data-v-cb586726]{color:#888;font-size:28px}.hovered .drag-handle[data-v-cb586726]{opacity:1;transition:opacity .6s ease-in-out;cursor:pointer}.disabled .drag-handle[data-v-cb586726]{display:none}.contained-content[data-v-cb586726]{position:relative;margin:7px 0;padding:0}",
      map: undefined,
      media: undefined
    });
  };
  /* scoped */


  var __vue_scope_id__$d = "data-v-cb586726";
  /* module identifier */

  var __vue_module_identifier__$9 = undefined;
  /* functional template */

  var __vue_is_functional_template__$d = false;
  /* component normalizer */

  function __vue_normalize__$d(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "ContainedContent.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;
    {
      var hook;

      if (style) {
        hook = function hook(context) {
          style.call(this, createInjector(context));
        };
      }

      if (hook !== undefined) {
        if (component.functional) {
          // register for functional component in vue file
          var originalRender = component.render;

          component.render = function renderWithStyleInjection(h, context) {
            hook.call(context);
            return originalRender(h, context);
          };
        } else {
          // inject component registration as beforeCreate hook
          var existing = component.beforeCreate;
          component.beforeCreate = existing ? [].concat(existing, hook) : [hook];
        }
      }
    }
    return component;
  }
  /* style inject */


  function __vue_create_injector__$9() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$9.styles || (__vue_create_injector__$9.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());
    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = {
        ids: [],
        parts: [],
        element: undefined
      });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;
        style.ids.push(id);

        if (css.map) {
          // https://developer.chrome.com/devtools/docs/javascript-debugging
          // this makes source maps inside style tags work properly in Chrome
          code += '\n/*# sourceURL=' + css.map.sources[0] + ' */'; // http://stackoverflow.com/a/26603875

          code += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(css.map)))) + ' */';
        }

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';
          if (css.media) el.setAttribute('media', css.media);

          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */


  var ContainedContent = __vue_normalize__$d({
    render: __vue_render__$d,
    staticRenderFns: __vue_staticRenderFns__$d
  }, __vue_inject_styles__$d, __vue_script__$d, __vue_scope_id__$d, __vue_is_functional_template__$d, __vue_module_identifier__$9, __vue_create_injector__$9); //
  //
  //
  //
  //
  //
  //
  //


  var script$c = {
    name: 'tailor-input-error',
    props: {
      error: {
        type: String,
        "default": ''
      }
    }
  };
  /* script */

  var __vue_script__$c = script$c;
  /* template */

  var __vue_render__$c = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('transition', {
      attrs: {
        "name": "message-transition"
      }
    }, [!!_vm.error ? _c('div', {
      staticClass: "input-error"
    }, [_vm._v("\n    " + _vm._s(_vm.error) + "\n  ")]) : _vm._e()]);
  };

  var __vue_staticRenderFns__$c = [];
  /* style */

  var __vue_inject_styles__$c = function __vue_inject_styles__(inject) {
    if (!inject) return;
    inject("data-v-ff8d03d8_0", {
      source: ".input-error[data-v-ff8d03d8]{color:var(--v-error-base);font-size:.75rem}",
      map: undefined,
      media: undefined
    });
  };
  /* scoped */


  var __vue_scope_id__$c = "data-v-ff8d03d8";
  /* module identifier */

  var __vue_module_identifier__$8 = undefined;
  /* functional template */

  var __vue_is_functional_template__$c = false;
  /* component normalizer */

  function __vue_normalize__$c(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "InputError.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;
    {
      var hook;

      if (style) {
        hook = function hook(context) {
          style.call(this, createInjector(context));
        };
      }

      if (hook !== undefined) {
        if (component.functional) {
          // register for functional component in vue file
          var originalRender = component.render;

          component.render = function renderWithStyleInjection(h, context) {
            hook.call(context);
            return originalRender(h, context);
          };
        } else {
          // inject component registration as beforeCreate hook
          var existing = component.beforeCreate;
          component.beforeCreate = existing ? [].concat(existing, hook) : [hook];
        }
      }
    }
    return component;
  }
  /* style inject */


  function __vue_create_injector__$8() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$8.styles || (__vue_create_injector__$8.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());
    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = {
        ids: [],
        parts: [],
        element: undefined
      });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;
        style.ids.push(id);

        if (css.map) {
          // https://developer.chrome.com/devtools/docs/javascript-debugging
          // this makes source maps inside style tags work properly in Chrome
          code += '\n/*# sourceURL=' + css.map.sources[0] + ' */'; // http://stackoverflow.com/a/26603875

          code += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(css.map)))) + ' */';
        }

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';
          if (css.media) el.setAttribute('media', css.media);

          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */


  var InputError = __vue_normalize__$c({
    render: __vue_render__$c,
    staticRenderFns: __vue_staticRenderFns__$c
  }, __vue_inject_styles__$c, __vue_script__$c, __vue_scope_id__$c, __vue_is_functional_template__$c, __vue_module_identifier__$8, __vue_create_injector__$8); //


  var DRAG_OPTIONS = {
    handle: '.drag-handle',
    scrollSensitivity: 125,
    scrollSpeed: 15
  };
  var script$b = {
    name: 'question',
    props: {
      assessment: {
        type: Object,
        required: true
      },
      errors: {
        type: Array,
        "default": function _default() {
          return [];
        }
      },
      isEditing: {
        type: Boolean,
        "default": false
      }
    },
    data: function data() {
      return {
        isFocused: false
      };
    },
    computed: Object.assign({}, vueRadio.mapChannels({
      editorChannel: 'editor'
    }), {
      question: {
        get: function get() {
          return cloneDeep__default['default'](this.assessment.data.question);
        },
        set: function set(question) {
          this.$emit('update', {
            question: question
          });
        }
      },
      questionError: function questionError(vm) {
        return head__default['default'](utils.assessment.getErrorMessages(vm.errors, 'question'));
      },
      dragOptions: function dragOptions() {
        return DRAG_OPTIONS;
      }
    }),
    methods: {
      addQuestionElements: function addQuestionElements(elements) {
        var question = cloneDeep__default['default'](this.assessment.data.question);
        this.$emit('update', {
          question: question.concat(elements)
        });
      },
      updateElement: function updateElement(element, data) {
        if (!this.isEditing) return;
        var question = cloneDeep__default['default'](this.assessment.data.question);
        var index = findIndex__default['default'](question, {
          id: element.id
        });
        if (index === -1) return;
        element = Object.assign({}, question[index], {
          data: data
        });
        this.$emit('update', {
          question: set__default['default'](question, index, element)
        });
      },
      deleteElement: function deleteElement(element) {
        var question = cloneDeep__default['default'](this.assessment.data.question);
        var index = findIndex__default['default'](question, {
          id: element.id
        });
        if (index === -1) return;
        pullAt__default['default'](question, index);
        this.$emit('update', {
          question: question
        });
      }
    },
    created: function created() {
      var _this = this;

      this.editorChannel.on('element:focus', function () {
        var element = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        _this.isFocused = !!find__default['default'](_this.question, {
          id: element.id
        });
      });
    },
    components: {
      AddElement: AddElement,
      ContainedContent: ContainedContent,
      Draggable: Draggable__default['default'],
      InputError: InputError
    }
  };
  /* script */

  var __vue_script__$b = script$b;
  /* template */

  var __vue_render__$b = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', [_c('div', {
      staticClass: "subtitle-2 mb-2"
    }, [_vm._v("Question")]), _vm._v(" "), _c('div', {
      "class": ['question-container', {
        focused: _vm.isFocused,
        disabled: !_vm.isEditing,
        incorrect: !!_vm.questionError
      }]
    }, [_c('draggable', _vm._b({
      staticClass: "row",
      model: {
        value: _vm.question,
        callback: function callback($$v) {
          _vm.question = $$v;
        },
        expression: "question"
      }
    }, 'draggable', _vm.dragOptions, false), _vm._l(_vm.question, function (element) {
      return _c('contained-content', {
        key: element.id,
        staticClass: "mb-4",
        attrs: {
          "element": element,
          "is-disabled": !_vm.isEditing,
          "dense": ""
        },
        on: {
          "save": function save($event) {
            return _vm.updateElement(element, $event);
          },
          "delete": function _delete($event) {
            return _vm.deleteElement(element);
          }
        }
      });
    }), 1)], 1), _vm._v(" "), _c('add-element', {
      "class": {
        invisible: !_vm.isEditing
      },
      attrs: {
        "items": _vm.question,
        "layout": false,
        "position": _vm.question.length,
        "disabled": !_vm.isEditing,
        "include": ['JODIT_HTML', 'IMAGE', 'EMBED', 'HTML']
      },
      on: {
        "add": _vm.addQuestionElements
      },
      scopedSlots: _vm._u([{
        key: "default",
        fn: function fn(ref) {
          var addElement = ref.addElement;
          return [_c('div', {
            staticClass: "d-flex justify-space-between mt-2 pl-3"
          }, [_c('input-error', {
            attrs: {
              "error": _vm.questionError
            }
          }), _vm._v(" "), _c('v-btn', {
            staticClass: "mt-2 ml-auto px-2",
            attrs: {
              "text": ""
            },
            on: {
              "click": addElement
            }
          }, [_c('v-icon', {
            staticClass: "mr-1",
            attrs: {
              "dense": ""
            }
          }, [_vm._v("mdi-plus")]), _vm._v("\n        Add question element\n      ")], 1)], 1)];
        }
      }])
    })], 1);
  };

  var __vue_staticRenderFns__$b = [];
  /* style */

  var __vue_inject_styles__$b = function __vue_inject_styles__(inject) {
    if (!inject) return;
    inject("data-v-28708166_0", {
      source: ".question-container[data-v-28708166]{position:relative;min-height:8.75rem;padding:1rem 3rem 0 2.5rem;text-align:center;background:#ebebeb;border-radius:.125rem;transition:.3s cubic-bezier(.25,.8,.5,1)}.question-container[data-v-28708166]::after,.question-container[data-v-28708166]::before{content:'';position:absolute;bottom:-1px;left:0;width:100%;transition:.3s cubic-bezier(.25,.8,.5,1)}.question-container[data-v-28708166]::before{border-style:solid;border-width:thin 0 0 0}.question-container[data-v-28708166]::after{border-style:solid;border-width:thin 0 thin 0;transform:scaleX(0)}.question-container[data-v-28708166]:not(.focused):not(.disabled):not(.incorrect):hover{background:#dcdcdc}.question-container[data-v-28708166]:not(.focused):not(.disabled):not(.incorrect):hover  .content-element{border-color:#bbb}.focused[data-v-28708166]::after{transform:scaleX(1)}.disabled[data-v-28708166]{color:rgba(0,0,0,.38)}.disabled[data-v-28708166]::before{border-image:repeating-linear-gradient(to right,rgba(0,0,0,.38) 0,rgba(0,0,0,.38) .125rem,transparent .125rem,transparent .25rem) 1 repeat}.incorrect[data-v-28708166]::after,.incorrect[data-v-28708166]::before{border-color:var(--v-error-base)}.invisible[data-v-28708166]{visibility:none}",
      map: undefined,
      media: undefined
    });
  };
  /* scoped */


  var __vue_scope_id__$b = "data-v-28708166";
  /* module identifier */

  var __vue_module_identifier__$7 = undefined;
  /* functional template */

  var __vue_is_functional_template__$b = false;
  /* component normalizer */

  function __vue_normalize__$b(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "Question.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;
    {
      var hook;

      if (style) {
        hook = function hook(context) {
          style.call(this, createInjector(context));
        };
      }

      if (hook !== undefined) {
        if (component.functional) {
          // register for functional component in vue file
          var originalRender = component.render;

          component.render = function renderWithStyleInjection(h, context) {
            hook.call(context);
            return originalRender(h, context);
          };
        } else {
          // inject component registration as beforeCreate hook
          var existing = component.beforeCreate;
          component.beforeCreate = existing ? [].concat(existing, hook) : [hook];
        }
      }
    }
    return component;
  }
  /* style inject */


  function __vue_create_injector__$7() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$7.styles || (__vue_create_injector__$7.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());
    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = {
        ids: [],
        parts: [],
        element: undefined
      });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;
        style.ids.push(id);

        if (css.map) {
          // https://developer.chrome.com/devtools/docs/javascript-debugging
          // this makes source maps inside style tags work properly in Chrome
          code += '\n/*# sourceURL=' + css.map.sources[0] + ' */'; // http://stackoverflow.com/a/26603875

          code += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(css.map)))) + ' */';
        }

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';
          if (css.media) el.setAttribute('media', css.media);

          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */


  var Question = __vue_normalize__$b({
    render: __vue_render__$b,
    staticRenderFns: __vue_staticRenderFns__$b
  }, __vue_inject_styles__$b, __vue_script__$b, __vue_scope_id__$b, __vue_is_functional_template__$b, __vue_module_identifier__$7, __vue_create_injector__$7); //


  var resolveComponentName = function resolveComponentName(type) {
    return utils.getComponentName(utils.processAnswerType(type));
  };

  var WITH_FEEDBACK = ['MC', 'SC', 'TF'];
  var TEXT_CONTAINERS$1 = ['JODIT_HTML', 'HTML'];
  var validationOptions = {
    recursive: true,
    abortEarly: false
  };
  var script$a = {
    name: 'tce-question-container',
    inject: ['$teRegistry'],
    props: {
      element: {
        type: Object,
        required: true
      },
      isDisabled: {
        type: Boolean,
        "default": false
      }
    },
    data: function data(vm) {
      return {
        isEditing: !vm.element.id,
        editedElement: cloneDeep__default['default'](vm.element),
        undoState: cloneDeep__default['default'](vm.element),
        errors: [],
        alert: {}
      };
    },
    computed: {
      answerType: function answerType(vm) {
        return vm.element.data.type;
      },
      isGraded: function isGraded(vm) {
        return vm.element.type === 'ASSESSMENT';
      },
      showFeedback: function showFeedback(vm) {
        return WITH_FEEDBACK.includes(vm.answerType);
      },
      componentName: function componentName(vm) {
        return resolveComponentName(vm.answerType);
      },
      config: function config(vm) {
        return vm.$teRegistry.get(vm.answerType);
      },
      hintErrors: function hintErrors(vm) {
        return utils.assessment.getErrorMessages(vm.errors, 'hint');
      },
      schema: function schema() {
        var schema = this.config.schema;
        return ObjectSchema().shape(Object.assign({}, baseSchema, this.isGraded ? schema : omit__default['default'](schema, ['correct'])));
      }
    },
    methods: {
      edit: function edit() {
        this.editedElement = cloneDeep__default['default'](this.element);
        this.undoState = cloneDeep__default['default'](this.element);
        this.isEditing = true;
      },
      update: function update(data, validate) {
        var _this = this;

        Object.assign(this.editedElement.data, data);

        if (validate && !isEmpty__default['default'](this.errors)) {
          this.errors = [];
          this.validate()["catch"](function (err) {
            return _this.errors = err.inner;
          });
        }

        this.$emit('add', this.editedElement);
      },
      save: function save() {
        var _this2 = this;

        this.validate().then(function () {
          _this2.$emit('save', cloneDeep__default['default'](_this2.editedElement.data));

          _this2.isEditing = false;
          _this2.errors = [];
        })["catch"](function (err) {
          return _this2.errors = err.inner;
        });
      },
      cancel: function cancel() {
        if (!this.editedElement.id) return this.$emit('delete');
        this.$emit('add', cloneDeep__default['default'](this.undoState));
        this.editedElement = cloneDeep__default['default'](this.undoState);
        this.isEditing = false;
        this.errors = [];
        this.alert = {};
      },
      validate: function validate() {
        return this.schema.validate(this.editedElement.data, validationOptions);
      },
      updateFeedback: function updateFeedback(data) {
        var element = this.editedElement;
        this.$set(element.data, 'feedback', Object.assign({}, element.data.feedback, data));
      }
    },
    components: {
      Controls: Controls,
      Feedback: Feedback,
      Question: Question
    }
  };
  var question = ArraySchema().test('has-text', 'Please define question', function (question) {
    return !!question.find(containsText);
  });

  function containsText(asset) {
    return TEXT_CONTAINERS$1.includes(asset.type) && asset.data.content && asset.data.content.trim().length > 0;
  }

  var baseSchema = {
    question: question,
    hint: StringSchema().trim().max(500),
    _refs: ObjectSchema().shape({
      objectiveId: NumberSchema().integer().positive()
    })
  };
  /* script */

  var __vue_script__$a = script$a;
  /* template */

  var __vue_render__$a = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('v-card', {
      staticClass: "tce-question-container my-2 grey lighten-5"
    }, [_c('v-toolbar', {
      staticClass: "mb-5 px-0 elevation-2 text-left",
      attrs: {
        "color": "primary darken-3",
        "height": "36",
        "dark": ""
      }
    }, [_c('v-icon', {
      staticClass: "mr-2",
      attrs: {
        "color": "secondary lighten-2",
        "size": "18"
      }
    }, [_vm._v("mdi-help")]), _vm._v(" "), _c('span', {
      staticClass: "subtitle-2"
    }, [_vm._v(_vm._s(_vm.config.name))])], 1), _vm._v(" "), _vm._t("default", null, {
      "isEditing": _vm.isEditing
    }), _vm._v(" "), _c('div', {
      staticClass: "content"
    }, [_c('question', {
      attrs: {
        "assessment": _vm.editedElement,
        "is-editing": _vm.isEditing,
        "errors": _vm.errors
      },
      on: {
        "update": _vm.update
      }
    }), _vm._v(" "), _c(_vm.componentName, {
      tag: "component",
      staticClass: "tce-answer",
      attrs: {
        "assessment": _vm.editedElement.data,
        "is-editing": _vm.isEditing,
        "is-graded": _vm.isGraded,
        "errors": _vm.errors
      },
      on: {
        "update": _vm.update,
        "alert": function alert($event) {
          _vm.alert = $event;
        }
      }
    }), _vm._v(" "), _c('div', {
      staticClass: "subtitle-2 mb-2"
    }, [_vm._v("Hint")]), _vm._v(" "), _c('v-text-field', {
      attrs: {
        "error-messages": _vm.hintErrors,
        "disabled": !_vm.isEditing,
        "placeholder": "Optional hint...",
        "color": "blue-darken darken-3",
        "filled": "",
        "clearable": ""
      },
      model: {
        value: _vm.editedElement.data.hint,
        callback: function callback($$v) {
          _vm.$set(_vm.editedElement.data, "hint", $$v);
        },
        expression: "editedElement.data.hint"
      }
    }), _vm._v(" "), _vm.showFeedback ? _c('feedback', {
      attrs: {
        "answers": _vm.editedElement.data.answers,
        "feedback": _vm.editedElement.data.feedback,
        "is-graded": _vm.isGraded,
        "is-editing": _vm.isEditing
      },
      on: {
        "update": _vm.updateFeedback
      }
    }) : _vm._e(), _vm._v(" "), _c('v-alert', {
      directives: [{
        name: "show",
        rawName: "v-show",
        value: _vm.alert.text,
        expression: "alert.text"
      }],
      staticClass: "mt-4",
      attrs: {
        "type": _vm.alert.type,
        "prominent": ""
      }
    }, [_vm._v("\n      " + _vm._s(_vm.alert.text) + "\n    ")]), _vm._v(" "), !_vm.isDisabled ? _c('controls', {
      staticClass: "controls",
      attrs: {
        "is-editing": _vm.isEditing
      },
      on: {
        "edit": _vm.edit,
        "save": _vm.save,
        "cancel": _vm.cancel
      }
    }) : _vm._e()], 1)], 2);
  };

  var __vue_staticRenderFns__$a = [];
  /* style */

  var __vue_inject_styles__$a = function __vue_inject_styles__(inject) {
    if (!inject) return;
    inject("data-v-b4ecdf22_0", {
      source: ".tce-question-container[data-v-b4ecdf22]{min-height:25rem;background-color:#fff;overflow:visible;text-align:left}.tce-question-container[data-v-b4ecdf22]  .title{font-weight:400}.tce-question-container .content[data-v-b4ecdf22]{margin:.5rem 1.625rem}@media (max-width:1263px){.tce-question-container .content[data-v-b4ecdf22]{margin:.5rem}}.tce-question-container .tce-answer[data-v-b4ecdf22]{overflow:hidden}.disabled .controls[data-v-b4ecdf22]{display:none}",
      map: undefined,
      media: undefined
    });
  };
  /* scoped */


  var __vue_scope_id__$a = "data-v-b4ecdf22";
  /* module identifier */

  var __vue_module_identifier__$6 = undefined;
  /* functional template */

  var __vue_is_functional_template__$a = false;
  /* component normalizer */

  function __vue_normalize__$a(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "index.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;
    {
      var hook;

      if (style) {
        hook = function hook(context) {
          style.call(this, createInjector(context));
        };
      }

      if (hook !== undefined) {
        if (component.functional) {
          // register for functional component in vue file
          var originalRender = component.render;

          component.render = function renderWithStyleInjection(h, context) {
            hook.call(context);
            return originalRender(h, context);
          };
        } else {
          // inject component registration as beforeCreate hook
          var existing = component.beforeCreate;
          component.beforeCreate = existing ? [].concat(existing, hook) : [hook];
        }
      }
    }
    return component;
  }
  /* style inject */


  function __vue_create_injector__$6() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$6.styles || (__vue_create_injector__$6.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());
    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = {
        ids: [],
        parts: [],
        element: undefined
      });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;
        style.ids.push(id);

        if (css.map) {
          // https://developer.chrome.com/devtools/docs/javascript-debugging
          // this makes source maps inside style tags work properly in Chrome
          code += '\n/*# sourceURL=' + css.map.sources[0] + ' */'; // http://stackoverflow.com/a/26603875

          code += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(css.map)))) + ' */';
        }

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';
          if (css.media) el.setAttribute('media', css.media);

          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */


  var TceQuestionContainer = __vue_normalize__$a({
    render: __vue_render__$a,
    staticRenderFns: __vue_staticRenderFns__$a
  }, __vue_inject_styles__$a, __vue_script__$a, __vue_scope_id__$a, __vue_is_functional_template__$a, __vue_module_identifier__$6, __vue_create_injector__$6); //


  var TEXT_CONTAINERS = ['JODIT_HTML', 'HTML'];
  var blankRegex = /(@blank)/g;
  var htmlRegex = /(<\/?[^>]+(>|$))|&nbsp;/g;

  var getTextAssets = function getTextAssets(item) {
    return filter__default['default'](item, function (it) {
      return TEXT_CONTAINERS.includes(it.type);
    });
  };

  var script$9 = {
    name: 'tailor-assessment-item',
    inject: ['$teRegistry', '$editorState'],
    props: {
      assessment: {
        type: Object,
        required: true
      },
      expanded: {
        type: Boolean,
        "default": false
      },
      draggable: {
        type: Boolean,
        "default": false
      },
      isDisabled: {
        type: Boolean,
        "default": false
      }
    },
    data: function data() {
      return {
        hover: false
      };
    },
    computed: {
      elementConfig: function elementConfig() {
        return this.$teRegistry.get(this.assessment.data.type);
      },
      question: function question() {
        var textAssets = getTextAssets(this.assessment.data.question);
        var question = map__default['default'](textAssets, 'data.content').join(' ');
        return question.replace(htmlRegex, '').replace(blankRegex, function () {
          return '____';
        });
      }
    },
    methods: {
      save: function save(data) {
        var assessment = cloneDeep__default['default'](this.assessment);
        Object.assign(assessment.data, data);
        this.$emit('save', assessment);
      }
    },
    components: {
      PublishDiffChip: PublishDiffChip,
      TceQuestionContainer: TceQuestionContainer
    }
  };
  /* script */

  var __vue_script__$9 = script$9;
  /* template */

  var __vue_render__$9 = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('li', {
      staticClass: "list-group-item assessment-item elevation-1",
      "class": [_vm.assessment.changeSincePublish, {
        hover: _vm.hover,
        expanded: _vm.expanded,
        diff: _vm.$editorState.isPublishDiff
      }],
      on: {
        "mouseenter": function mouseenter($event) {
          _vm.hover = true;
        },
        "mouseleave": function mouseleave($event) {
          _vm.hover = false;
        }
      }
    }, [_vm.draggable ? _c('span', {
      staticClass: "drag-handle"
    }, [_c('v-icon', [_vm._v("mdi-drag-vertical")])], 1) : _vm._e(), _vm._v(" "), _vm.expanded ? _c('tce-question-container', {
      staticClass: "question-container",
      attrs: {
        "element": _vm.assessment,
        "is-disabled": _vm.isDisabled
      },
      on: {
        "save": _vm.save,
        "delete": function _delete($event) {
          return _vm.$emit('delete');
        }
      },
      scopedSlots: _vm._u([{
        key: "default",
        fn: function fn(ref) {
          var isEditing = ref.isEditing;
          return [_c('div', {
            staticClass: "px-6 d-flex justify-end"
          }, [_c('v-btn', {
            staticClass: "px-2",
            attrs: {
              "text": "",
              "small": ""
            },
            on: {
              "click": function click($event) {
                return _vm.$emit('selected');
              }
            }
          }, [_c('v-icon', {
            staticClass: "mr-2",
            attrs: {
              "dense": ""
            }
          }, [_vm._v("mdi-arrow-collapse")]), _vm._v("\n          Collapse\n        ")], 1)], 1), _vm._v(" "), _c('div', {
            staticClass: "d-flex pb-4 px-6"
          }, [_vm._t("header", null, {
            "isEditing": isEditing
          })], 2)];
        }
      }], null, true)
    }) : _c('div', {
      staticClass: "minimized d-flex justify-space-between align-center",
      on: {
        "click": function click($event) {
          return _vm.$emit('selected');
        }
      }
    }, [_c('v-chip', {
      staticClass: "readonly",
      attrs: {
        "color": "primary darken-3",
        "label": "",
        "dark": "",
        "small": ""
      }
    }, [_vm._v("\n      " + _vm._s(_vm.elementConfig.subtype) + "\n    ")]), _vm._v(" "), _c('span', {
      staticClass: "question"
    }, [_vm._v(_vm._s(_vm._f("truncate")(_vm.question, 50)))]), _vm._v(" "), _vm.$editorState.isPublishDiff && _vm.assessment.changeSincePublish ? _c('publish-diff-chip', {
      attrs: {
        "change-type": _vm.assessment.changeSincePublish
      }
    }) : _c('v-btn', {
      staticClass: "delete",
      "class": {
        disabled: _vm.isDisabled
      },
      attrs: {
        "color": "primary darken-2",
        "icon": ""
      },
      on: {
        "click": function click($event) {
          $event.stopPropagation();
          return _vm.$emit('delete');
        }
      }
    }, [_c('v-icon', [_vm._v("mdi-close")])], 1)], 1)], 1);
  };

  var __vue_staticRenderFns__$9 = [];
  /* style */

  var __vue_inject_styles__$9 = function __vue_inject_styles__(inject) {
    if (!inject) return;
    inject("data-v-493c9656_0", {
      source: ".assessment-item[data-v-493c9656]{margin-bottom:.625rem;padding:0}.assessment-item .v-chip[data-v-493c9656]{min-width:1.875rem}.assessment-item .drag-handle[data-v-493c9656]{position:absolute;top:0;left:-3px;color:#888;font-size:28px;opacity:0;cursor:move}.assessment-item.hover .drag-handle[data-v-493c9656]{opacity:1;transition:opacity .6s ease-in-out}.assessment-item .minimized[data-v-493c9656]{padding:.375rem 1.375rem;cursor:pointer}.assessment-item .minimized .question[data-v-493c9656]{display:inline-block;max-width:80%;min-height:1.875rem;color:#444;font-size:1rem;font-weight:400;line-height:2.125rem}.assessment-item .minimized .v-chip[data-v-493c9656]{margin-top:.125rem}.assessment-item .delete[data-v-493c9656]{opacity:0}.assessment-item.hover:not(.sortable-chosen) .delete[data-v-493c9656]:not(.disabled){opacity:1}.question-container[data-v-493c9656]{margin:0!important}.diff[data-v-493c9656]{border:none}.diff.expanded[data-v-493c9656]{border-radius:4px}.diff.new[data-v-493c9656]{border:none;box-shadow:0 0 0 2px var(--v-success-lighten2)!important}.diff.changed[data-v-493c9656],.diff.removed[data-v-493c9656]{border:none;box-shadow:0 0 0 2px var(--v-secondary-lighten4)!important}",
      map: undefined,
      media: undefined
    });
  };
  /* scoped */


  var __vue_scope_id__$9 = "data-v-493c9656";
  /* module identifier */

  var __vue_module_identifier__$5 = undefined;
  /* functional template */

  var __vue_is_functional_template__$9 = false;
  /* component normalizer */

  function __vue_normalize__$9(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "AssessmentItem.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;
    {
      var hook;

      if (style) {
        hook = function hook(context) {
          style.call(this, createInjector(context));
        };
      }

      if (hook !== undefined) {
        if (component.functional) {
          // register for functional component in vue file
          var originalRender = component.render;

          component.render = function renderWithStyleInjection(h, context) {
            hook.call(context);
            return originalRender(h, context);
          };
        } else {
          // inject component registration as beforeCreate hook
          var existing = component.beforeCreate;
          component.beforeCreate = existing ? [].concat(existing, hook) : [hook];
        }
      }
    }
    return component;
  }
  /* style inject */


  function __vue_create_injector__$5() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$5.styles || (__vue_create_injector__$5.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());
    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = {
        ids: [],
        parts: [],
        element: undefined
      });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;
        style.ids.push(id);

        if (css.map) {
          // https://developer.chrome.com/devtools/docs/javascript-debugging
          // this makes source maps inside style tags work properly in Chrome
          code += '\n/*# sourceURL=' + css.map.sources[0] + ' */'; // http://stackoverflow.com/a/26603875

          code += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(css.map)))) + ' */';
        }

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';
          if (css.media) el.setAttribute('media', css.media);

          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */


  __vue_normalize__$9({
    render: __vue_render__$9,
    staticRenderFns: __vue_staticRenderFns__$9
  }, __vue_inject_styles__$9, __vue_script__$9, __vue_scope_id__$9, __vue_is_functional_template__$9, __vue_module_identifier__$5, __vue_create_injector__$5);

  var downloadMixin = {
    methods: {
      download: function download(url, fileName) {
        var a = document.createElement('a');
        a.href = url;
        a.download = fileName;
        a.target = '_blank';
        a.click();
      }
    }
  };
  var uploadMixin = {
    inject: ['$storageService', '$repository'],
    mixins: [downloadMixin],
    data: function data() {
      return {
        uploading: false
      };
    },
    computed: {
      repositoryId: function repositoryId() {
        return this.$repository.id;
      }
    },
    methods: Object.assign({}, vueRadio.mapRequests('app', ['showConfirmationModal']), {
      createFileForm: function createFileForm(e) {
        this.form = new FormData();

        var _e$target$files = _slicedToArray(e.target.files, 1),
            file = _e$target$files[0];

        if (!file) return;
        this.form.append('file', file, file.name);
      },
      upload: loader(function (e) {
        var _this = this;

        this.createFileForm(e);
        return this.$storageService.upload(this.repositoryId, this.form).then(function (data) {
          var _this$form$get = _this.form.get('file'),
              name = _this$form$get.name;

          _this.$emit('upload', Object.assign({}, data, {
            name: name
          }));
        })["catch"](function () {
          _this.error = 'An error has occurred!';
        });
      }, 'uploading'),
      downloadFile: async function downloadFile(key, name) {
        var url = await this.$storageService.getUrl(this.repositoryId, key);
        return this.download(url, name);
      },
      deleteFile: function deleteFile(item) {
        var _this2 = this;

        this.showConfirmationModal({
          title: 'Delete file?',
          message: "Are you sure you want to remove ".concat(item.fileName, "?"),
          action: function action() {
            return _this2.$emit('delete', item.id, null);
          }
        });
      }
    })
  }; //

  var script$8 = {
    name: 'upload-btn',
    mixins: [uploadMixin],
    props: {
      id: {
        type: String,
        "default": function _default() {
          return uniqueId__default['default']('file_');
        }
      },
      fileName: {
        type: String,
        "default": ''
      },
      fileKey: {
        type: String,
        "default": ''
      },
      validate: {
        type: Object,
        "default": function _default() {
          return {
            ext: []
          };
        }
      },
      label: {
        type: String,
        "default": 'Choose a file'
      },
      sm: {
        type: Boolean,
        "default": false
      }
    },
    methods: {
      validateAndUpload: async function validateAndUpload(e) {
        var _await$this$$refs$val = await this.$refs.validator.validate(e),
            valid = _await$this$$refs$val.valid;

        if (valid) this.upload(e);
      }
    },
    watch: {
      uploading: function uploading(val) {
        this.$emit('update:uploading', val);
      }
    }
  };
  /* script */

  var __vue_script__$8 = script$8;
  /* template */

  var __vue_render__$8 = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      staticClass: "file-upload"
    }, [_c('form', {
      staticClass: "upload-form",
      on: {
        "submit": function submit($event) {
          $event.preventDefault();
        }
      }
    }, [_c('validation-provider', {
      ref: "validator",
      attrs: {
        "rules": _vm.validate
      }
    }, [_c('input', {
      ref: _vm.id,
      staticClass: "upload-input",
      attrs: {
        "id": _vm.id,
        "name": _vm.id,
        "accept": _vm.validate.ext,
        "type": "file"
      },
      on: {
        "change": _vm.validateAndUpload
      }
    })]), _vm._v(" "), !_vm.fileKey ? _c('v-btn', {
      attrs: {
        "loading": _vm.uploading,
        "color": "grey darken-4",
        "text": ""
      },
      on: {
        "click": function click($event) {
          return _vm.$refs[_vm.id].click();
        }
      }
    }, [_c('v-icon', {
      staticClass: "mr-2",
      attrs: {
        "color": "secondary"
      }
    }, [_vm._v("mdi-cloud-upload-outline")]), _vm._v("\n      " + _vm._s(_vm.label) + "\n    ")], 1) : _c('span', {
      staticClass: "file-name",
      on: {
        "click": function click($event) {
          return _vm.downloadFile(_vm.fileKey, _vm.fileName);
        }
      }
    }, [_vm._v(_vm._s(_vm.fileName) + "\n    ")]), _vm._v(" "), _vm.fileKey ? _c('v-btn', {
      attrs: {
        "icon": "",
        "small": ""
      },
      on: {
        "click": function click($event) {
          return _vm.deleteFile({
            id: _vm.id,
            fileName: _vm.fileName
          });
        }
      }
    }, [_c('v-icon', [_vm._v("mdi-delete")])], 1) : _vm._e()], 1)]);
  };

  var __vue_staticRenderFns__$8 = [];
  /* style */

  var __vue_inject_styles__$8 = function __vue_inject_styles__(inject) {
    if (!inject) return;
    inject("data-v-1f089141_0", {
      source: ".file-upload[data-v-1f089141],.upload-form[data-v-1f089141]{display:inline-block}.upload-input[data-v-1f089141]{visibility:hidden;max-width:0;max-height:0}.file-name[data-v-1f089141]{color:#00f;font-size:1rem;text-decoration:underline;cursor:pointer}",
      map: undefined,
      media: undefined
    });
  };
  /* scoped */


  var __vue_scope_id__$8 = "data-v-1f089141";
  /* module identifier */

  var __vue_module_identifier__$4 = undefined;
  /* functional template */

  var __vue_is_functional_template__$8 = false;
  /* component normalizer */

  function __vue_normalize__$8(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "UploadBtn.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;
    {
      var hook;

      if (style) {
        hook = function hook(context) {
          style.call(this, createInjector(context));
        };
      }

      if (hook !== undefined) {
        if (component.functional) {
          // register for functional component in vue file
          var originalRender = component.render;

          component.render = function renderWithStyleInjection(h, context) {
            hook.call(context);
            return originalRender(h, context);
          };
        } else {
          // inject component registration as beforeCreate hook
          var existing = component.beforeCreate;
          component.beforeCreate = existing ? [].concat(existing, hook) : [hook];
        }
      }
    }
    return component;
  }
  /* style inject */


  function __vue_create_injector__$4() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$4.styles || (__vue_create_injector__$4.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());
    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = {
        ids: [],
        parts: [],
        element: undefined
      });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;
        style.ids.push(id);

        if (css.map) {
          // https://developer.chrome.com/devtools/docs/javascript-debugging
          // this makes source maps inside style tags work properly in Chrome
          code += '\n/*# sourceURL=' + css.map.sources[0] + ' */'; // http://stackoverflow.com/a/26603875

          code += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(css.map)))) + ' */';
        }

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';
          if (css.media) el.setAttribute('media', css.media);

          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */


  var UploadBtn = __vue_normalize__$8({
    render: __vue_render__$8,
    staticRenderFns: __vue_staticRenderFns__$8
  }, __vue_inject_styles__$8, __vue_script__$8, __vue_scope_id__$8, __vue_is_functional_template__$8, __vue_module_identifier__$4, __vue_create_injector__$4); //


  function isUploaded(url) {
    try {
      return url && new URL(url).protocol === 'storage:';
    } catch (e) {
      return false;
    }
  }

  var script$7 = {
    name: 'tailor-asset-input',
    props: {
      url: {
        type: String,
        "default": null
      },
      publicUrl: {
        type: String,
        "default": null
      },
      extensions: {
        type: Array,
        required: true
      },
      allowFileUpload: {
        type: Boolean,
        "default": true
      },
      uploadLabel: {
        type: String,
        "default": 'Select file'
      }
    },
    data: function data() {
      var isLinked = !isUploaded(this.url);
      return {
        isEditing: !this.url,
        uploading: false,
        file: isLinked ? null : pick__default['default'](this, ['url', 'publicUrl']),
        urlInput: isLinked ? this.url : null
      };
    },
    computed: {
      hasAsset: function hasAsset(vm) {
        return vm.file || vm.urlInput;
      },
      isLinked: function isLinked(vm) {
        return !!vm.urlInput;
      },
      hasChanges: function hasChanges(vm) {
        return vm.url !== (vm.isLinked ? vm.urlInput : get__default['default'](vm, 'file.url', null));
      },
      fileName: function fileName() {
        if (!this.file) return null;
        return last__default['default'](this.file.url.split('___'));
      }
    },
    methods: {
      save: async function save() {
        if (this.$refs.provider) {
          var _await$this$$refs$pro = await this.$refs.provider.validate(),
              valid = _await$this$$refs$pro.valid;

          if (!valid) return;
        }

        this.isEditing = false;
        var payload = this.file || {
          url: this.urlInput,
          publicUrl: this.urlInput
        };
        this.$emit('input', payload);
      },
      cancel: function cancel() {
        var isLinked = !isUploaded(this.url);
        this.urlInput = isLinked ? this.url : null;
        this.file = isLinked ? null : pick__default['default'](this, ['url', 'publicUrl']);
        this.isEditing = !this.url;
      }
    },
    components: {
      UploadBtn: UploadBtn
    }
  };
  /* script */

  var __vue_script__$7 = script$7;
  /* template */

  var __vue_render__$7 = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('v-toolbar-items', [_vm.url && !_vm.isEditing ? _c('v-btn', {
      attrs: {
        "href": _vm.publicUrl || _vm.url,
        "target": "_blank",
        "color": "info",
        "text": ""
      }
    }, [_c('v-icon', [_vm._v("mdi-open-in-new")])], 1) : _vm._e(), _vm._v(" "), _vm.allowFileUpload ? _c('upload-btn', {
      directives: [{
        name: "show",
        rawName: "v-show",
        value: !_vm.file && _vm.isEditing,
        expression: "!file && isEditing"
      }],
      staticClass: "upload-btn",
      attrs: {
        "uploading": _vm.uploading,
        "validate": {
          ext: _vm.extensions
        },
        "confirm-deletion": false,
        "label": _vm.uploadLabel
      },
      on: {
        "upload": function upload(val) {
          return (_vm.file = val) && (_vm.urlInput = null);
        },
        "update:uploading": function updateUploading($event) {
          _vm.uploading = $event;
        }
      }
    }) : _vm._e(), _vm._v(" "), _vm.file ? [_vm.isEditing ? _c('v-btn', {
      attrs: {
        "color": "red",
        "text": ""
      },
      on: {
        "click": function click($event) {
          $event.stopPropagation();
          _vm.file = null;
        }
      }
    }, [_c('v-icon', [_vm._v("mdi-delete")])], 1) : _vm._e(), _vm._v(" "), _c('v-text-field', {
      attrs: {
        "value": _vm.fileName,
        "readonly": "",
        "hide-details": "",
        "filled": ""
      }
    })] : _vm._e(), _vm._v(" "), !_vm.uploading && (_vm.urlInput || !_vm.hasAsset) ? _c('validation-provider', {
      ref: "provider",
      attrs: {
        "rules": {
          url: {
            protocols: ['http', 'https'],
            require_protocol: true,
            require_valid_protocol: true
          }
        },
        "name": "URL"
      },
      scopedSlots: _vm._u([{
        key: "default",
        fn: function fn(ref) {
          var errors = ref.errors;
          return [_c('v-text-field', {
            attrs: {
              "error-messages": errors,
              "disabled": !_vm.isEditing,
              "placeholder": _vm.allowFileUpload ? 'or paste a URL...' : 'Paste a URL...',
              "filled": "",
              "clearable": ""
            },
            model: {
              value: _vm.urlInput,
              callback: function callback($$v) {
                _vm.urlInput = $$v;
              },
              expression: "urlInput"
            }
          })];
        }
      }], null, false, 17370557)
    }) : _vm._e(), _vm._v(" "), !_vm.isEditing ? _c('v-btn', {
      staticClass: "action",
      attrs: {
        "text": ""
      },
      on: {
        "click": function click($event) {
          $event.stopPropagation();
          _vm.isEditing = true;
        }
      }
    }, [_vm._v("\n    Edit\n  ")]) : [_vm.hasChanges ? _c('v-btn', {
      staticClass: "action",
      attrs: {
        "disabled": _vm.uploading,
        "text": ""
      },
      on: {
        "click": function click($event) {
          $event.stopPropagation();
          return _vm.save($event);
        }
      }
    }, [_vm._v("\n      Save\n    ")]) : _vm._e(), _vm._v(" "), _vm.hasChanges || _vm.url ? _c('v-btn', {
      staticClass: "action",
      attrs: {
        "disabled": _vm.uploading,
        "text": ""
      },
      on: {
        "click": function click($event) {
          $event.stopPropagation();
          return _vm.cancel($event);
        }
      }
    }, [_vm._v("\n      Cancel\n    ")]) : _vm._e()]], 2);
  };

  var __vue_staticRenderFns__$7 = [];
  /* style */

  var __vue_inject_styles__$7 = function __vue_inject_styles__(inject) {
    if (!inject) return;
    inject("data-v-00f47ac8_0", {
      source: ".v-text-field[data-v-00f47ac8]{min-width:21.875rem;margin:.5rem .75rem 0 1.75rem}.action[data-v-00f47ac8]  .v-btn__content{min-width:4rem!important}.upload-btn[data-v-00f47ac8]  .v-btn{height:100%}.upload-btn[data-v-00f47ac8]  .v-btn .v-btn__content{padding:1.5rem 0}",
      map: undefined,
      media: undefined
    });
  };
  /* scoped */


  var __vue_scope_id__$7 = "data-v-00f47ac8";
  /* module identifier */

  var __vue_module_identifier__$3 = undefined;
  /* functional template */

  var __vue_is_functional_template__$7 = false;
  /* component normalizer */

  function __vue_normalize__$7(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "AssetInput.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;
    {
      var hook;

      if (style) {
        hook = function hook(context) {
          style.call(this, createInjector(context));
        };
      }

      if (hook !== undefined) {
        if (component.functional) {
          // register for functional component in vue file
          var originalRender = component.render;

          component.render = function renderWithStyleInjection(h, context) {
            hook.call(context);
            return originalRender(h, context);
          };
        } else {
          // inject component registration as beforeCreate hook
          var existing = component.beforeCreate;
          component.beforeCreate = existing ? [].concat(existing, hook) : [hook];
        }
      }
    }
    return component;
  }
  /* style inject */


  function __vue_create_injector__$3() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$3.styles || (__vue_create_injector__$3.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());
    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = {
        ids: [],
        parts: [],
        element: undefined
      });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;
        style.ids.push(id);

        if (css.map) {
          // https://developer.chrome.com/devtools/docs/javascript-debugging
          // this makes source maps inside style tags work properly in Chrome
          code += '\n/*# sourceURL=' + css.map.sources[0] + ' */'; // http://stackoverflow.com/a/26603875

          code += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(css.map)))) + ' */';
        }

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';
          if (css.media) el.setAttribute('media', css.media);

          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */


  __vue_normalize__$7({
    render: __vue_render__$7,
    staticRenderFns: __vue_staticRenderFns__$7
  }, __vue_inject_styles__$7, __vue_script__$7, __vue_scope_id__$7, __vue_is_functional_template__$7, __vue_module_identifier__$3, __vue_create_injector__$3); //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //


  var script$6 = {
    name: 'date-picker',
    props: {
      value: {
        type: [String, Date],
        "default": null
      },
      label: {
        type: String,
        "default": null
      },
      clearable: {
        type: Boolean,
        "default": true
      },
      placeholder: {
        type: String,
        "default": 'Click to set...'
      }
    },
    data: function data() {
      return {
        showDatePicker: false
      };
    },
    methods: {
      clear: function clear() {
        this.$emit('input', null);
        this.$refs.textField.blur();
      }
    }
  };
  /* script */

  var __vue_script__$6 = script$6;
  /* template */

  var __vue_render__$6 = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('v-menu', {
      attrs: {
        "close-on-content-click": false,
        "min-width": "290px",
        "transition": "scale-transition"
      },
      scopedSlots: _vm._u([{
        key: "activator",
        fn: function fn(ref) {
          var on = ref.on;
          return [_c('v-text-field', _vm._g({
            ref: "textField",
            attrs: {
              "value": _vm._f("formatDate")(_vm.value, 'MMM D, YYYY'),
              "label": _vm.label,
              "placeholder": _vm.placeholder,
              "clearable": _vm.clearable,
              "outlined": "",
              "readonly": ""
            },
            on: {
              "click:clear": _vm.clear,
              "click": function click($event) {
                _vm.showDatePicker = true;
              }
            }
          }, on))];
        }
      }]),
      model: {
        value: _vm.showDatePicker,
        callback: function callback($$v) {
          _vm.showDatePicker = $$v;
        },
        expression: "showDatePicker"
      }
    }, [_vm._v(" "), _c('v-date-picker', {
      attrs: {
        "value": _vm._f("formatDate")(_vm.value, 'YYYY-MM-DD'),
        "color": "primary darken-2",
        "no-title": ""
      },
      on: {
        "input": function input($event) {
          return _vm.$emit('input', $event);
        },
        "change": function change($event) {
          _vm.showDatePicker = false;
        }
      }
    })], 1);
  };

  var __vue_staticRenderFns__$6 = [];
  /* style */

  var __vue_inject_styles__$6 = undefined;
  /* scoped */

  var __vue_scope_id__$6 = undefined;
  /* functional template */

  var __vue_is_functional_template__$6 = false;
  /* component normalizer */

  function __vue_normalize__$6(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "DatePicker.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;
    return component;
  }
  /* style inject */

  /* style inject SSR */


  __vue_normalize__$6({
    render: __vue_render__$6,
    staticRenderFns: __vue_staticRenderFns__$6
  }, __vue_inject_styles__$6, __vue_script__$6, __vue_scope_id__$6, __vue_is_functional_template__$6); //


  var CE_FOCUS_EVENT = 'element:focus';
  var script$5 = {
    name: 'tailor-element-list',
    props: {
      elements: {
        type: Array,
        "default": function _default() {
          return [];
        }
      },
      dragOptions: {
        type: Object,
        "default": function _default() {
          return {};
        }
      },
      supportedTypes: {
        type: Array,
        "default": null
      },
      activity: {
        type: Object,
        "default": null
      },
      layout: {
        type: Boolean,
        "default": false
      },
      isDisabled: {
        type: Boolean,
        "default": false
      },
      enableAdd: {
        type: Boolean,
        "default": true
      },
      addElementOptions: {
        type: Object,
        "default": function _default() {
          return {};
        }
      }
    },
    data: function data() {
      return {
        dragElementIndex: null
      };
    },
    computed: Object.assign({}, vueRadio.mapChannels({
      editorChannel: 'editor'
    }), {
      options: function options(vm) {
        return Object.assign({}, vm.dragOptions, {
          handle: '.drag-handle'
        });
      }
    }),
    methods: {
      get: get__default['default'],
      getElementId: utils.getElementId,
      onDragStart: function onDragStart(index) {
        this.dragElementIndex = index;
        this.editorChannel.emit(CE_FOCUS_EVENT);
      },
      onDragEnd: function onDragEnd(element) {
        this.dragElementIndex = -1;
        this.editorChannel.emit(CE_FOCUS_EVENT, element);
      },
      reorder: function reorder(_ref) {
        var newPosition = _ref.newIndex;
        var items = this.elements;
        this.$emit('update', {
          newPosition: newPosition,
          items: items
        });
      }
    },
    components: {
      AddElement: AddElement,
      Draggable: Draggable__default['default']
    }
  };
  /* script */

  var __vue_script__$5 = script$5;
  /* template */

  var __vue_render__$5 = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      staticClass: "list-group"
    }, [_c('draggable', _vm._b({
      staticClass: "row",
      attrs: {
        "list": _vm.elements,
        "disabled": _vm.isDisabled
      },
      on: {
        "start": function start($event) {
          _vm.dragElementIndex = $event.oldIndex;
        },
        "end": function end($event) {
          _vm.dragElementIndex = -1;
        },
        "update": _vm.reorder
      }
    }, 'draggable', _vm.options, false), _vm._l(_vm.elements, function (element, index) {
      return _c('div', {
        key: _vm.getElementId(element),
        staticClass: "pr-5",
        "class": "col-xs-" + _vm.get(element, 'data.width', 12),
        on: {
          "dragstart": function dragstart($event) {
            return _vm.onDragStart(index);
          },
          "dragend": function dragend($event) {
            return _vm.onDragEnd(element);
          }
        }
      }, [_vm._t("list-item", null, {
        "element": element,
        "isDragged": _vm.dragElementIndex === index,
        "position": index
      })], 2);
    }), 0), _vm._v(" "), _vm.enableAdd && !_vm.isDisabled ? [_vm._t("list-add", [_c('add-element', {
      staticClass: "mt-1",
      attrs: {
        "items": _vm.elements,
        "include": _vm.supportedTypes,
        "activity": _vm.activity,
        "label": _vm.addElementOptions.label,
        "large": _vm.addElementOptions.large,
        "position": _vm.elements.length,
        "layout": _vm.layout
      },
      on: {
        "add": function add($event) {
          return _vm.$emit('add', $event);
        }
      }
    })], {
      "include": _vm.supportedTypes,
      "activity": _vm.activity,
      "position": _vm.elements.length,
      "layout": _vm.layout
    })] : _vm._e()], 2);
  };

  var __vue_staticRenderFns__$5 = [];
  /* style */

  var __vue_inject_styles__$5 = function __vue_inject_styles__(inject) {
    if (!inject) return;
    inject("data-v-f18f3e56_0", {
      source: ".list-group[data-v-f18f3e56]{padding:.625rem 1.5rem}[data-v-f18f3e56] .sortable-ghost .drag-handle{display:none}[data-v-f18f3e56] .sortable-ghost .content-element{max-height:9.375rem;background:#f4f5f5}[data-v-f18f3e56] .sortable-ghost .content-element>*{visibility:hidden}[data-v-f18f3e56] .sortable-drag .content-element{max-height:auto;background:#fff}",
      map: undefined,
      media: undefined
    });
  };
  /* scoped */


  var __vue_scope_id__$5 = "data-v-f18f3e56";
  /* module identifier */

  var __vue_module_identifier__$2 = undefined;
  /* functional template */

  var __vue_is_functional_template__$5 = false;
  /* component normalizer */

  function __vue_normalize__$5(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "ElementList.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;
    {
      var hook;

      if (style) {
        hook = function hook(context) {
          style.call(this, createInjector(context));
        };
      }

      if (hook !== undefined) {
        if (component.functional) {
          // register for functional component in vue file
          var originalRender = component.render;

          component.render = function renderWithStyleInjection(h, context) {
            hook.call(context);
            return originalRender(h, context);
          };
        } else {
          // inject component registration as beforeCreate hook
          var existing = component.beforeCreate;
          component.beforeCreate = existing ? [].concat(existing, hook) : [hook];
        }
      }
    }
    return component;
  }
  /* style inject */


  function __vue_create_injector__$2() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$2.styles || (__vue_create_injector__$2.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());
    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = {
        ids: [],
        parts: [],
        element: undefined
      });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;
        style.ids.push(id);

        if (css.map) {
          // https://developer.chrome.com/devtools/docs/javascript-debugging
          // this makes source maps inside style tags work properly in Chrome
          code += '\n/*# sourceURL=' + css.map.sources[0] + ' */'; // http://stackoverflow.com/a/26603875

          code += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(css.map)))) + ' */';
        }

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';
          if (css.media) el.setAttribute('media', css.media);

          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */


  var ElementList = __vue_normalize__$5({
    render: __vue_render__$5,
    staticRenderFns: __vue_staticRenderFns__$5
  }, __vue_inject_styles__$5, __vue_script__$5, __vue_scope_id__$5, __vue_is_functional_template__$5, __vue_module_identifier__$2, __vue_create_injector__$2); //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //


  var script$4 = {
    name: 'tailor-element-placeholder',
    props: {
      name: {
        type: String,
        required: true
      },
      icon: {
        type: String,
        required: true
      },
      placeholder: {
        type: String,
        "default": 'Select to edit'
      },
      activePlaceholder: {
        type: String,
        "default": 'Use toolbar to edit'
      },
      activeIcon: {
        type: String,
        "default": null
      },
      activeColor: {
        type: String,
        "default": '#fff'
      },
      isDisabled: {
        type: Boolean,
        "default": false
      },
      isFocused: {
        type: Boolean,
        "default": false
      },
      dense: {
        type: Boolean,
        "default": false
      }
    },
    computed: {
      iconSize: function iconSize() {
        if (this.dense) return this.isFocused ? 24 : 20;
        return this.isFocused ? 38 : 30;
      }
    }
  };
  /* script */

  var __vue_script__$4 = script$4;
  /* template */

  var __vue_render__$4 = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('v-sheet', {
      staticClass: "transparent grey--text text--darken-4",
      "class": _vm.dense ? 'pt-3' : 'pa-12'
    }, [_c('v-avatar', {
      attrs: {
        "size": _vm.dense ? 40 : 60,
        "color": _vm.isDisabled ? 'grey darken-3' : 'primary darken-4'
      }
    }, [_c('v-icon', {
      attrs: {
        "size": _vm.iconSize,
        "color": _vm.isFocused ? _vm.activeColor : '#fff'
      }
    }, [_vm._v("\n      " + _vm._s(_vm.icon) + "\n    ")])], 1), _vm._v(" "), _c('div', {
      staticClass: "grey--text",
      "class": [_vm.isDisabled ? 'text--darken-3' : 'text--darken-4', _vm.dense ? 'my-2 subtitle-2' : 'my-4 headline']
    }, [_vm._v("\n    " + _vm._s(_vm.name) + "\n  ")]), _vm._v(" "), !_vm.dense && !_vm.isDisabled ? _c('div', {
      staticClass: "subtitle-1"
    }, [!_vm.isFocused ? [_vm._v(_vm._s(_vm.placeholder))] : [_c('span', [_vm._v(_vm._s(_vm.activePlaceholder))]), _vm._v(" "), _vm.activeIcon ? _c('v-icon', {
      attrs: {
        "size": "20",
        "color": "primary darken-4"
      }
    }, [_vm._v("\n        " + _vm._s(_vm.activeIcon) + "\n      ")]) : _vm._e()]], 2) : _vm._e()], 1);
  };

  var __vue_staticRenderFns__$4 = [];
  /* style */

  var __vue_inject_styles__$4 = undefined;
  /* scoped */

  var __vue_scope_id__$4 = undefined;
  /* functional template */

  var __vue_is_functional_template__$4 = false;
  /* component normalizer */

  function __vue_normalize__$4(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "ElementPlaceholder.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;
    return component;
  }
  /* style inject */

  /* style inject SSR */


  __vue_normalize__$4({
    render: __vue_render__$4,
    staticRenderFns: __vue_staticRenderFns__$4
  }, __vue_inject_styles__$4, __vue_script__$4, __vue_scope_id__$4, __vue_is_functional_template__$4);

  var script$3 = {
    name: 'tailor-embedded-container',
    inheritAttrs: false,
    props: {
      container: {
        type: Object,
        required: true
      },
      types: {
        type: Array,
        "default": function _default() {
          return ['JODIT_HTML', 'IMAGE', 'HTML', 'VIDEO'];
        }
      },
      isDisabled: {
        type: Boolean,
        "default": false
      },
      addElementOptions: {
        type: Object,
        "default": function _default() {
          return {};
        }
      },
      enableAdd: {
        type: Boolean,
        "default": true
      }
    },
    computed: {
      embeds: function embeds() {
        var items = this.container.embeds;
        return items ? values__default['default'](items).sort(function (a, b) {
          return a.position - b.position;
        }) : [];
      }
    },
    methods: Object.assign({}, vueRadio.mapRequests('app', ['showConfirmationModal']), {
      addItems: function addItems(items) {
        items = Array.isArray(items) ? items : [items];
        var container = cloneDeep__default['default'](this.container);
        container.embeds = Object.assign({}, container.embeds, mapKeys__default['default'](items, 'id'));
        this.$emit('save', container);
      },
      reorderItem: function reorderItem(_ref) {
        var newPosition = _ref.newPosition,
            items = _ref.items;
        var context = {
          items: items,
          newPosition: newPosition
        };
        var container = cloneDeep__default['default'](this.container);
        var reordered = container.embeds[items[newPosition].id];
        reordered.position = utils.calculatePosition(context);
        this.$emit('save', container);
      },
      save: function save(item, key, value) {
        var container = cloneDeep__default['default'](this.container);
        container.embeds[item.id] = Object.assign({}, item, _defineProperty({}, key, value));
        this.$emit('save', container);
      },
      requestDeleteConfirmation: function requestDeleteConfirmation(element) {
        var _this = this;

        this.showConfirmationModal({
          title: 'Delete element?',
          message: 'Are you sure you want to delete element?',
          action: function action() {
            return _this.$emit('delete', element);
          }
        });
      }
    }),
    components: {
      ContainedContent: ContainedContent,
      ElementList: ElementList
    }
  };
  /* script */

  var __vue_script__$3 = script$3;
  /* template */

  var __vue_render__$3 = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('element-list', {
      attrs: {
        "add-element-options": _vm.addElementOptions,
        "elements": _vm.embeds,
        "supported-types": _vm.types,
        "enable-add": !_vm.isDisabled && _vm.enableAdd
      },
      on: {
        "add": _vm.addItems,
        "update": _vm.reorderItem
      },
      scopedSlots: _vm._u([{
        key: "list-item",
        fn: function fn(ref) {
          var element = ref.element;
          var isDragged = ref.isDragged;
          return [_c('contained-content', _vm._b({
            staticClass: "my-2",
            attrs: {
              "element": element,
              "is-dragged": isDragged,
              "is-disabled": _vm.isDisabled
            },
            on: {
              "save": function save($event) {
                return _vm.save(element, 'data', $event);
              },
              "save:meta": function saveMeta($event) {
                return _vm.save(element, 'meta', $event);
              },
              "delete": function _delete($event) {
                return _vm.requestDeleteConfirmation(element);
              }
            }
          }, 'contained-content', _vm.$attrs, false))];
        }
      }])
    });
  };

  var __vue_staticRenderFns__$3 = [];
  /* style */

  var __vue_inject_styles__$3 = undefined;
  /* scoped */

  var __vue_scope_id__$3 = undefined;
  /* functional template */

  var __vue_is_functional_template__$3 = false;
  /* component normalizer */

  function __vue_normalize__$3(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "EmbeddedContainer.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;
    return component;
  }
  /* style inject */

  /* style inject SSR */


  __vue_normalize__$3({
    render: __vue_render__$3,
    staticRenderFns: __vue_staticRenderFns__$3
  }, __vue_inject_styles__$3, __vue_script__$3, __vue_scope_id__$3, __vue_is_functional_template__$3); //


  var script$2$1 = {
    name: 'file-input',
    mixins: [uploadMixin],
    props: {
      id: {
        type: String,
        "default": function _default() {
          return uniqueId__default['default']('file_');
        }
      },
      fileKey: {
        type: String,
        "default": ''
      },
      fileName: {
        type: String,
        "default": ''
      },
      validate: {
        type: Object,
        "default": function _default() {
          return {
            ext: []
          };
        }
      },
      label: {
        type: String,
        "default": 'File upload'
      },
      placeholder: {
        type: String,
        "default": 'Choose a file'
      },
      outlined: {
        type: Boolean,
        "default": false
      },
      dense: {
        type: Boolean,
        "default": false
      }
    },
    computed: {
      acceptedFileTypes: function acceptedFileTypes() {
        var ext = get__default['default'](this.validate, 'ext', []);
        return ext.length ? ".".concat(ext.join(',.')) : '';
      }
    },
    watch: {
      uploading: function uploading(val) {
        this.$emit('update:uploading', val);
      }
    }
  };
  /* script */

  var __vue_script__$2$1 = script$2$1;
  /* template */

  var __vue_render__$2$1 = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('form', {
      on: {
        "submit": function submit($event) {
          $event.preventDefault();
        }
      }
    }, [!_vm.fileKey ? _c('v-file-input', {
      ref: _vm.id,
      attrs: {
        "accept": _vm.acceptedFileTypes,
        "label": _vm.label,
        "placeholder": _vm.placeholder,
        "outlined": _vm.outlined,
        "dense": _vm.dense,
        "clearable": false,
        "append-icon": _vm.uploading ? 'mdi-loading mdi-spin' : 'mdi-upload',
        "prepend-icon": ""
      },
      on: {
        "click:append": function clickAppend($event) {
          _vm.$refs[_vm.id].$el.querySelector('input').click();
        }
      },
      nativeOn: {
        "change": function change($event) {
          return _vm.upload($event);
        }
      }
    }) : _c('div', {
      staticClass: "mb-5 px-1 grey--text text--darken-3"
    }, [_c('div', [_vm._v(_vm._s(_vm.label))]), _vm._v(" "), _c('v-btn', {
      staticClass: "grey--text text--darken-4 text-none px-0",
      attrs: {
        "text": ""
      },
      on: {
        "click": function click($event) {
          return _vm.downloadFile(_vm.fileKey, _vm.fileName);
        }
      }
    }, [_vm._v("\n      " + _vm._s(_vm._f("truncate")(_vm.fileName, 35)) + "\n    ")]), _vm._v(" "), _c('v-btn', {
      staticClass: "ml-1",
      attrs: {
        "color": "grey darken-4",
        "icon": "",
        "x-small": ""
      },
      on: {
        "click": function click($event) {
          return _vm.deleteFile({
            id: _vm.id,
            fileName: _vm.fileName
          });
        }
      }
    }, [_c('v-icon', [_vm._v("mdi-close")])], 1)], 1)], 1);
  };

  var __vue_staticRenderFns__$2$1 = [];
  /* style */

  var __vue_inject_styles__$2$1 = undefined;
  /* scoped */

  var __vue_scope_id__$2$1 = undefined;
  /* functional template */

  var __vue_is_functional_template__$2$1 = false;
  /* component normalizer */

  function __vue_normalize__$2$1(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "FileInput.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;
    return component;
  }
  /* style inject */

  /* style inject SSR */


  __vue_normalize__$2$1({
    render: __vue_render__$2$1,
    staticRenderFns: __vue_staticRenderFns__$2$1
  }, __vue_inject_styles__$2$1, __vue_script__$2$1, __vue_scope_id__$2$1, __vue_is_functional_template__$2$1); //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //


  var script$1$1 = {
    name: 'tailor-inline-activator',
    inheritAttrs: false,
    props: {
      disabled: {
        type: Boolean,
        required: false
      }
    }
  };
  /* script */

  var __vue_script__$1$1 = script$1$1;
  /* template */

  var __vue_render__$1$1 = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('button', _vm._g({
      staticClass: "inline-activator",
      "class": {
        disabled: _vm.disabled
      }
    }, _vm.$listeners), [_c('hr'), _vm._v(" "), _c('v-avatar', {
      attrs: {
        "size": "20",
        "color": "primary darken-4"
      }
    }, [_c('v-icon', {
      attrs: {
        "size": "16",
        "dark": ""
      }
    }, [_vm._v("mdi-plus")])], 1), _vm._v(" "), _c('hr')], 1);
  };

  var __vue_staticRenderFns__$1$1 = [];
  /* style */

  var __vue_inject_styles__$1$1 = function __vue_inject_styles__(inject) {
    if (!inject) return;
    inject("data-v-64eb8c58_0", {
      source: ".default-activator-state[data-v-64eb8c58],.inline-activator[data-v-64eb8c58],.inline-activator.disabled[data-v-64eb8c58],.inline-activator.disabled[data-v-64eb8c58]:hover{padding:0 3.125rem;opacity:0}.inline-activator[data-v-64eb8c58]{display:flex;align-items:center;width:100%;margin:0;padding:0 3.125rem;opacity:0;transition:opacity .3s,padding .3s}.inline-activator[data-v-64eb8c58],.inline-activator .v-chip[data-v-64eb8c58]{cursor:pointer}.inline-activator hr[data-v-64eb8c58]{flex:1;display:inline-flex;margin:0;border-top:.0625rem dashed var(--v-primary-darken3)}.inline-activator[data-v-64eb8c58]:focus,.inline-activator[data-v-64eb8c58]:hover{padding:.75rem 0;opacity:1;outline:0;transition:opacity .3s .25s,padding .3s .1s}.inline-activator.disabled[data-v-64eb8c58],.inline-activator.disabled[data-v-64eb8c58]:hover{pointer-events:none}",
      map: undefined,
      media: undefined
    });
  };
  /* scoped */


  var __vue_scope_id__$1$1 = "data-v-64eb8c58";
  /* module identifier */

  var __vue_module_identifier__$1$1 = undefined;
  /* functional template */

  var __vue_is_functional_template__$1$1 = false;
  /* component normalizer */

  function __vue_normalize__$1$1(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "InlineActivator.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;
    {
      var hook;

      if (style) {
        hook = function hook(context) {
          style.call(this, createInjector(context));
        };
      }

      if (hook !== undefined) {
        if (component.functional) {
          // register for functional component in vue file
          var originalRender = component.render;

          component.render = function renderWithStyleInjection(h, context) {
            hook.call(context);
            return originalRender(h, context);
          };
        } else {
          // inject component registration as beforeCreate hook
          var existing = component.beforeCreate;
          component.beforeCreate = existing ? [].concat(existing, hook) : [hook];
        }
      }
    }
    return component;
  }
  /* style inject */


  function __vue_create_injector__$1$1() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$1$1.styles || (__vue_create_injector__$1$1.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());
    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = {
        ids: [],
        parts: [],
        element: undefined
      });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;
        style.ids.push(id);

        if (css.map) {
          // https://developer.chrome.com/devtools/docs/javascript-debugging
          // this makes source maps inside style tags work properly in Chrome
          code += '\n/*# sourceURL=' + css.map.sources[0] + ' */'; // http://stackoverflow.com/a/26603875

          code += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(css.map)))) + ' */';
        }

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';
          if (css.media) el.setAttribute('media', css.media);

          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */


  __vue_normalize__$1$1({
    render: __vue_render__$1$1,
    staticRenderFns: __vue_staticRenderFns__$1$1
  }, __vue_inject_styles__$1$1, __vue_script__$1$1, __vue_scope_id__$1$1, __vue_is_functional_template__$1$1, __vue_module_identifier__$1$1, __vue_create_injector__$1$1); //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //


  var script$B = {
    name: 'tailor-preview-overlay',
    props: {
      show: {
        type: Boolean,
        "default": false
      }
    }
  };
  /* script */

  var __vue_script__$B = script$B;
  /* template */

  var __vue_render__$B = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('v-overlay', {
      attrs: {
        "value": _vm.show,
        "opacity": "0.9",
        "absolute": ""
      }
    }, [_c('button', {
      staticClass: "message pa-2 grey--text text--lighten-2"
    }, [_vm._t("default", [_vm._v("Click to preview")])], 2)]);
  };

  var __vue_staticRenderFns__$B = [];
  /* style */

  var __vue_inject_styles__$B = function __vue_inject_styles__(inject) {
    if (!inject) return;
    inject("data-v-20303d2e_0", {
      source: ".message[data-v-20303d2e]{border-radius:2px;font-size:1.125rem}",
      map: undefined,
      media: undefined
    });
  };
  /* scoped */


  var __vue_scope_id__$B = "data-v-20303d2e";
  /* module identifier */

  var __vue_module_identifier__$p = undefined;
  /* functional template */

  var __vue_is_functional_template__$B = false;
  /* component normalizer */

  function __vue_normalize__$B(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "PreviewOverlay.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;
    {
      var hook;

      if (style) {
        hook = function hook(context) {
          style.call(this, createInjector(context));
        };
      }

      if (hook !== undefined) {
        if (component.functional) {
          // register for functional component in vue file
          var originalRender = component.render;

          component.render = function renderWithStyleInjection(h, context) {
            hook.call(context);
            return originalRender(h, context);
          };
        } else {
          // inject component registration as beforeCreate hook
          var existing = component.beforeCreate;
          component.beforeCreate = existing ? [].concat(existing, hook) : [hook];
        }
      }
    }
    return component;
  }
  /* style inject */


  function __vue_create_injector__$p() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$p.styles || (__vue_create_injector__$p.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());
    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = {
        ids: [],
        parts: [],
        element: undefined
      });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;
        style.ids.push(id);

        if (css.map) {
          // https://developer.chrome.com/devtools/docs/javascript-debugging
          // this makes source maps inside style tags work properly in Chrome
          code += '\n/*# sourceURL=' + css.map.sources[0] + ' */'; // http://stackoverflow.com/a/26603875

          code += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(css.map)))) + ' */';
        }

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';
          if (css.media) el.setAttribute('media', css.media);

          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */


  __vue_normalize__$B({
    render: __vue_render__$B,
    staticRenderFns: __vue_staticRenderFns__$B
  }, __vue_inject_styles__$B, __vue_script__$B, __vue_scope_id__$B, __vue_is_functional_template__$B, __vue_module_identifier__$p, __vue_create_injector__$p);

  //
  var script$2 = {
    name: 'file-input',
    mixins: [uploadMixin],
    props: {
      id: {
        type: String,
        "default": function _default() {
          return uniqueId__default['default']('file_');
        }
      },
      fileKey: {
        type: String,
        "default": ''
      },
      fileName: {
        type: String,
        "default": ''
      },
      validate: {
        type: Object,
        "default": function _default() {
          return {
            ext: []
          };
        }
      },
      label: {
        type: String,
        "default": 'File upload'
      },
      placeholder: {
        type: String,
        "default": 'Choose a file'
      },
      outlined: {
        type: Boolean,
        "default": false
      },
      dense: {
        type: Boolean,
        "default": false
      }
    },
    computed: {
      acceptedFileTypes: function acceptedFileTypes() {
        var ext = get__default['default'](this.validate, 'ext', []);
        return ext.length ? ".".concat(ext.join(',.')) : '';
      }
    },
    watch: {
      uploading: function uploading(val) {
        this.$emit('update:uploading', val);
      }
    }
  };

  /* script */
  var __vue_script__$2 = script$2;
  /* template */

  var __vue_render__$2 = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('form', {
      on: {
        "submit": function submit($event) {
          $event.preventDefault();
        }
      }
    }, [!_vm.fileKey ? _c('v-file-input', {
      ref: _vm.id,
      attrs: {
        "accept": _vm.acceptedFileTypes,
        "label": _vm.label,
        "placeholder": _vm.placeholder,
        "outlined": _vm.outlined,
        "dense": _vm.dense,
        "clearable": false,
        "append-icon": _vm.uploading ? 'mdi-loading mdi-spin' : 'mdi-upload',
        "prepend-icon": ""
      },
      on: {
        "click:append": function clickAppend($event) {
          _vm.$refs[_vm.id].$el.querySelector('input').click();
        }
      },
      nativeOn: {
        "change": function change($event) {
          return _vm.upload($event);
        }
      }
    }) : _c('div', {
      staticClass: "mb-5 px-1 grey--text text--darken-3"
    }, [_c('div', [_vm._v(_vm._s(_vm.label))]), _vm._v(" "), _c('v-btn', {
      staticClass: "grey--text text--darken-4 text-none px-0",
      attrs: {
        "text": ""
      },
      on: {
        "click": function click($event) {
          return _vm.downloadFile(_vm.fileKey, _vm.fileName);
        }
      }
    }, [_vm._v("\n      " + _vm._s(_vm._f("truncate")(_vm.fileName, 35)) + "\n    ")]), _vm._v(" "), _c('v-btn', {
      staticClass: "ml-1",
      attrs: {
        "color": "grey darken-4",
        "icon": "",
        "x-small": ""
      },
      on: {
        "click": function click($event) {
          return _vm.deleteFile({
            id: _vm.id,
            fileName: _vm.fileName
          });
        }
      }
    }, [_c('v-icon', [_vm._v("mdi-close")])], 1)], 1)], 1);
  };

  var __vue_staticRenderFns__$2 = [];
  /* style */

  var __vue_inject_styles__$2 = undefined;
  /* scoped */

  var __vue_scope_id__$2 = undefined;
  /* functional template */

  var __vue_is_functional_template__$2 = false;
  /* component normalizer */

  function __vue_normalize__$2(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "FileInput.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */

  /* style inject SSR */


  var FileInput = __vue_normalize__$2({
    render: __vue_render__$2,
    staticRenderFns: __vue_staticRenderFns__$2
  }, __vue_inject_styles__$2, __vue_script__$2, __vue_scope_id__$2, __vue_is_functional_template__$2);

  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  var script$1 = {
    name: 'tailor-inline-activator',
    inheritAttrs: false,
    props: {
      disabled: {
        type: Boolean,
        required: false
      }
    }
  };

  /* script */
  var __vue_script__$1 = script$1;
  /* template */

  var __vue_render__$1 = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('button', _vm._g({
      staticClass: "inline-activator",
      "class": {
        disabled: _vm.disabled
      }
    }, _vm.$listeners), [_c('hr'), _vm._v(" "), _c('v-avatar', {
      attrs: {
        "size": "20",
        "color": "primary darken-4"
      }
    }, [_c('v-icon', {
      attrs: {
        "size": "16",
        "dark": ""
      }
    }, [_vm._v("mdi-plus")])], 1), _vm._v(" "), _c('hr')], 1);
  };

  var __vue_staticRenderFns__$1 = [];
  /* style */

  var __vue_inject_styles__$1 = function __vue_inject_styles__(inject) {
    if (!inject) return;
    inject("data-v-64eb8c58_0", {
      source: ".default-activator-state[data-v-64eb8c58],.inline-activator[data-v-64eb8c58],.inline-activator.disabled[data-v-64eb8c58],.inline-activator.disabled[data-v-64eb8c58]:hover{padding:0 3.125rem;opacity:0}.inline-activator[data-v-64eb8c58]{display:flex;align-items:center;width:100%;margin:0;padding:0 3.125rem;opacity:0;transition:opacity .3s,padding .3s}.inline-activator[data-v-64eb8c58],.inline-activator .v-chip[data-v-64eb8c58]{cursor:pointer}.inline-activator hr[data-v-64eb8c58]{flex:1;display:inline-flex;margin:0;border-top:.0625rem dashed var(--v-primary-darken3)}.inline-activator[data-v-64eb8c58]:focus,.inline-activator[data-v-64eb8c58]:hover{padding:.75rem 0;opacity:1;outline:0;transition:opacity .3s .25s,padding .3s .1s}.inline-activator.disabled[data-v-64eb8c58],.inline-activator.disabled[data-v-64eb8c58]:hover{pointer-events:none}",
      map: undefined,
      media: undefined
    });
  };
  /* scoped */


  var __vue_scope_id__$1 = "data-v-64eb8c58";
  /* module identifier */

  var __vue_module_identifier__$1 = undefined;
  /* functional template */

  var __vue_is_functional_template__$1 = false;
  /* component normalizer */

  function __vue_normalize__$1(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "InlineActivator.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    {
      var hook;

      if (style) {
        hook = function hook(context) {
          style.call(this, createInjector(context));
        };
      }

      if (hook !== undefined) {
        if (component.functional) {
          // register for functional component in vue file
          var originalRender = component.render;

          component.render = function renderWithStyleInjection(h, context) {
            hook.call(context);
            return originalRender(h, context);
          };
        } else {
          // inject component registration as beforeCreate hook
          var existing = component.beforeCreate;
          component.beforeCreate = existing ? [].concat(existing, hook) : [hook];
        }
      }
    }

    return component;
  }
  /* style inject */


  function __vue_create_injector__$1() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__$1.styles || (__vue_create_injector__$1.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());
    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = {
        ids: [],
        parts: [],
        element: undefined
      });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;
        style.ids.push(id);

        if (css.map) {
          // https://developer.chrome.com/devtools/docs/javascript-debugging
          // this makes source maps inside style tags work properly in Chrome
          code += '\n/*# sourceURL=' + css.map.sources[0] + ' */'; // http://stackoverflow.com/a/26603875

          code += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(css.map)))) + ' */';
        }

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';
          if (css.media) el.setAttribute('media', css.media);

          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */


  var InlineActivator = __vue_normalize__$1({
    render: __vue_render__$1,
    staticRenderFns: __vue_staticRenderFns__$1
  }, __vue_inject_styles__$1, __vue_script__$1, __vue_scope_id__$1, __vue_is_functional_template__$1, __vue_module_identifier__$1, __vue_create_injector__$1);

  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  var script = {
    name: 'tailor-preview-overlay',
    props: {
      show: {
        type: Boolean,
        "default": false
      }
    }
  };

  /* script */
  var __vue_script__ = script;
  /* template */

  var __vue_render__ = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('v-overlay', {
      attrs: {
        "value": _vm.show,
        "opacity": "0.9",
        "absolute": ""
      }
    }, [_c('button', {
      staticClass: "message pa-2 grey--text text--lighten-2"
    }, [_vm._t("default", [_vm._v("Click to preview")])], 2)]);
  };

  var __vue_staticRenderFns__ = [];
  /* style */

  var __vue_inject_styles__ = function __vue_inject_styles__(inject) {
    if (!inject) return;
    inject("data-v-20303d2e_0", {
      source: ".message[data-v-20303d2e]{border-radius:2px;font-size:1.125rem}",
      map: undefined,
      media: undefined
    });
  };
  /* scoped */


  var __vue_scope_id__ = "data-v-20303d2e";
  /* module identifier */

  var __vue_module_identifier__ = undefined;
  /* functional template */

  var __vue_is_functional_template__ = false;
  /* component normalizer */

  function __vue_normalize__(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "PreviewOverlay.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    {
      var hook;

      if (style) {
        hook = function hook(context) {
          style.call(this, createInjector(context));
        };
      }

      if (hook !== undefined) {
        if (component.functional) {
          // register for functional component in vue file
          var originalRender = component.render;

          component.render = function renderWithStyleInjection(h, context) {
            hook.call(context);
            return originalRender(h, context);
          };
        } else {
          // inject component registration as beforeCreate hook
          var existing = component.beforeCreate;
          component.beforeCreate = existing ? [].concat(existing, hook) : [hook];
        }
      }
    }

    return component;
  }
  /* style inject */


  function __vue_create_injector__() {
    var head = document.head || document.getElementsByTagName('head')[0];
    var styles = __vue_create_injector__.styles || (__vue_create_injector__.styles = {});
    var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());
    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

      var group = isOldIE ? css.media || 'default' : id;
      var style = styles[group] || (styles[group] = {
        ids: [],
        parts: [],
        element: undefined
      });

      if (!style.ids.includes(id)) {
        var code = css.source;
        var index = style.ids.length;
        style.ids.push(id);

        if (css.map) {
          // https://developer.chrome.com/devtools/docs/javascript-debugging
          // this makes source maps inside style tags work properly in Chrome
          code += '\n/*# sourceURL=' + css.map.sources[0] + ' */'; // http://stackoverflow.com/a/26603875

          code += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(css.map)))) + ' */';
        }

        if (isOldIE) {
          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
        }

        if (!style.element) {
          var el = style.element = document.createElement('style');
          el.type = 'text/css';
          if (css.media) el.setAttribute('media', css.media);

          if (isOldIE) {
            el.setAttribute('data-group', group);
            el.setAttribute('data-next-index', '0');
          }

          head.appendChild(el);
        }

        if (isOldIE) {
          index = parseInt(style.element.getAttribute('data-next-index'));
          style.element.setAttribute('data-next-index', index + 1);
        }

        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
        } else {
          var textNode = document.createTextNode(code);
          var nodes = style.element.childNodes;
          if (nodes[index]) style.element.removeChild(nodes[index]);
          if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
        }
      }
    };
  }
  /* style inject SSR */


  var PreviewOverlay = __vue_normalize__({
    render: __vue_render__,
    staticRenderFns: __vue_staticRenderFns__
  }, __vue_inject_styles__, __vue_script__, __vue_scope_id__, __vue_is_functional_template__, __vue_module_identifier__, __vue_create_injector__);

  exports.ActiveUsers = ActiveUsers$1;
  exports.AddElement = AddElement$1;
  exports.AssessmentItem = AssessmentItem;
  exports.AssetInput = AssetInput;
  exports.ContainedContent = ContainedContent$1;
  exports.ContentElement = ContentElement$3;
  exports.DatePicker = DatePicker;
  exports.Discussion = Discussion$3;
  exports.ElementList = ElementList$1;
  exports.ElementPlaceholder = ElementPlaceholder;
  exports.EmbeddedContainer = EmbeddedContainer;
  exports.FileInput = FileInput;
  exports.InlineActivator = InlineActivator;
  exports.InputError = InputError$1;
  exports.PreviewOverlay = PreviewOverlay;
  exports.PublishDiffChip = PublishDiffChip$1;
  exports.QuestionContainer = TceQuestionContainer$1;
  exports.SelectElement = SelectElement$1;
  exports.UploadBtn = UploadBtn$1;
  exports.upload = uploadMixin$1;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
