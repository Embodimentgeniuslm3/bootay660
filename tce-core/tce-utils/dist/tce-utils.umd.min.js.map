{"version":3,"file":"tce-utils.umd.min.js","sources":["../src/InsertLocation.js","../src/calculatePosition.js"],"sourcesContent":["export default {\n  ADD_BEFORE: 'ADD_BEFORE',\n  ADD_AFTER: 'ADD_AFTER',\n  ADD_INTO: 'ADD_INTO',\n  REORDER: 'REORDER'\n};\n","import InsertLocation from './InsertLocation';\n\nconst { ADD_AFTER, REORDER } = InsertLocation;\n\nconst distributePositions = ({ lower = 0, upper }, count) => {\n  const delta = upper ? (upper - lower) / (count + 1) : 1;\n  return Array.from({ length: count }).map((_, i) => delta * (i + 1) + lower);\n};\n\nfunction getDeprecationWarning(config) {\n  if (!Object.prototype.hasOwnProperty.call(config, 'isFirstChild')) return;\n  console.warn(`Deprecation notice:\n    'isFirstChild' option is deprecated and no longer used!\n    Providing it does not affect this function.`);\n}\n\nexport const getPositions = (items, index, count = 1) => {\n  const { position: lower } = items[index - 1] || {};\n  const { position: upper } = items[index] || {};\n  return distributePositions({ lower, upper }, count);\n};\n\n/**\n * Calculates item position(s) based on the options provided.\n * @param {number} newPosition The index of the anchor item by which the new\n *     positions will be calculated. Defaults to the end of the `items` array.\n * @param {Object[]} items An array of objects in which we are determining\n *     item's new position.\n * @param {boolean} isFirstChild Deprecated: Boolean value denoting whether\n *     the item should be placed as the first child of its parent.\n * @param {\"ADD_AFTER\" | \"ADD_BEFORE\" | \"REORDER\" } [action=REORDER]\n *     A string value determining where the item should be placed\n *     in relation to `newPosition`.\n *     `ADD_BEFORE` returns position(s) placed before the anchor element.\n *     `ADD_AFTER` returns position(s) placed after the anchor element.\n *     `REORDER` returns calculated position(s) based on `position` property of\n *     adjacent elements.\n *     Defaults to `REORDER`.\n * @param {number} count A number of items for which position needs to be\n *     determinate.\n * @return {(number|Array)} Single position if `count` is 1 or an array containing\n *     `count` positions.\n */\nexport function calculatePosition({ newPosition, items, action = REORDER, count = 1 }) {\n  getDeprecationWarning(...arguments);\n  const arr = [...items];\n  if (action === REORDER) arr.splice(newPosition, count);\n  let index = items.length;\n  if (newPosition !== undefined) {\n    index = action === ADD_AFTER ? newPosition + 1 : newPosition;\n  }\n  const positions = getPositions(arr, index, count);\n  return count === 1 ? positions[0] : positions;\n}\n"],"names":["ADD_BEFORE","ADD_AFTER","ADD_INTO","REORDER","InsertLocation","distributePositions","count","lower","upper","delta","Array","from","length","map","_","i","getDeprecationWarning","config","Object","prototype","hasOwnProperty","call","console","warn","getPositions","items","index","position","newPosition","action","arguments","arr","splice","undefined","positions"],"mappings":"g+BAAe,CACbA,WAAY,aACZC,UAAW,YACXC,SAAU,WACVC,QAAS,uDCFHF,EAAuBG,EAAvBH,UAAWE,EAAYC,EAAZD,QAEbE,EAAsB,WAAuBC,WAApBC,MAAAA,aAAQ,IAAGC,IAAAA,MAClCC,EAAQD,GAASA,EAAQD,IAAUD,EAAQ,GAAK,SAC/CI,MAAMC,KAAK,CAAEC,OAAQN,IAASO,KAAI,SAACC,EAAGC,UAAMN,GAASM,EAAI,GAAKR,MAGvE,SAASS,EAAsBC,GACxBC,OAAOC,UAAUC,eAAeC,KAAKJ,EAAQ,iBAClDK,QAAQC,8IAKGC,EAAe,SAACC,EAAOC,OAAOpB,yDAAQ,IACrBmB,EAAMC,EAAQ,IAAM,GAA9BnB,IAAVoB,WACoBF,EAAMC,IAAU,GAA1BlB,IAAVmB,gBACDtB,EAAoB,CAAEE,MAAAA,EAAOC,MAAAA,GAASF,2CAwBxC,gBAA6BsB,IAAAA,YAAaH,IAAAA,UAAOI,OAAAA,aAAS1B,QAASG,MAAAA,aAAQ,IAChFU,eAAyBc,eACnBC,IAAUN,GACZI,IAAW1B,GAAS4B,EAAIC,OAAOJ,EAAatB,OAC5CoB,EAAQD,EAAMb,YACEqB,IAAhBL,IACFF,EAAQG,IAAW5B,EAAY2B,EAAc,EAAIA,OAE7CM,EAAYV,EAAaO,EAAKL,EAAOpB,UAC1B,IAAVA,EAAc4B,EAAU,GAAKA"}